[
{
	"uri": "http://ysjune.github.io/en/posts/clean-code/chapter1/",
	"title": "1. 깨끗한 코드",
	"tags": [],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "1. 깨끗한 코드 코드가 존재하리라 어느 수준에 이르면 코드의 도움 없이 요구사항을 상세하게 표현하기란 불가능 하기에 코드가 사라질 가망은 없다.  궁극적으로 코드는 요구사항을 표현하는 언어라는 사실을 명심 \n나쁜코드 나쁜 코드에 발목이 잡혀 고생한 기억은 많다. 실제로 고행이라는 이름도 있다. 어째서 나쁜 코드를 짰는가? -\u0026gt; 당장 급해서, 서두르느라 자신이 짠 쓰레기 코드를 쳐다보며 나중에 고쳐야겠다고 생각한다. But, 나중은 오지 않는다. (르블랑의 법칙) \n나쁜 코드로 치르는 대가 나쁜 코드는 개발 속도를 크게 떨어뜨린다. -\u0026gt; 코드를 고칠 때마다 엉뚱한 곳에서 문제가 생기기 때문 -\u0026gt;  결국 생산성이 0에 수렴 -\u0026gt; 재설계를 시작 -\u0026gt;  기존의 것을 100% 수용하지 않으면 관리층에서는 대체하려고 하지 않을 것이고,  오래 지속되다보면 이탈 맴버가 생겨 흐지부지하게 된다. \nConclusion.  시간을 들여 깨끗한 코드를 만드는 노력이 비용을 절감하는 방법이며, 전문가로서 살아남는 길 \n태도 우리는 프로다. 나쁜 코드의 위험을 이해하지 못하는 관리자 말을 그대로 따르는 행동은 전문가(프로)답지 못하다. \n원초적 난제 빨리 가려고 나쁜 코드를 양상하는 경우가 있다. 하지만 이는 잘못된 판단으로 빨리가는 유일한 방법은 언제나 코드를 깨끗하게 유지하는 습관이다. \n깨끗한 코드라는 예술? 깨끗한 코드와 나쁜 코드를 구분할 줄 안다고 깨끗한 코드를 작성할 줄 안다는 뜻은 아니다. 열쇠는 코드 감각이다. \u0026lsquo;코드 감각'이 없는 프로그래머도 나쁜 모듈을 알아보긴 하지만 거기서 끝이다. \n우리는 저자다 Javadoc 에서 @author 필드는 저자를 소개 저자는 독자와 잘 소통할 책임이 있다. 코드를 읽는 시간 대 코드를 짜는 시간 비율이 10 대 1을 훌쩍 넘는다. 우리는 끊임없이 코드를 읽는다. 그렇기에 읽기 쉬운 코드를 짜야 한다. \n보이스카우드 규칙 캠프장은 처음 왔을 때보다 더 깨끗하게 해놓고 떠나라 \n결론 예술에 대한 책을 읽는다고 예술가가 된다는 보장은 없다. 책은 단지 다른 예술가가 사용하는 도구와 기법, 그리고 생각하는 방식을 소개할 뿐이다. 이 책을 어떻게 활용할지는 독자에게 달렸다. \n사견을 덧붙이자면..? 돌아보면 항상.. 안되는 것보단 굴러가는 쓰레기라도 만든다는 느낌으로 일단 구현을 우선했던 것 같다. 물론, 만들면서 더 좋은 건 없을까 고민은 했지..만 잠깐일 뿐이다. 구현을 다 하면 다른 거 하기 바쁜 그런 생활을 보냈던 것 같다. 그리고 \u0026lsquo;코드 감각\u0026rsquo; 이라는 얘기가 나오는데, 이 부분은 리펙토링 책에 나오는 \u0026lsquo;냄새\u0026rsquo; 와 비슷하지 않은가 싶었다.  어느 정도 경험에 의해 생기는 그런..? 보이 스카우트 규칙이야 워낙 유명하니.. (남자고 군필자라면 다 알거다..) 마지막에 나오는 결론은 많은 생각을 하게 한다.\n 예술에 대한 책을 읽는다고 예술가가 된다는 보장은 없다.  클린 코드는 이전에 한 번 읽었었다. 읽을 때마다 이렇게 해야지 하는 마음은 생기는데, 막상 코드 앞에서의 나는 책의 내용을 많이 실천하지는 못하는 것 같다. 이번에는 읽은 챕터마다 정리를 할 예정이니 자주 보면서 많이 실천하려고 노력하지 않을까? 싶다 :)\n "
},
{
	"uri": "http://ysjune.github.io/en/posts/clean-code/chapter10/",
	"title": "10. 클래스",
	"tags": [],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "10. 클래스 클래스 체계 공개에서 비공개 형식으로 진행되어 추상화 단계가 순차적으로 내려간다.\n캡슐화 변수와 유틸리티 함수는 가능한 공개하지 않는 편이 낫지만 반드시 숨겨야 한다는 법칙도 없다.  테스트에서 사용한다면 protected 도 고려할만하다. 하지만, 그 전에 비공개 상태를 유지할 온갖 방법을 강구한다.  캡슐화를 풀어주는 결정은 언제나 최후의 수단이다.\n클래스는 작아야 한다. 클래스는 작아야 한다. 클래스를 설계할 때도 함수와 마찬가지로 \u0026lsquo;작게\u0026rsquo; 가 기본 규칙이다.  그렇다면 얼마나 작아야 할까? 함수는 물리적인 행 수로 크기를 측정했다.  클래스에서는 클래스가 맡은 책임을 센다.  클래스 이름은 해당 클래스 책임을 기술해야 한다.  실제로 작명은 클래스 크기를 줄이는 첫 번째 관문이다. 간결한 이름이 떠오르지 않는다면 필시 맡은 역할이 너무 많이 때문이다.\n단일 책임 원칙(SRP : Single Responsibility Principle) 클래스나 모듈을 변경할 이유가 하나, 단 하나뿐이어야 한다는 원칙이다.  책임, 즉 변경할 이유를 파악하려 애쓰다 보면 코드를 추상화하기도 쉬워진다. 더 좋은 추상화가 더 쉽게 떠오른다.  단일 책임 원칙은 설계자가 가장 무시하는 규칙중 하나이다.  소프트웨어를 돌아가게 만드는 활동과 소프트웨어를 깨끗하게 만드는 활동은 완전히 별개다.  우리는 주로 \u0026lsquo;깨끗한\u0026rsquo; 보다는 \u0026lsquo;돌아가는\u0026rsquo; 에 초점을 맞추기 때문이다.  물론 중요하긴 하지만, 문제는 돌아가는 데에서 끝낸다는 것이다. 다음 관심사인 깨끗한 에는 관심을 기울이지 않는다. 규모가 어느정도 되는 시스템은 논리가 많고 복잡하다.  이런 복잡성을 다루려면 체계적인 정리가 필수다.  그래야 개발자가 어디에 무엇이 있는지 쉽게 찾을 수 있고, 변경을 했을 때 직접적인 영향을 미치는 컴포넌트만 알아도 충분하다. 큰 클래스 몇 개로 이뤄진 것보다 작은 클래스 여럿으로 이뤄진 시스템이 훨씬 바람직하다\n응집도 클래스는 인스턴스 변수 수가 작아야 한다.  각 클래스 메서드는 클래스 인스턴스 변수를 하나 이상 사용해야 한다.  일반적으로 메서드가 변수를 더 많이 사용할수록 메서드와 클래스는 응집도가 더 높다.  \u0026lsquo;함수를 작게, 매개변수 목록을 짧게\u0026rsquo; 라는 전략을 따르다보면 때때로 몇몇 메서드 만이 사용하는 인스턴스 변수가 많아지는 경우가 생기는데,  이는 새로운 클래스로 쪼개야 한다는 신호다.  응집도를 유지하면 작은 클래스 여럿이 나온다.\n변경하기 쉬운 클래스 대다수 시스템은 지속적인 변경이 가해진다.  그리고 뭔가 변경할 때마다 시스템이 의도대로 동작하지 않을 위험이 따른다.  새 기능을 수정하거나 기존 기능을 변경할 때 건드릴 코드가 최소인 시스템 구조가 바람직하다.  이상적인 시스템이라면 새 기능을 추가할 때 시스템을 확장할 뿐 기존 코드를 변경하지는 않는다.\n변경으로부터 격리 요구사항은 변하기 마련이다. 따라서 코드도 변하기 마련이다.  객체 지향에서 구체적인 클래스는 상세한 구현을 포함하며 추상 클래스는 개념만 포함한다고 배웠다.  상세한 구현이 의존하는 클라이언트 클래스는 구현이 바뀌면 위험에 빠진다.  그렇기에 인터페이스와 추상 클래스를 사용해 구현에 미치는 영향을 격리한다.  시스템의 결합도를 낮추면 유연성과 재사용성도 더욱 높아진다.  결합도가 낮다는 소리는 각 시스템 요소가 다른 요소로부터 그리고 변경으로부터 잘 격리되어 있다는 의미다.  결합도를 최소로 줄이면 자연스럽게 또 다른 클래스 설계 원칙인  DIP (Dependency Inversion Principle) 를 따른 클래스가 나온다.  이 원칙은 상세한 구현이 아니라 추상화에 의존해야 한다는 원칙이다.\n사견을 덧붙이면\u0026hellip;? 이번 장은 직접 보여주는 코드가 많은 장이다. 살짝 고민을 하긴 했다. 코드를 넣을지 말지. 하지만, 이 정리를 할 때 \u0026lsquo;최대한 글 위주로 하자\u0026rsquo; 란 생각을 했기에..  서론은 넘어가고, 클래스를 작성할 때 항상 해당 클래스가 어디에 위치하면 좋을지, 이 클래스가 어느부분까지 역할을 맡아야 하는지 고민하는 나에겐  이번 단일책임원칙 은 고개를 끄덕이게 한다. 하지만, 아직까지 구현이 우선인 생활을 하는 나에겐 정리가 쉽진 않다.  그래도 어느정도 책으로 배운 예측 통해 평소에 조금조금씩 수정하는 마음가짐을 가져야겠지\n"
},
{
	"uri": "http://ysjune.github.io/en/posts/clean-code/chapter11/",
	"title": "11. 시스템",
	"tags": [],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "11. 시스템 시스템 제작과 시스템 사용을 분리하라 제작과 사용은 다르다.  체계적이고 탄탄한 시스템을 만들고 싶다면 흔히 쓰는 손쉬운 기법으로 무듈성을 깨서는 안된다. 설정 논리는 일반 실행 논리와 분리해야 모듈성이 높아진다.\nMain 분리 시스템 생성과 시스템 사용을 분리하는 한 가지 방법으로,  생성과 관련한 코드는 모두 main 이나 main 이 호출하는 모듈로 옮기고,  나머지 시스템은 모든 객체가 생성되었고 모든 의존성이 연결되었다고 가정한다.\n팩토리 때로는 객체가 생성되는 시점을 애플리케이션이 결정할 필요도 생긴다.  이럴 때는 추상 팩토리 패턴을 사용하여 결정은 애플리케이션이 하지만, 생성 코드는 애플리케이션이 모르게 할 수 있다.\n의존성 주입 제어의 역전(IoC) 기법을 사용하는데,  한 객체가 맡은 보조 책임을 새로운 객체에게 전적으로 떠넘기는 것.  새로운 객체는 넘겨받은 책임만 맡으므로 단일 책임 원칙을 지키게 된다.\n확장 처음부터 확장을 생각하여 들어가는 비용을 정당화하긴 어렵다.  (시골에 확장성을 고려해 처음부터 6차선 도로를 만든다면\u0026hellip;??)  \u0026lsquo;처음부터 올바르게\u0026rsquo; 시스템을 만들 수 있다는 믿음은 미신이다.  오늘은 주어진 사용자의 스토리에 맞게 구현을 하고, 내일은 새로운 스토리에 맞춰 조정하고 확장한다.\n횡단(cross-cutting) 관심사 EJB2 아키텍처는 일부 영역에서 관심사를 거의 완벽하게 분리한다.  예를 들어 트랜잭션, 보안, 일부 영속적인 동작은 소스 코드가 아닌 배치 기술자에서 정의,  영속성과 같은 관심사는 애플리케이션의 자연스럽게 객체 경계를 넘나든다.\n자바 프록시 자바 프록시는 단순한 상황에 적합, 개별 객체나 클래스에서 메서드 호출을 감싸는 경우가 좋은 예.\nAspectJ 관점 관심사를 관점을 분리하는 가장 강력한 도구는 AspectJ 언어이다.  AspectJ는 언어 차원에서 관점을 모듈화 구성으로 지원하는 자바 언어 확장이다.\n테스트 주도 시스템 아키텍처 구축 애플리케이션 도메인 논리를 POJO 로 작성할 수 있다면,  즉 코드 수준에서 아키텍처 관심사를 분리할 수 있다면, 진정한 테스트 주도 아키텍처 구축이 가능해진다.  프로젝트를 시작할 때는 일반적인 범위, 목표, 일정은 물론이고 결과로 내놓을 시스템의 일반적인 구조도 생각해야 한다.  하지만 변하는 환경에 대처해 진로를 변경할 능력도 반드시 유지해야 한다. \n  최선의 시스템 구조는 각기 POJO 객체로 구현되는 모듈화된 관심사 영역(도메인) 으로 구성된다.  이렇게 서로 다른 영역을 해당 영역 코드에 최소한의 영향을 미치는 관점이나 유사한 도구를 사용해 통합한다.  이런 구조 역시 코드와 마찬가지로 테스트 주도 기법을 적용할 수 있다.\n  의사 결정을 최적화하라 가능한 마지막 순간까지 결정을 미루는 방법이 최선이다.  최대한 정보를 모아 최선의 결정을 내리기 위함\n명백한 가치가 있을 때 표준을 현명하게 사용하라 표준을 사용하면 재사용성이 증가하고, 캡슐화 하기 쉽다는 장점이 있겠지만,  때로는 표준을 만드는 시간이 너무 오래 걸리는 (배보다 배꼽이 더 큰) 케이스도 있다.\n결론 시스템은 깨끗해야된다. 그렇지 못한 시스템은 도메인 논리를 흐리며 기민성을 떨어뜨린다.  시스템을 설계하든 개별 모듈을 설계하든, 실제로 돌아가는 가장 단순한 수단을 사용해야 한다는 사실을 명심하자.\n사견을 덧붙이면\u0026hellip;? 음\u0026hellip; 이번 챕터는 굉장히 자바스럽다. 아니, 스프링 스럽다? 라고 해야하나?  뭐하튼, 그렇다. 깨끗한 구조를 설명하고 있긴 하지만, 마치 스프링의 역사를 보는 느낌? (EJB1,2,3 에 대한 얘기가 나오고, 스프링 프레임워크의 등장에 대한 얘기가 나온다.)  그런 느낌으로 읽었다. 내가 스프링 개념이 빈약해서 그런지..(..) 쉽게 이해가 안되는 부분도 있고, 쉽게 읽히지는 않았다.  중간에 보면 확장 에 관련된 얘기가 나온다. 이 부분에 관해서인데,  이전에 사수가 있었을 때, 서로 추구랄까? 스타일이랄까? 그런게 꽤 달랐다.  사수는 빨리 만들고 빨리 버리자 (일종의 빠른 프로토 타이핑으로 일단 만들고 돌려봐서 확장을 고려하자) 였고,  난 기능을 만들되 최대한 확장성을 고려하여 진행하자. 였다.  그러다보니 속도? 그런 건 말할 것도 없고 ㅋㅋㅋㅋ, 그 후 사수랑 얘기를 하는데, 본인도 처음에는 나와 비슷한 스타일이었다고 한다.  그런데 기획이 하도 바뀌니까 빨리 대충 만들고, 리펙토링을 중점으로 하게 되었다고\u0026hellip;  근데 요즘 보면 이 말이 참 맞는 것 같다. 기획이 참 잘 바뀌여\u0026hellip; 에자일도 아닌데 말이지..\n"
},
{
	"uri": "http://ysjune.github.io/en/posts/clean-code/chapter12/",
	"title": "12. 창발성",
	"tags": [],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "12. 창발성 창발적 설계로 깔끔한 코드를 구현하자  켄트 벡이 제시한 단순한 설계 규칙 4가지    모든 테스트를 실행하라 무엇보다도 먼저 설계는 의도한 대로 돌아가는 시스템을 내놓아야 한다.  테스트가 불가능한 시스템은 검증도 불가능하며, 검증이 불가능한 시스템은 출시하면 안된다고 생각한다.  테스트 케이스를 만들고 계속 돌려라 라는 단순한 규칙을 따르면 시스템은 낮은 결함도와 높은 응집력이라는,  객체 지향 방법론이 지향하는 목표를 저절로 달성한다.\n  중복을 없애라 우수한 설계에서 중복은 커다란 적이다.  똑같은 코드는 당연히 중복이고, 비슷한 코드는 더 비슷하게 고쳐주면 리펙토링이 쉬워진다.  구현 중복도 중복의 한 형태이다. 소규모 재사용은 시스템 복잡도를 극적으로 줄여주고, 추후 대규모 재사용을 가능토록 한다.\n  프로그래머 의도를 표현한다 자신이 이해하는 코드를 짜기는 쉽다. 코드를 짜는 동안에는 문제에 푹 빠져 코드를 구석구석 이해하니까.  하지만, 나중에 코드를 유지보수할 사람이 코드를 짜는 사람만큼이나 문제를 깊이 이해할 가능성은 희박하다.  우선, 좋은 이름을 선택한다. 이름과 기능이 딴판인 클래스나 함수는 안되겠다.  둘째, 함수와 클래스 크기를 가능한 줄인다.  셋째, 표준 명칭을 사용한다. 예를 들어 디자인 패턴은 의사소통과 표현력 강화가 주요 목적이다.  패턴을 사용할 경우 패턴명을 넣어주면 더 편하다. 하지만, 표현력을 높이는 가장 중요한 방법은 노력이다.  흔히 코드만 돌린 후 다음 문제로 직행하는 사례가 비일비재한데, 나중을 위해 조금이라도 쉽게 표현하려는 고민이 필요하다.  나중 읽는 사람이 나 자신이 될 수도 있다.\n  클래스와 매서드 수를 최소로 줄인다. SRP 를 극도로 준수하면 득보다 실이 더 많아진다.  이 규칙은 \u0026lsquo;가능한\u0026rsquo; 줄이라고 제안한다. 목표는 함수와 클래스 크기를 작게 유지하면서 동시에 시스템 크기도 작게 유지하는 데에 있다.  하지만, 이 규칙은 4가지 규칙 중 우선순위가 가장 낮다, 즉 클래스와 함수 수를 줄이는 작업은 중요하지만,  테스트 케이스를 만들고 중복을 제거하고 의도를 표현하는 작업이 더 중요하다는 의미이다.\n  결론을 덧붙이면\u0026hellip;? 우선\u0026hellip; 어려운 창발이 무슨 뜻인지부터 보자.\n 창발(創發, Emergence)또는 떠오름 현상은 하위 계층(구성 요소)에는 없는 특성이나 행동이 상위 계층(전체 구조)에서 자발적으로 돌연히 출현하는 현상이다. \u0026ndash; 위키백과\n 뜻을 봐도 잘 모르겠다. 예전에 영어로는 나타난다. 이런 뜻으로 외웠던 거 같은데..  나타난다 로 생각하면 클린 코드는 위의 4가지 규칙을 통해 나타난다 (emergence) 정도가 되려나??  뭐하튼.. 이번 내용은 짧다. 하지만, 내용은 핵심적이다.  테스트 케이스를 작성 -\u0026gt; 리펙토링  현재 회사에 와서 처음에는 CMS 를 포팅(spring -\u0026gt; spring boot, angularJS -\u0026gt; Angular) 할 때는 테스트 케이스도 만들고 재밌었다.  하지만, 요즘은 기능 추가 혹은 수정 건도 없고, 두서 없는 작업 지시에, 외주가 정말.. 개판으로 짜놓은 화면 소스를 유지보수 하고 있다.  어리광 부리는 거 아니냐? 라고 할 수도 있겠지만 너무 재미가 없다.  그래서 재미좀 찾아보려고 책도 보고 정리도 하면서 하고있긴 하지만..  아니다. 어느덧 책도 5장 정도 밖에 안 남았다. (부록에 나와 있는 부분은 따로 정리를 안하려고 한다. 그냥 편하게 읽고 넘어갈까 하지만, 변심이 생겨 주말에 정리할지도\u0026hellip;?)  일단, 이 책을 다 정리하면 다음에는 어떤 책을 정리할까 고민이긴 하다.\n"
},
{
	"uri": "http://ysjune.github.io/en/posts/clean-code/chapter13/",
	"title": "13. 동시성",
	"tags": [],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "13. 동시성 동시성이 필요한 이유? 동시성은 커플링(결합)을 없애는 전략이다, 즉 무엇과 언제를 분리하는 전략이다  단일 스레드의 경우 호출 스택을 살펴보면 프로그램 상태가 곧바로 드러난다.  응답 시간과 작업 처리량 혹은 한 번에 한 사람만 처리하는 경우, 정보를 대량으로 분석하는 경우, 이런 경우를 위해 동시성이 필요하다 할 수 있다.\n미신과 오해   동시성은 성능을 높여준다 (때때로 높여준다, 각 스레드가 독립적인 행동을 취할 때) 동시성을 구현해도 설계가 바뀌지 않는다 (단일과 다중 스레드 시스템은 설계가 판이하게 다름) 웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다 (오히려 더 알아야 한다. 동시 수정, 데드락 등을 피하기 위해)   타당한 생각   동시성은 다소 부하를 유발한다 (성능 측면에서 부하가 걸리며, 코드도 더 짜야됨) 동시성은 복잡하다. 동시성 버그는 재현이 어렵다 (그렇기에 일회성 문제로 여겨 무시되는 경우가 생김) 동시성을 구현하려면 근본적인 설계 전략을 재고해야 됨   난관 두 스레드가 있을 때 두 스레드가 자바 코드 한 줄을 거쳐가는 경로는 수 없이 많다.  대부분 올바른 결과를 내놓지만, 일부가 잘못된 결과를 내놓고, 이 경우가 드물다 \n동시성 방어 원칙  단일 책임 원칙 동시성은 복잡성 하나만으로 충분히 분리할만한 가치가 있으며, 동시성을 구현할 때는 다음을 고려한다.    동시성 코드는 독자적인 개발, 변경, 조율 주기가 있다. 독자적인 난관이 있으며, 다른 코드에서 겪는 난관과는 난이도가 다르다. 잘못 구현된 코드는 별의 별 방식으로 실패한다.   권장사항 : 동시성 코드는 다른 코드와 분리하라. \n따름 정리 : 자료 범위를 제한하라 두 스레드가 공유하는 영역을 synchronized 키워드로 보호한다. 이런 임계영역의 수는 줄여야 하고, 공유 영역이 많아질 수록 다음 가능성도 커진다    보호할 임계영역을 빼먹어서 공유 자료를 수정하는 모든 코드를 망가뜨린다. 모든 임계영역을 보호했는지 확인하느라 똑같은 노력과 수고를 반복한다. 찾아내기 어려운 버그가 더 찾기 어려워진다.   권장 사항 : 자료를 캡술화 하고, 공유 자료를 최대한 줄여라\n 따름 정리 : 자료 사본을 사용하라 공유 자료를 줄이려면 처음부터 공유하지 않는 방법이 최상이다. 이럴 경우 원본은 두고 사본을 사용하는 방법이 있는데  객체를 복사하는 시간이 걸린다면 테스트를 통해 측정해본다. 하지만 사본으로 동기화를 피할 수 있다면 내부 잠금을 없애 절약한 수행 시간이  사본 생성과 가비지 컬렉션에 드는 부하를 상쇄할 가능성이 크다.\n  따름 정리 : 스레드는 가능한 독립적으로 구현하라 다른 스레드와 자료를 공유하지 않는다. 각 스레드는 클라이언트 요청 하나를 처리한다. 그러면 각 스레드는 세상에 자신만 있는 듯이 돌아갈 수 있다.\n  권장 사항 : 독자적인 스레드로, 가능하면 다른 프로세서에서 돌려도 괜찮도록 자료를 독립적인 단위로 분할하라.\n실행 모델을 이해하라   생산자 - 소비자 생산자 스레드는 대기열에 정보를 채운 다음 소비자 스레드에게 \u0026ldquo;대기열에 정보가 있다\u0026quot;는 시그널을 보낸다. 소비자 스레드는 대기열에서 정보를 읽어들인 후 \u0026ldquo;대기열에 빈 공간이 있다\u0026rdquo; 는 시그널을 보낸다. 따라서 잘못하면 생산자 스레드와 소비자 스레드가 둘 다 진행 가능함에도 불구하고 동시에 서로에게서 시그널을 기다릴 가능성이 존재한다.\n  읽기 - 쓰기 읽기 스레드의 요구와 쓰기 스레드의 요구를 적절히 만족시켜 처리율도 적당히 높고 기아도 방지하는 해법이 필요. 간단한 방법은 읽기가 없을 때까지 쓰기가 기다리는 방법이지만, 읽기가 지속될 경우 쓰기가 기아 상태에 걸린다.  반대로 쓰기 가 우선이 되면, 처리율이 떨어진다.\n  식사하는 철학자들 둥근 식탁에 철학자들이 앉아있고 각 철학자 왼쪽에는 포크가 있으며, 철학자는 스파게티를 먹을 때 양손을 사용.  철학자를 스레드로 포크를 자원으로 바꿔 생각해보라. 여러 프로세스가 자원을 얻으러 경쟁하기에, 주의해서 설계하지 않으면 데드락, 라이브락, 처리율 저하, 효율성 저하등을 겪는다.\n  권장 사항 : 설명한 3가지와 관련된 알고리즘과 각 해법을 이해해라\n동기화하는 메소드 사이에 존재하는 의존성을 이해하라 자바에서는 동기화를 위해 synchronized 를 지원하지만 공유 클래스 하나에 동기화된 메소드가 여럿이라면 구현이 올바른지 다시 한 번 확인해야된다.\n권장 사항 : 공유 객체 하나에는 메소드 하나만 사용하라\n하지만, 공유 객체 하나에 여러 메소드가 필요한 상황도 있다.\n 클라이언트에서 잠금 : 클라이언트에서 첫 번째 메소드를 호출하기 전에 서버를 잠그고, 마지막 메소드를 호출할 때까지 유지한다. 서버에서 잠금 : 서버에 \u0026ldquo;서버를 잠그고 모든 메소드를 호출한 후 잠금을 해제\u0026quot;하는 메소드를 생성, 클라이언트는 이 메소드를 호출 연결 서버 : 잠금을 수행하는 중간 단계를 생성한다. 2.서버에서 잠금 과 다른 점은 서버를 변경하지 않는 것.  동기화하는 부분을 작게 만들어라 자바에서 synchronized 를 사용하면 락이 설정된다. 락은 스레드를 지연시키고 부하를 가중시키기에 남발은 좋지 않다. 하지만, 임계영역은 반드시 보호해야 하므로 임계영역을 최대한 줄인다.\n올바른 종료 코드는 구현하기 어렵다. 영구적으로 돌아가는 시스템과 잠시 돌다 깔끔하게 종료하는 시스템은 구현하는 방법이 다르다.  깔끔하게 종료하는 코드는 올바로 구현하기가 어렵다. 절대 오지 않을 시그널을 기다리는 데드락 상태가 걸릴 수 있기 때문.\n권장 사항 : 종료 코드를 개발 초기부터 고민하고 동작하게 초기부터 구현하라, 생각보다 오래 걸리고 어렵기에 이미 나온 알고리즘을 검토\n스레드 코드 테스트하기 코드가 올바르다고 증명하기는 현실적으로 불가능하다. 테스트가 정확성을 보장하지는 않지만, 충분한 테스트는 위험을 낮춘다.\n  말이 안되는 실패는 잠정적인 스레드 문제로 취급하라 다중 스레드 코드는 때때로 말이 안되는 오류를 일으킨다. 이 일회성 문제를 계속 무시한다면 잘못된 코드 위에 코드가 쌓인다.\n  다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자 스레드 환경 밖에서 생기는 버그와 스레드 환경에서 생기는 버그를 동시에 디버깅하지 마라. 먼저 스레드 환경 밖에서 코드를 올바로 돌려라.\n  다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있게 스레드 코드를 구현하라 한 스레드로 실행, 다중으로 실행, 실행 중 스레드 수 변경, 환경 변경, 다양한 속도 등.\n  다중스레드를 쓰는 코드 부분을 상황에 맞게 조율할 수 있게 작성해라 적절한 스레드 개수를 파악할면 상당한 시행착오가 필요. 프로그램 처리율과 효율에 따라 스스로 스레드 개수를 조율하는 코드도 고민\n  프로세서 수보다 많은 스레드를 돌려보라 스와핑을 일으키려면 프로세서 수보다 많은 스레드를 돌려야 하고, 스와핑이 잦으면 문제를 일으키는 코드를 찾기 쉬워진다.\n  다른 플렛폼에서 돌려보라 처음부터 그리고 자주 모든 목표 플랫폼에서 코드를 돌려라\n  코드에 보조 코드를 넣어 돌려라. 강제로 실패를 일으키게 해보라 보조 코드를 추가하는 방법은 두 가지 (직접 구현하기, 자동화) 이다. 흔들기 기법을 사용해 오류를 찾아내보자\n  사견을 덧붙이면\u0026hellip;? 어렵다! 이 한 마디로 표현이 가능할 것 같다.  처음 자바를 공부할 때도 이 부분이 어려웠고, 현업 개발자인 지금도 스레드 관련 부분은 어렵다.  물론 개념은 알고 있다. 하지만 항상 그렇듯 이론과 실제의 갭이랄까, 현업에서 스레드를 다뤄본 기억이 그렇게 있진 않다.  그렇기 때문에 지금도 어렵다고 생각하는 것이고, 이번의 동시성 얘기도 아, 그렇구나 하는 정도로 읽었다.  정리할 때는 어느 정도 이해를 바탕으로 정리를 하는데, 이번에는 내용도 길고 퇴근 후 짬짬히 읽고 정리하는 수준이라 이틀에 걸쳐 정리하였다.  그리고 이 스레드 라는게 면접 단골 질문이기도 해서, 추후에 멀티 스레드 및 테스트에 관한 글을 또 정리할 예정이다. \n"
},
{
	"uri": "http://ysjune.github.io/en/posts/clean-code/chapter2/",
	"title": "2. 의미 있는 이름",
	"tags": [],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "2. 의미 있는 이름 의도를 분명히 밝혀라 로직이 간단한 것보단, 이름이 간단 명료한 것이 좋다. \n그릇된 정보를 피하라 유사한 개념은 유사한 표기법을 사용한다. 일관성이 떨어지는 표기법은 그릇된 정보이다. 개발자는 대부분 (객체에 달린 상세한 주석이나 제공하는 다른 목록을 보고 선택하기 보다는 이름만 보고 객체를 선택하는 경우가 대다수이다.) \n의미있게 구분하라 customerInfo 와 customer / accountData 와 account 는 구분이 가지 않는다. 읽는 사람이 차이를 알도록 이름을 지어라. \n발음하기 쉬운 이름을 사용하라 genymdhms (generate date, year, month, day, hour, minute, second) 라는 단어의 조합은 발음하기도 어렵고, 토론하기도 어렵다. \n검색하기 쉬운 이름을 사용하라 이름을 의미있게 지으면 함수가 길어지긴 하지만, 찾기는 쉬워진다. 그냥 상수나 글자 하나의 변수를 사용하는 것보단 훨씬 낫다. \n자신의 기억력을 자랑하지 마라 일반적으로 문제 영역이나 해법 영역에서 사용하지 않고,  자신이 아는 이름으로 변수를 작성한다면 나중에 문제가 생기기 마련이다. for 등을 사용하는 반복문을 제외하고는 i,j,k 등을 사용하지 않는 것이 바람직하다. \n클래스 이름 클래스 이름과 객체 이름은 명사나 명사구가 적합하다.  Customer, Account 등.. Info 등과 같은 단어는 피하고, 동사는 사용하지 않는다. \n매서드 이름 매서드 이름은 동사나 동사구가 적합하다.  postPayment, deletePage 등이 좋은 예이다. \n기발한 이름은 피하라 재미난 이름보다 명료한 이름을 선택하는 것이 좋다. \n한 개념에 한 단어를 사용하라 추상적인 개념 하나에는 단어 하나를 선택해 이를 고수해라.  예를 들어 똑같은 클래스마다 get, fetch, retrieve 등을 사용하면 혼란을 야기할 수 있다. \n말장난을 하지 마라 한 단어를 두 가지 목적으로 사용하지 마라.  예를 들어 add 라는 기존에는 두 값을 더해서 값을 구하는 메소드가 있을 때,  집합에 값 하나를 추가하는 메소드는 add 와는 맥락이 다르므로 insert 나 append 라는 이름이 적당하다. \n해법영역에서 가져온 이름을 사용하라 코드를 작성하는 사람도 코드를 읽는 사람도 프로그래머이다. 기술 개념에는 기술 이름이 가장 적합한 선택이다.  Ex) singleton, factory \n불필요한 맥락은 없애라 예를 들어 휘발유 충전소 라는 애플리케이션을 만든다고 해서 모든 클래스 앞에 GSD 를 붙인다면 이는 불필요한 맥락이다. \n결론 우리들 대다수는 자신이 짠 클래스 이름과 매서드 이름을 모두 암기하지 못한다.  그렇기 때문에 문장이나 문단처럼 읽히는 코드 아니면, 적어도 표나 자료 구조처럼 읽히는 코드를 짜는 데에 집중해야 한다. \n사견을 덧붙이면\u0026hellip;? 개인적으로는 가장 공감하면서도 지키려고 하는 챕터의 내용이다.  그리고.. 어려운 부분이기도 하다.  여러 주의점들이 있겠지만, 나에게는  특히 말장난을 하지 마라 이 부분이 가장 주의해야 할 부분이 아닌가 싶다.  개인적으로 스프링으로 개발을 할 때,  서비스 계층은 add 등의 일반적인 용어를 사용하고 Persistent 계층은 DB 친화적인 단어를 사용하여 insert 를 사용한다.  그러다보면 종국에는 만능 add 와 만능 insert 가 되는 느낌이 들곤 하는데\u0026hellip;  내 나름대로도 어떤 상황에서는 어떤 단어로 통일하자는 그런 개념? 이 확립되어야 할 것 같다.\n"
},
{
	"uri": "http://ysjune.github.io/en/posts/clean-code/chapter3/",
	"title": "3. 함수",
	"tags": [],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "3. 함수 작게 만들어라  중첩 구조가 생길만큼 함수가 커져서는 안된다는 뜻이다.  함수에서 들여쓰기 수준은 1단이나 2단을 넘어서면 안 된다.  당연한 말이지만, 그래야 함수는 읽고 이해하기 쉬워진다. \n한 가지만 해라 함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다.  그 한 가지만을 해야 한다. \n함수 당 추상화 수준은 하나로 함수가 확실히 한 가지 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일해야 한다.  한 함수 내에 추상화 수준을 섞으면 코드를 읽는 사람이 헷갈린다.  특정 표현이 근본 개념인지, 아니면 세부사항인지 구분하기 어려운 탓이다.  그리고 구분하기 어려워지면 세부사항에 세부사항을 더 붙이는 복잡한 함수가 된다. \n위에서 아래로 내려가기 규칙 코드는 위에서 아래로 이야기처럼 읽혀야 좋다.  한 함수 다음에는 추상화 수준이 한 단계 낮은 함수가 온다,  즉 위에서 아래로 프로그램을 읽으면 함수 추상화 수준이 한 번에 한 단계씩 낮아진다. \n서술적인 이름을 사용하라 testableHtml -\u0026gt; SetupTeardownIncluder 좋은 이름이 주는 가치는 강조해도 모자르지 않다. \n함수 인수 함수에서 이상적인 인수 개수는 0개(무항) 이다.  다음은 1개, 다음은 2개이다. 3항은 가능하면 피하는 것이 좋고, 4항 이상일 경우에는 특별한 이유가 필요하다.  그리고 특별한 이유가 있어도 사용하길 지양한다. \n부수 효과를 일으키지 마라! 함수에서 한 가지를 하겠다고 약속하고선 남 몰래 다른 일을 한다.  이는 때로 예상치 못한 변수가 발생할 수 있다. \n명령과 조회를 분리하라 함수는 뭔가를 수행하거나 뭔가에 답하거나 둘 중 하나만 해야 한다.  객체 상태를 변경하거나 아니면 객체 정보를 반환하거나 둘 중 하나다. 둘 다 하면 혼란을 초래한다. \n오류 코드보다 예외를 사용하라 if 를 사용해서 오류 코드를 뽑아 처리하기 보다는 try/catch 문을 사용해라, 하지만 try/catch 문도 하나의 함수 안에 정상 동작과 오류 동적을 뒤섞기 때문에 catch 부분을 별도의 함수로 뽑아 내는 편이 좋다. \n반복하지 마라 (DRY : Don't Repeat Yourself) 코드 길이가 늘어날 뿐만 아니라 하나의 알고리즘이 변하면 네 곳이나 손봐야 한다.  게다가 오류가 발생할 확률도 몇 배나 높다. \n결론 시스템은 풀어나가야할 하나의 큰 이야기라고 할 수 있다.  함수를 잘 만드는 기교도 중요하지만,  분명하고 정확한 언어로 깔끔하게 맞아떨어져야 이야기를 풀어나가기가 쉬워진다는 사실 또한 기억해야 한다. \n사견을 덧붙이면\u0026hellip;? 이번 장은 함수에 대한 얘기였다. 주 언어가 자바인 나에게는 메소드 라고 할 수 있을 것 같다.  읽으면서 가장 기억에 남는 부분은 아무래도 함수 인수 이 부분인데, 이유인 즉  전 회사에서 코어를 담당하는 메소드의 파라미터가 무려 10개 였다!!!  길이도 길어서 볼 때마다 어려운 코드였고, 아에 대놓고 null 이 들어가는 인수도 있었다. 정말 이해하기 힘들고 어려워서 항상 저걸 쪼개고 싶다는 생각을 했는데\u0026hellip;  테스트도 없고 그 부분을 건드릴 깜냥(?)이 안되서 결국 나올 때까지 못 건드리고 나왔다.  그 후에는 유닛 테스트도 진행하고 나름 재밌게 하고 있다.  책에서도 나오지만 유닛테스트를 하다보면 assertEqual() 을 사용할 때가 있다. expected 와 actual 의 순서가 헷갈리곤 하는데 다행이도 인텔리 제이에서는 파라미터에 대한 설명(?) 이랄까 그런게 잘 나오더라\n"
},
{
	"uri": "http://ysjune.github.io/en/posts/clean-code/chapter4/",
	"title": "4. 주석",
	"tags": [],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "4. 주석 나쁜 코드에 주석을 달지 마라. 새로 짜라 주석은 나쁜 코드를 보완하지 못한다. 코드에 주석을 추가하는 일반적인 이유는 코드 품질이 나쁘기 때문이다.  주석을 달기보단, 그 코드를 깔끔하게 개선하는데에 시간을 투자해라.\n코드로 의도를 표현하라! if(employee.isEligibleForFullBenenfits() 같이 주석을 대신해 함수로 충분히 표현이 가능하다.\n좋은 주석 하지만 어떤 주석은 필요로 한다. 그 주석의 종류를 열거하자면, \n  법적인 주석 - 회사가 정립한 구현 표준에 맞춰 법적인 이유로 특정 주석을 넣는 경우\n  정보를 제공하는 주석 - 기본적인 정보를 주석으로 제공하면 편리함. 혹은 파라미터 등에서 어떤 포멧인지 (하지만, 필수는 아님. 함수명을 변경함으로 충분히 대체 가능)\n  의도를 설명하는 주석 - 구현을 이해하게 도와주는 형태의 주석, 주로 저자의 구현 의도가 드러나는 주석이라 할 수 있다.\n  의미를 명료하게 밝히는 주석 - 모호한 인수나 반환값을 읽기 좋게 표현하는 것\n  결과를 경고하는 주석 - 특정 테스트 케이스에서 실행할 경우 문제가 생길 수 있다는 것을 설명해주는 것\n  TODO 주석 - 때로는 앞으로 할 일을 남겨놓을 필요가 있기 때문에 사용한다.  하지만, 시스템에 나쁜 코드를 남겨 놓는 핑계가 되어서는 안된다.\n  나쁜 주석 대다수의 주석이 이 범주 안에 속하며, 허술한 코드를 변명하는 것에 지나지 않는다.\n  주절거리는 주석 - 의무감 혹은 프로세스에 의해서 주석을 다는 경우는 시간 낭비이다. 주석을 달기로 했으면 충분한 시간을 들여 최고의 주석을 달도록 노력한다.\n  같은 이야기를 중복하는 주석 - 헤더에 달린 주석이 같은 코드 내용을 그대로 중복하면 자칫 코드를 읽는데 시간이 더 소요될 수 있다.\n  오해할 여지가 있는 주석 - 분기 처리 등에서 설명이 살짝 부족한 경우 충분히 오해의 소지가 있어, 관련 기능을 포함하여 테스트 혹은 개발을 할 때 문제가 생길 여지가 다분하다.\n  의무적으로 다는 주석 - 무조건적으로 다는 주석은 코드를 복잡하게 만들며, 거짓말을 퍼뜨리고 혼동을 줄 여지가 충분하다.\n  있으나 마나 한 주석 - 너무 당연한 사실을 언급하며 새로운 정보를 제공하지 못하는 주석 ex) // 생성자\n  함수나 변수로 표현할 수 있다면 주석을 달지 마라 닫는 괄호에 다는 주석 때로는 괄호가 닫히는 곳에 주석을 달곤 하는데 (주로 반복이 중첩되거나, 여러 분기가 있는 경우) ,  괄호에 주석을 달아야 겠다고 생각한다면, 그 에너지를 함수를 줄이는 것에 사용하자.\n저자를 표시하는 주석 근래의 소스 코드 관리 시스템은 누가 언제 무엇을 추가했는지 귀신처럼 기억한다.  그러므로 굳이 주석을 달아서 코드를 오염시킬 필요가 없다.\n주석으로 처리한 코드 주석으로 처리된 코드는 다른 사람들이 지우기를 주저한다. 우리는 우수한 소스 관리 시스템을 사용하기 때문에, 굳이 주석으로 남길 필요가 없다. 그냥 코드를 삭제해라, 코드를 잃어버릴 염려는 없다.\n전역 정보 주석을 달아야 한다면 근처에 있는 코드만 기술하라. 전역적인 정보를 기술하지 마라.  만약 전역정보가 변한다고 해도, 그 주석에 있는 전역 정보에 대한 서술이 바뀔 가능성은 낮다.\n모호한 관계 주석을 달았다면 적어도 독자가 주석과 코드를 읽어보고 무슨 소린지 알아야 한다.  주석 자체가 다시 설명을 요구한다면, 그것은 잘못된 주석이다.\n사견을 덧붙이면\u0026hellip;? 나는 변수와 메소드 명을 중요시 하게 여긴다.  개발자라면, 코드로 의도를 전달할 수 있어야 한다고 생각하기에 주석은 가급적 피하는 편이다.  그리고 이번 장은 그런 나의 의도와 잘 맞는 장이라고 할 수 있겠다. 책에서도 나오는 얘기지만, 예전에는 해당 함수 등의 내용이 변경되면 기존 코드를 주석으로 해놓고, 새 기능을 작성했다. 아까워서 그랬는지, 나중에 쓸까봐 그랬는지는 지금와서는 잘 기억이 안 나지만(아마 후자가 아닐까 한다.) 이제는 미련없이 지운다. 경험상 그 주석 처리한 코드를 쓴 일은 없었고(짧은 경험이긴 하지만\u0026hellip;.), 설사 쓴다해도 되돌리면 그만이다.  그리고 혼자 개발하다보니 당장 좋은 방법이 생각 안나거나 할 때 TODO,FIXME 등을 꽤 애용하는 편인데(미래의 나야 부탁해)  책에서도 언급했듯이 TODO 떡칠을 항상 경계해야 할 것 같다.\n"
},
{
	"uri": "http://ysjune.github.io/en/posts/clean-code/chapter5/",
	"title": "5. 형식 맞추기",
	"tags": [],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "5. 형식 맞추기 형식을 맞추는 목적 오늘 구현한 기능이 다음 버전에서 바뀔 확률은 매우 높다.  그리고 오늘 구현한 코드의 가독성은 앞으로 바뀔 코드의 품질에 지대한 영향을 미친다. 오랜 시간이 지나 원본을 찾기 힘들정도로 코드가 변해도 맨 처음 잡아놓은 구현 스타일과 가독성 수준은 계속 영향을 미친다.\n적절한 행 길이를 유지하라 200줄 정도인 파일로도 커다란 시스템을 구축할 수 있다. (그만큼 모듈화가 되어있다는 뜻)  일반적으로 큰 파일보다 작은 파일이 이해하기 쉽다.\n신문 기사처럼 작성하라 최상단에 기사를 몇 마디로 요약하는 표제가 나온다.  독자는 표제를 보고서 기사를 읽을지 말지 결정한다.  첫 문단은 전체 기사 내용을 요약한다. 세세한 사실은 숨기고 커다란 그림을 보여준다.  쭉 읽으며 내려가면 세세한 사실이 조금씩 드러난다. 날짜, 이름, 발언, 주장, 기타 세부 사항이 나온다.\n개념은 빈 행으로 분리하라 빈 행은 새로운 개념을 시작한다는 시각적 단서다.  코드를 읽어 내려가다 보면 빈 행 바로 다음 줄에 눈길이 멈추게 된다.\n수직 거리 서로 밀접한 개념은 세로로 가까이 둬야 한다.  물론 두 개념이 서로 다른 파일에 속한다면 규칙이 통하지 않는다.  하지만 타당한 근거가 없다면 서로 밀접한 개념은 한 파일에 속해야 마땅하다.  연관성이 깊은 두 개념이 멀리 떨어져 있으면 코드를 읽는 사람이 소스 파일과 클래스를 여기저기 뒤지게 된다.\n 변수 선언 : 변수는 사용하는 위치에 최대한 가까이 선언 인스턴스 변수 : 클래스 맨 처음에 선언 (이유인 즉, 잘 설계한 클래스는 많은 클래스 매서드가 인스턴스 변수를 사용하기 떄문) 종속 함수 : 한 함수가 다른 함수를 호출한다면 두 함수는 세로로 가까이 배치한다. 또한, 가능하다면 호출하는 함수를 호출되는 함수보다 먼저 배치한다.  가로 형식 맞추기 통계적으로 봤을 때, 20 ~ 60자의 행이 총 행 수의 40%, 10자 미만은 30% 정도이다.\n가로 공백과 밀집도 가로로는 공백을 사용해 밀접한 개념과 느슨한 개념을 표현한다.\n들여쓰기 들여쓰기 한 파일은 구조가 한 눈에 들어온다.  반면에 들여쓰기를 하지 않은 코드는 열심히 분석하지 않는 한 거의 불가능하다.\n사견을 덧붙이면\u0026hellip;? 책으로 보면 이번 챕터는 코드가 많고, 짧은 느낌이 있다. 하지만 내용면에서는 충분하다.  한 마디로 말하자면 가독성 이 하나로 충분하지 않을까  그러고보면 이 형식맞추기라는 측면은 학부생때부터 계속 고민해온 사항이기도 하다.  예전에 국비 교육을 들었을 때, 반복문과 지역 변수들 사이의 개행에 관해 어떤 게 보기 좋을지 강사님한테 물었던 기억이 있다.  당시 강사님이 했던 말씀이 \u0026ldquo;보통 그런 경우는 의미 단위로 개행을 한다.\u0026rdquo; 라고 비스무리 하게 말하셨던 거 같고, 덧붙여  경험이 쌓이면, 좀 더 쉽게 개행할 수 있을 거라고 하셨던 거 같은데.. (큰일이다 2년 정도밖에 안 지났는데도 기억이 잘 안나는거보니)\n"
},
{
	"uri": "http://ysjune.github.io/en/posts/clean-code/chapter6/",
	"title": "6. 객체와 자료 구조",
	"tags": [],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "6. 객체와 자료 구조 자료 추상화 자료를 세세하게 공개하기보다는 추상적인 개념으로 표현하는 것이 좋다.  인터페이스나 조회/설정 함수만으로는 추상화가 이뤄지지 않는다.  개발자는 객체가 포함하는 자료를 표현할 가장 좋은 방법을 심각하게 고민해야 한다.  아무 생각 없이 조회/설정 함수를 추가하는 방법이 가장 나쁘다.\n자료/객체 비대칭 객체와 자료 구조는 근본적으로 양분된다.  객체 지향 코드에서 어려운 변경은 절차적인 코드에서 쉬우며,  절차적인 코드에서 어려운 변경은 객체 지향 코드에서 쉽다.  복잡한 시스템을 짜다보면 새로운 함수가 아니라 새로운 자료 타입이 필요한 경우가 생기는데,  이 때는 클래스와 객체 지향 기법이 가장 적합하다.  반면, 새로운 자료 타입이 아니라 새로운 함수가 필요한 경우도 있는데, 이 때는 절차적인 자료 구조가 좀 더 적합하다.\n디미터 법칙 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙\n기차 충돌  final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();\n 위와 같은 형태(꼬리에 꼬리를 무는 형태) 를 기차 충돌이라 하며, 지양해야 하는 방법이다.  하지만, 디미터의 법칙을 위반하느냐 하면 그건 확실히 알 수가 없다.  객체일 경우에는 위반하는 것이 되지만(객체라면 내부 구조를 숨겨야 하므로),  자료 구조라면 당연히 내부 구조를 노출하므로 디미터 법칙이 적용되지 않는다. But, final String outputDir = ctxt.options.scratchDir.absolutePath 였다면, 논란이 필요없다.\n잡종 구조 객체와 자료구조의 형태가 섞인 구조로 새로운 함수는 물론이고 새로운 자료 구조도 추가하기 어렵다.  양쪽에서 단점만 모와놓은 구조라 볼 수 있다.  함수나 타입을 보호할지 공개할지 확신하지 못해 어중간하게 내놓은 설계에 불과\n자료 전달 객체 자료 구조체의 전형적인 형태는 공개 변수만 있고, 함수가 없는 클래스다.  이런 자료 구조체를 떄로는 자료 전달 객체 Data Transfer Object (DTO) 라 한다.  그리고 좀 더 일반적인 형태는 빈(bean) 구조이다. 빈은 private 변수를 조회/설정 함수로 조작한다.  일종의 사이비 캡슐화로 별다른 이익을 제공하지 않는다.\n활성 레코드 DTO 의 특수한 형태이다. DTO + save/find 같은 함수도 제공한다.  활성 레코드는 데이터베이스 테이블이나 다른 소스에서 자료를 직접 변환한 결과다.  이런 레코드에 비지니스 규칙 메서드를 추가할 경우 잡종이 되므로, 활성 레코드는 자료 구조로 취급하고, 비즈니스 구조는 따로 가져간다.\n결론 객체는 동작을 공개하고 자료를 숨긴다.  그래서 기존 동작을 변경하지 않으면서 새 객체 타입을 추가하기는 쉬운 반면,  기존 객체에 새 동작을 추가하기는 어렵다.  자료 구조는 별다른 동작 없이 자료를 노출한다.  그래서 기존 자료 구조에 새 동작을 추가하기는 쉬우나, 기존 함수에 새 자료 구조를 추가하기는 어렵다.  어떤 시스템을 구현할 때 새로운 자료 타입을 추가하는 유연성이 필요하면 객체가,  다른 경우로 새로운 동작을 추가하는 유연성이 필요하면 자료 구조와 절차적인 코드가 더 적합하다.  결국 이렇다 하는 정답은 없는 것이다.\n사견을 덧붙이면\u0026hellip;? 이번 장의 내용은 짧다. 정말 짧지만, 이해하는 데에는 꽤나 많은 시간이 들었던 장이다.  특히 앞 장의 객체와 자료구조를 읽으면서\u0026hellip; 내가 평소에 만드는게 객체 인지 자료구조인지\u0026hellip;  이게 이건가? 저게 이건가? 하면서 명확하지 않은 채로 읽었기 때문이다. (일단 처음엔 읽는다, 이해가 안되도 그냥)  뒤로 가면서 익숙한게 나와서 그나마 좀 명확해졌는데, 그 부분이 바로 자료 전달 객체 이 부분이다.  완전 쌩신입 때의 나는 그저 DTO 만 만들었고 (그러다가 본 건 있어서 잡종 구조가 된 것 같기도 하다.)  최근까진 이게 클래스, 객체, 빈 다 총칭하는 줄 알았다.  이제는 둘의 차이점도 알았겠다. 최대한 잡종 구조는 지양, 경계하면서 코딩해야겠다.\n"
},
{
	"uri": "http://ysjune.github.io/en/posts/clean-code/chapter7/",
	"title": "7. 오류 처리",
	"tags": [],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "7. 오류 처리 오류 코드보다 예외를 사용하라 오류 처리 코드와 호출하여 논리를 진행하는 코드가 섞이면 알아보기가 어렵다.  논리가 뒤섞여 있기 때문.\ntry/catch/finally 문부터 작성하라 try 블록에 들어가는 코드를 실행하면 어느 시점에서든 실행히 중단된 후 catch 블록으로 넘어갈 수 있다.  어떤 면에서 catch 블록은 트랜잭션과 비슷하다.  try 블록에서 무슨 일이 생기든 catch 블록은 프로그램 상태를 일관성 있게 유지해야 한다.  먼저 강제로 예외를 일으키는 테스트 케이스를 작성한 후 테스트를 통과하게 코드를 작성하는 방법을 권장한다.\n미확인 예외를 사용하라 확인된 예외를 할 경우 최하위 (연쇄반응에서의 마지막) 함수에서 확인된 예외를 던질 경우  상위 함수에서는 그 예외를 알아야 하고, 결론적으로 캡슐화가 깨지게 되는 현상이 발생한다.  일반적인 애플리케이션은 의존성이라는 비용이 이익보다 크다.\n예외에 의미를 제공하라 예외를 던질 때는 전후 상황을 충분히 덧붙인다.  그러면 오류가 발생한 원인과 위치를 찾기 쉬워진다. 즉, catch 문에 logger 등을 사용\n호출자를 고려해 예외 클래스를 정의하라 애플리케이션에서 오류를 정의할 때 프로그래머에게 가장 중요한 관심사는 오류를 잡아내는 방법이 되어야 한다.  대다수 상황에서 우리가 오류를 처리하는 방식은 (오류를 일으킨 원인과 무관하게) 비교적 일정하다. \n 오류를 기록 프로그램을 계속 수행해도 좋은지..  외부 라이브러리를 사용할 경우 외부 라이브러리에서 나올 에러를 예외처리 하기보단 외부 라이브러리 자체를 예외 처리해라.  그래야 외존성도 좋고 갈아타는 비용도 적다  null 을 반환하지 마라 null 체크를 기반으로 돌아가는 코드는 엄밀히 말하자면 나쁜 코드다.  null 을 반환하는 코드는 일거리를 늘릴 뿐만 아니라 호출자에게 문제를 떠넘긴다.  누구 하나라도 null 체크를 빼먹는다면 애플리케이션이 통제 불능에 빠질지도 모른다.  매서드에서 null 을 반환하고픈 유혹이 든다면 그 대신에 예외를 던지거나 특수 사례 객체를 반환한다.  그리고 자바에선 Collections.emptyList() 가 있어 미리 정의된 읽기 전용 리스트를 반환한다.\nnull 을 전달하지 마라 메서드에 null 을 반환하는 방식도 나쁘지만, 메서드로 null 을 전달하는 방식은 더 나쁘다.  정상적인 인수로 null 을 받는 API 가 아니라면 null 을 넘기는 것은 최대한 지양해라.  대다수 프로그래밍 언어는 호출자가 실수로 null 을 넘겼을 때 적절히 처리하는 방법이 없다.  그렇다면 애초에 null 을 넘기지 못하게 하는 것이 합리적이다.  즉, 인수로 null 이 넘어오면 코드에 문제가 있다는 말이다.\n결론 깨끗한 코드는 읽기 좋아야 하지만, 안정성도 높아야 한다. 그리고 이 둘은 상충하는 목표가 아니다. 오류 처리를 프로그램 논리와 분리하면 독립적인 추론이 가능해지며 코드 유지보수성도 높아진다.\n사견을 덧붙이면\u0026hellip;? 글쎄.. 배울 때부터 try-catch 문을 사용하도록 배워서 그런지, 오히려 오류 코드라는 게 더 생소했다. null 에 관련해서는 에피소드가 떠오르는게 꽤 된다.  전 회사에서 코드 품질인증인지 뭔지를 받는다고 소스를 검증 업체에 넘긴 적이 있다.  거기서 많이 나왔던 지적 사항이 null 체크를 안한다는 것이었다. 그래서 당시에 엄청난 야근을 하면서(\u0026hellip;) null 체크 로직을 넣곤 했다.  당시엔 뭣도 모르는 신입 시절이라 하라는대로 했지만, 지금 생각해보면 그런 체크를 일일히 넣어줬어야 했던 코드인가? 에 대해서는 좀 의문이 든다.  그리고 다른 에피소드는 비교적 최근 일인데,  본인이 작업한 소스를 보여주고, 어떻게 리팩토링을 진행했는지 발표하는 그런 리팩토링 스터디에 참가했었다.  그 자리에서 다른 발표자의 자료를 보고 있는데, 마침 눈에 들어 왔던게, null 을 파라미터로 넣고 진행하는 메소드가 눈에 보였다.  왜 null 을 넣었고, 무슨 의도였는지 물어볼까 하다가 시간이 지나서 결국은 못 물어봤던 기억이 있다. (아직까지 생각나는거보니 나는 그런 형태가 되게 싫었나보다.)  내성적이라 말할 타이밍을 놓치고 그냥 넘어가는 경우가 많은데, 이런 부분은 고쳐야 되겠다 싶다.\n"
},
{
	"uri": "http://ysjune.github.io/en/posts/clean-code/chapter8/",
	"title": "8. 경계",
	"tags": [],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "8. 경계 외부 코드 사용하기 인터페이스 제공자와 인터페이스 사용자 사이에는 특유의 경계가 존재한다.  제공자는 사용성을 높이기 위해 많은 영역에서 지원하려고 하고,  사용자는 본인이 사용하는 쪽의 특화된 기능을 원하기 때문이다.  한 가지 예로 Map 을 보면 유용성이 높지만, 그만큼 위험하기도 하다.  여러 유형의 객체를 지원하지만, 오용의 가능성도 높기 때문.  그렇기에 경계 인터페이스를 여기저기 넘기지 않고,  Map 과 같은 경계 인터페이스를 이용할 때는 이를 이용하는 클래스나 클래스 계열 밖으로 노출되지 않도록 주의한다.\n경계 살피고 익히기 외부 코드를 익히기는 어렵고, 통합하기도 어렵다.  둘을 동시에 하려면 더 어렵다.  그렇기에 우리쪽 코드를 먼저 작성해 외부 코드를 호출하는 대신 먼저 간단한 테스트 케이스를 작성해 외부 코드를 익히는 것을 학습 테스트 라고 하고, 이 학습 테스트는 통제된 환경에서 API를 제대로 이애하는지 확인하는 셈이다.  학습 테스트는 API 를 사용하는 목적에 초점이 있다.\n학습 테스트는 공짜 이상이다 학습 테스트는 투자하는 노력보다 얻는 성과가 더 크다.  실제 코드와 동일한 방식으로 인터페이스를 사용하는 테스트 케이스가 필요하다.  이런 경계 테스트가 있다면 패키지의 새 버전으로 이전하기 쉬워진다.  그렇지 않다면 낡은 버전을 필요 이상으로 오랫동안 사용하려는 유혹에 빠지기 쉽다.\n아직 존재하지 않는 코드를 사용하기 경계와 관련해 또 다른 유형은 아는 코드와 모르는 코드를 분리하는 경계다.  초반에는 경계와 먼 부분부터 구현을 시작하여, 점차 만날 지점에서는 인터페이스를 구현하여 다른 곳과의 경계 부분에 adapter 패턴을 사용하여 붙인다.\n깨끗한 경계 소프트웨어 설계가 우수하다면 변경하는데 많은 투자와 재작업이 필요하지 않다.  엄청난 시간과 노력과 재작업을 요구하지 않는다.  경계에 위치하는 코드는 깔끔히 분리한다. 또한 기대치를 정의하는 테스트 케이스도 작성한다.  통제가 불가능한 외부 패키지에 의존하는 것보다 통제가 가능한 우리 코드에 의존하는 편이 좋다.  자칫하면 외부 코드에 휘둘리기 때문이다. 외부 패키지를 호출하는 코드를 가능한 줄여 경계를 관리하자.  새로운 클래스로 경계를 감싸거나, adapter 패턴을 사용해 인터페이스를 변환하자.\n사견을 덧붙이면\u0026hellip;? 이번 챕터에서는 외부 라이브러리 혹은 외부 API 등과 연결을 할 때, 어떻게 해야할지에 대해서 나와있다.  그리고 학습테스트(유닛테스트) 가 중요하다는 사실을 말하는 장이기도 하다.  이 책을 읽다보면 마틴 파울러의 리팩토링 책과 내용이 겹친다고 느껴지는 부분이 많다. (마치 시중에 있는 많은 자기계발서 와 비슷한..?)  그만큼 중요하지만 익숙해지지 않으면 힘든 것 같다. 나만해도 머리로는 해야지 하면서도 행동은 글쎄\u0026hellip;? 니까  책을 읽으면서 중간에 낡은 버전을 필요 이상으로 오랫동안 사용하려는 유혹에 빠지기 쉽다 라는 부분이 있다.  이전에 이런 경험이 있긴 하다. 타 라이브러리가 핵심 코어로 된 패키지 프로젝트가 있었다. 뭐 여기까지는 좋다. 그럴 수 있으니까.  하지만, 그 패키지에 테스트 케이스는 존재하지 않았고, 물론 리팩토링도 없었다.  그러다보니 시간이 지나면서 군데군데 요구사항 변경에 의한 땜빵만 늘어났고, 결국은 버리고 싶어도 버릴 수 없는 애물단지 같은 느낌이었다.  (왜냐고? 일단, 돌아는 가니까 팔아야지!)  이런 부분을 생각하면 정말 아쉽긴 하다. 하지만, 지금 그 때로 돌아간다고 해도 단위테스트를 만들고 그럴 수 있을 것 같진 않다.  하루살이란 느낌이 강했으니까\u0026hellip;  옆길로 좀 새긴 했지만\u0026hellip; 이번 장에서는 테스트를 통한 경계에 대해 말하기도 하지만, map 과 vo 에 대해서도 생각해볼 수 있는 좋은 장이었다.\n"
},
{
	"uri": "http://ysjune.github.io/en/posts/clean-code/chapter9/",
	"title": "9. 단위 테스트",
	"tags": [],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "9. 단위 테스트 TDD 의 법칙 3가지  실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다. 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다. 현재 실패하는 테스트를 통화할 정도로만 실제 코드를 작성한다.  깨끗한 코드 유지하기 지저분한 코드를 내놓으나 테스트를 안 하나 오십보 백보이다.  그 이유는 실제 코드가 진화하면 테스트 코드도 변해야 하기 때문이다.  그런데 테스트 코드가 지저분하면 그만큼 수정하기가 어려워진다.  테스트 코드는 실제 코드 못지 않게 중요하다. 테스트 코드는 이류 시민이 아니다.  실제 코드 못지 않게 깨끗하게 짜야 한다.\n테스트는 유연성, 유지보수성, 재사용성을 제공한다. 테스트 코드를 깨끗하게 유지하지 않으면 결국은 잃어버린다.  그리고 테스트 케이스가 없으면 실제 코드를 유연하게 만드는 버팀목도 사라진다.  테스트 케이스가 없다면 모든 변경은 잠정적인 버그다.\n깨끗한 테스트 코드 깨끗한 테스트 코드를 만들려면 세 가지가 필요하다. 가독성!, 가독성!!, 가독성!!!  테스트 코드는 최소의 표현으로 많은 것을 나타내야 한다.\n이중 표준 테스트에 적용하는 표준은 실제 코드에 적용하는 표준과는 확실히 다르다.  단순, 간결, 표현력 풍부해야 하지만, 실제 코드만큼 효율적일 필요는 없다.  실제 환경에서는 절대로 안되지만, 테스트 환경에서는 전혀 문제 없는 방식이 있다.  대게 메모리나 CPU 효율과 관련 있는 경우다. 코드의 깨끗함과는 무관한 케이스이다.\n테스트 당 개념 하나 테스트 함수마다 한 개념만 테스트하라 이것저것 잡다한 개념을 연속으로 테스트하는 긴 함수는 피해야한다.\nF.I.R.S.T  First : 테스트는 빨라야 한다. 테스트가 느리면 자주 돌릴 엄두를 못 내고, 자주 돌리지 않으면 초반에 문제를 찾아내 고치지 못한다. Independent : 각 테스트는 서로 의존하면 안된다. 한 테스트가 다음 테스트가 실행될 환경을 준비해서는 안된다. 각 테스트는 독립적으로 그리고 어떤 순서로 실행해도 괜찮아야 한다. Repeatable : 테스트는 어떤 환경에서도 반복 가능해야 한다. 어느 환경에서든 실행할 수 있어야 한다. 그렇지 않으면 변명거리를 만들게 된다. Self-Validating : 테스트는 부울 값으로 결과를 내야 한다. 성공 아니면 실패다. 통과 여부를 알려고 로그 파일을 읽게 만들어서는 안된다. 테스트가 스스로 성공과 실패를 가늠하지 않는다면 판단은 주관적이 되며 지루한 수작업 평가가 필요하게 된다. Timely : 테스트는 적시에 작성해야 한다. 단위 테스트는 테스트하려는 실제 코드를 구현하기 직전에 구현한다.  결론 사실상 깨끗한 테스트 코드라는 주제는 책 한 권을 할애해도 모자랄 주제다.  테스트 코드는 실제 코드만큼이나 프로젝트 건강에 중요하다.  테스트 코드가 방치디어 망가지면 실제 코드도 망가진다. 테스트 코드를 깨끗하게 유지하자.\n사견을 덧붙이면\u0026hellip;? 테스트 코드까지 왔다. 테스트 코드는 말로만 들었지, 실제로 접해본 건 5개월 정도 전이다.  그 전에는 테스트 코드가 뭔지 몰랐고, 뭔지 안 시점에서는 어떻게 적용해야할지 몰랐다. (뭐, 지금도 잘 하는 건 아니지만)  전 장에서도 언급했지만, 유닛 테스트 하면 역시 리펙토링이 떠오르게 된다.  개인적으로는 리펙토링 스터디를 통해 좋은 테스트 코드 작성법을 알게 된 것 같다.  이전에는 테스트 코드를 한 프로세스를 테스트 한다는 개념으로 작성했었다. 그러다보니 시간이 길게 걸리고 메소드 하나하나에 대한 검증이 쉽지 않았다.  그런 코드를 가지고 발표를 진행하는데 들었던 얘기가 여기에 나와 있는 말과 같다 테스트 당 개념 하나  아마 다른 건 몰라도 이 개념은 계속 지켜나가지 않을까?\n"
},
{
	"uri": "http://ysjune.github.io/en/categories/",
	"title": "Categories",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ysjune.github.io/en/categories/clean-code/",
	"title": "clean code",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ysjune.github.io/en/",
	"title": "Lazy Snack",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ysjune.github.io/en/posts/",
	"title": "Posts",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ysjune.github.io/en/series/",
	"title": "Series",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ysjune.github.io/en/about/",
	"title": "About",
	"tags": [""],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "Hello! I'm Snack. Web Programmer\n"
},
{
	"uri": "http://ysjune.github.io/en/tags/",
	"title": "Tags",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
}]