[
{
	"uri": "https://ysjune.github.io/",
	"title": "",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ysjune.github.io/categories/",
	"title": "Categories",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ysjune.github.io/categories/java/",
	"title": "java",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ysjune.github.io/posts/",
	"title": "Posts",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ysjune.github.io/series/",
	"title": "Series",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ysjune.github.io/posts/java/springboot_actuator/",
	"title": "SpringBoot Actuator",
	"tags": [],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "1. Spring Boot Actuator   일단.. 생소한Actuator 이란??\n An actuator is a manufacturing term that refers to a mechanical device for moving or controlling something. Actuators can generate a large amount of motion from a small change.\n물건을 움직이거나 컨트롤하기 위한 장치를 의미하는 제조 용어로, 작은 변화로 큰 변화를 일으킬 수 있다.\n   앱을 모니터링 하거나 메트릭을 수집하거나 트래픽 혹은 데이터 베이스 상태를 이해하는 것을 쉽게 하는 것\n  설명만 봐선 알듯말듯하게 모르겠고, 정리를 하는 시점에도 딱 이거다! 하고 떠오르질 않네요.\n  모든 내용은 spring boot2.x 를 기반으로 작성했습니다. 1.x 하고는 약간 달라요\n  2. 의존성 추가  maven 일 경우  1 2 3 4 5 6  \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-actuator\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;    Gradle 일 경우  1 2 3  dependencies{compile(\u0026#34;org.springframework.boot:spring-boot-starter-actuator\u0026#34;)}  3. Endpoints   엔드포인트를 사용하면 애플리케이션을 모니터링하고 상호 작용할 수 있음\n  spring boot 2.x 에서는 /health, /info 2개만 기본적으로 제공\n  모든 기능을 사용하려면 프로퍼티에 추가\nmanagement.endpoints.web.exposure.include = *   기본적인 /health 를 하면\n1 2 3  { \u0026#34;status\u0026#34;: \u0026#34;UP\u0026#34; }   만 나오며 healthIndicator 을 구현하여 추가적으로 커스텀도 가능\n  ex)\n1 2 3 4 5 6 7 8 9 10 11 12 13  @Component public class MyHealthIndicator implements HealthIndicator { @Override public Health health() { int errorCode = check(); // perform some specific health check  if (errorCode != 0) { return Health.down().withDetail(\u0026#34;Error Code\u0026#34;, errorCode).build(); } return Health.up().build(); } }     4. Metrics   Micrometer 지원, 직접 상호작용\n  MeterRegistry 유형의 Bean 이 자동 구성\n  이번 글을 쓰게 된 이유\n  /metrics 를 하면\n1 2 3 4 5 6 7 8 9 10 11 12 13  { \u0026#34;names\u0026#34;: [ \u0026#34;http.server.requests\u0026#34;, \u0026#34;jdbc.connections.idle\u0026#34;, \u0026#34;tomcat.sessions.rejected\u0026#34;, \u0026#34;hikaricp.connections.max\u0026#34;, \u0026#34;hikaricp.connections.min\u0026#34;, \u0026#34;process.cpu.usage\u0026#34;, \u0026#34;jvm.memory.max\u0026#34;, \u0026#34;jvm.threads.states\u0026#34;, //.... ] }   이런 식으로 뜨고, 실제 값을 얻으려면 원하는 메트릭 (/actuator/metrics/jvm.memory.max) 으로 이동해야 됨\n  /actuator/metrics/jvm.memory.max 의 경우\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  { \u0026#34;name\u0026#34;: \u0026#34;jvm.memory.max\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;The maximum amount of memory in bytes that can be used for memory management\u0026#34;, \u0026#34;baseUnit\u0026#34;: \u0026#34;bytes\u0026#34;, \u0026#34;measurements\u0026#34;: [ { \u0026#34;statistic\u0026#34;: \u0026#34;VALUE\u0026#34;, \u0026#34;value\u0026#34;: 9860284415 } ], \u0026#34;availableTags\u0026#34;: [ { \u0026#34;tag\u0026#34;: \u0026#34;area\u0026#34;, \u0026#34;values\u0026#34;: [ \u0026#34;heap\u0026#34; //... ] } ] }     당연하게도 커스텀 메트릭 또한 추가 가능\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  @Component public class SampleBean { private final Counter counter; private Tag tag = Tag.of(\u0026#34;status\u0026#34;, \u0026#34;ok\u0026#34;) public SampleBean(MeterRegistry registry) { this.counter = registry.counter(\u0026#34;received.message\u0026#34;, \u0026#34;status\u0026#34;, \u0026#34;all\u0026#34;); } public void handleMessage(String message) { this.counter.increment(); // handle message implementation  } }     metrics 에 등록된 것 확인\n1 2 3 4 5 6 7 8 9  { \u0026#34;names\u0026#34;: [ \u0026#34;http.server.requests\u0026#34;, \u0026#34;jdbc.connections.idle\u0026#34;, \u0026#34;tomcat.sessions.rejected\u0026#34;, //.... \u0026#34;received.message\u0026#34; ] }     /actuator/metrics/received.message 에서 내용을 확인해보면\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  { \u0026#34;name\u0026#34;: \u0026#34;received.message\u0026#34;, \u0026#34;description\u0026#34;: null, \u0026#34;baseUnit\u0026#34;: null, \u0026#34;measurements\u0026#34;: [ { \u0026#34;statistic\u0026#34;: \u0026#34;COUNT\u0026#34;, \u0026#34;value\u0026#34;: 1 // 호출 횟수 } ], \u0026#34;availableTags\u0026#34;: [ { \u0026#34;tag\u0026#34;: \u0026#34;server_name\u0026#34;, \u0026#34;values\u0026#34;: [ \u0026#34;sample-api\u0026#34; ] }, { \u0026#34;tag\u0026#34;: \u0026#34;profile\u0026#34;, \u0026#34;values\u0026#34;: [ \u0026#34;local\u0026#34; ] }, { \u0026#34;tag\u0026#34;: \u0026#34;status\u0026#34;, \u0026#34;values\u0026#34;: [ \u0026#34;all\u0026#34; ] } ] }   이런 식으로 정보를 알 수 있음\n  5. Custom Endpoint 생성   커스텀 앤드 포인트를 생성하는 것이 가능\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  @Component @Endpoint(id = \u0026#34;features\u0026#34;) public class FeaturesEndpoint { private Map\u0026lt;String, Feature\u0026gt; features = new ConcurrentHashMap\u0026lt;\u0026gt;(); @ReadOperation public Map\u0026lt;String, Feature\u0026gt; features() { return features; } @ReadOperation public Feature feature(@Selector String name) { return features.get(name); } @WriteOperation public void configureFeature(@Selector String name, Feature feature) { features.put(name, feature); } @DeleteOperation public void deleteFeature(@Selector String name) { features.remove(name); } public static class Feature { private Boolean enabled; // [...] getters and setters  } }     위의 경우는 /actuator/features 로 접속 가능\n  @ReadOperation – HTTP GET에 매핑 @WriteOperation – HTTP POST에 매핑 @DeleteOperation – HTTP DELETE에 매핑     이 외에도 actuator 에 대한 많은 기능들이 있습니다. 엔드포인트를 확장한다거나 logger 에 관련된 것이라던가, 보안과 관련된 기능이라던가\u0026hellip;\n  메트릭 설정을 추가하면서 맛보기로 알아본 것들을 api 문서 참고하면서 작성했기 때문에 빈약하거나, 잘못된 내용이 있을 수 있습니다.\n   참고\n https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-features.html#production-ready https://www.baeldung.com/spring-boot-actuators#boot-2x-actuator   "
},
{
	"uri": "https://ysjune.github.io/posts/java/eventlistener/",
	"title": "eventPublisher 와 eventListenr 사용",
	"tags": [],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "서론 최근 마이크로미터를 사용하여 해당 서비스의 접속 카운트를 표시할까 해봤다. (오로지 흥미 위주로..)\n처음에는 MeterRegistry 와 Counter 를 직접 사용하여 해당 메소드에 추가해주는 식으로 구현했었다.\n구현하고 보니 정작 이거 counter 부분에서 에러가 나면 어떻게 되지? 중요 비즈니스 로직과는 무관하게 진행되야 하는건데 라는 생각이 들어서 다른 방법을 알아보던 차에 다른 방법을 생각해봤다.\n처음에는 인터셉터의 afterCompletion 을 사용해봤으나, lateinit 을 이용하고 해도 계속 초기화 문제가 발생해서 이리저리 해보다가 결국은 이렇다할 해결책을 못 찾고(코틀린과 스프링에 대한 지식이 부족\u0026hellip;), 다른 방법을 찾다가 EventListener 을 통해 비동기 방식으로 처리할 수 있다고 하여 도전해봤다.\n1. Events 작성   해당 서비스에서 이벤트를 발생시킬 때 사용하는 Events 클래스\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  object Events { private var eventPublisher: ApplicationEventPublisher? = null private val log = LoggerFactory.getLogger(this.javaClass) fun publishEvent(event: Any) { when (eventPublisher) { null -\u0026gt; { log.warn(\u0026#34;no eventPublisher, so don\u0026#39;t publish an event.\u0026#34;) } else -\u0026gt; { eventPublisher!!.publishEvent(event) } } } fun setEventPublisher(eventPublisher: ApplicationEventPublisher) { Events.eventPublisher = eventPublisher } }    object 키워드를 통해 싱글톤 객체로 만들어줌 ApplicationEventPublisher 을 통해 이벤트를 퍼블리싱 eventPublisher 은 null 인 상태이므로 퍼블리싱 하기 전에 setEventPublisher 을 해줘야 함    2. EventsInitializer 생성   Events 에서 eventPublisher 을 주입해주기 위해 InitializingBean 을 사용\n1 2 3 4 5 6 7 8  @Configuration class EventsInitializer(val context: ApplicationContext) { @Bean fun initEvents(): InitializingBean { return InitializingBean { Events.setEventPublisher(context) } } }    이렇게 하면 Spring Bean Lifecycle 에 의해 InitializingBean 이 실행이 되고, Events 객체의 eventPublisher 이 주입이 된다.    3. Events 를 사용할 Service 객체   Events 는 필요한 곳에서 사용하면 되지만, 이번에는 서비스 객체에서 사용\n1 2 3 4 5 6 7 8  @Service class ListService(private val provider: DataProvider) { fun callCachedData(status: String, req: RequestDTO) : PageInfo\u0026lt;DTO\u0026gt;? { Events.publishEvent(MakedKey(status, req)) return provider.get(MakedKey(status, req)) } }    Events.publishEvent() 를 통해 이벤트를 발생시킨다    4. EventListener 을 통해 이벤트 핸들러 구현   이벤트를 발생을 시켰으니, 발생시킨 이벤트를 받는 곳을 구현해보자\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  @Component class EventMetricHandler(private val meterRegistry: MeterRegistry) { private val log = LoggerFactory.getLogger(javaClass) @Async @EventListener(value = [MakedKey::class]) fun handle(evt: MakedKey) { val tags = listOf( Tag.of(\u0026#34;status\u0026#34;, evt.status) ) val counter = meterRegistry.counter(\u0026#34;counter\u0026#34;, tags) counter.increment() log.info(\u0026#34;increment metric: tag-{}\u0026#34;, tags) } }    EventListener 을 통해 받은 이벤트를 처리할 수 있다. status 라는 tag 를 생성해주고 각 tag 에 대한 카운트를 증가시켜준다. 위의 경우에서는 list 라는 조회에 대해서 카운트를 하기 때문에 트랜잭션을 신경쓸 필요가 없지만, 저장 혹은 삭제했을 때에 대한 메트릭을 할 경우 @TransactionalEventListener 을 사용하면 된다. 해당 어노테이션의 경우 트랜잭션 커밋 이전 이후 등에 관한 설정을 할 수 있다. 비동기 처리를 하기 위해서 @Async 어노테이션을 추가해주자.    5. @EnableAsync 추가   어떻게 보면 비동기로 한다는 시점에서 처음 추가해줬어야 할 것 같은 설정이지만\u0026hellip;\n1 2 3 4 5 6 7  @SpringBootApplication @EnableAsync class SampleEventApplication fun main(args: Array\u0026lt;String\u0026gt;) { runApplication\u0026lt;SampleEventApplication\u0026gt;(*args) }    @SpringBootApplication 어노테이션 자리에 @EnableAsync를 추가해주면 비동기 처리가 된다.    결론  비동기 처리를 할 때 Events 객체를 추가해서 하는 방법은 좋은 방법인 것 같고 좋아보인다. 다만, 스프링을 사용하면서 좋은 기능은 정말 많은데, 모르는 것도 정말 많다는 것과 그만큼 알아야 하는 것도 정말 많다는 것을 할 때마다 느끼는 것 같다.  "
},
{
	"uri": "https://ysjune.github.io/posts/ml/regression/",
	"title": "5장. 회귀",
	"tags": [],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "파이썬 머신러닝 완벽가이드 5장. 회귀 발표 자료 입니다. 5장 회귀.pdf "
},
{
	"uri": "https://ysjune.github.io/categories/%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D/",
	"title": "머신러닝",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ysjune.github.io/posts/javascript/chapter22/advanced_technique/",
	"title": "22. 고급테크닉",
	"tags": [],
	"categories": [],
	"series": ["자바스크립트 프로그래밍"],
	"description": "",
	"content": "다루는 내용  고급 함수 쉽게 조작할 수 없는 객체 타이머 조작 커스텀 이벤트  1. 고급 함수  단순한 절차적인 방식, 복잡하고 동적인 방식, 클로저, 함수 포인터 등을 사용하는 다양성  1.1 안전한 타입 탐지   typeof 나 instanceof 처럼 내장된 타입 탐지는 완벽하지 않음\n  Object 의 toString() 메소드를 이용\n1 2 3  Object.prototype.toString.call(value) == \u0026#34;[object Function]\u0026#34; window.JSON \u0026amp;\u0026amp; Object.prototype.toString.call(JSON) == \u0026#34;[object JSON]\u0026#34;     1.2 스코프 확인 생성자 (scope-safe constructor)   new 연산자 없이 객체를 생성하면 this 가 전역에 묶여버리는 문제가 있음\n1 2 3 4 5 6 7 8  function Person(name, age) { if(this instanceof Person) { this.name = name; this.age = age; } else { return new Person(name, age) } }    if/else 를 통해 해결    생성자 훔치기 패턴을 사용할 때에는 프로토 타입 체인이나, 기생 상속을 함께 사용 자세한 내용은 (6장. 객체지향 프로그래밍 참조)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  function Polygon(sides) { if(this instanceof Polygon) { this.sides = sides; this.getArea = function() { return 0; }; } else { return new Polygon(sides); } } function Rectangle(width, height) { Polygon.call(this, 2); this.width = width; this.height = height; this.getArea = function() { return this.width * this.height; }; } Rectangle.prototype = new Polygon(); var rect = new Rectangle(5, 10); console.log(rect.sides); // 2     1.3 지연 로딩 함수   브라우저 차이 때문에 if 문이 많은데, if 문은 단 하나만 존재해도 속도에 영향을 줄 수 있기 때문에 if 문을 필요할 때만 실행하도록 하는게 권장되고 이를 지연로딩 이라고 함\n   함수를 처음 호출할 때 자기 자신을 수정하도록 만드는 방법  1 2 3 4 5 6 7 8 9 10  function createA() { if(typeof request != \u0026#34;undefined\u0026#34;) { createA = function() { return new Request(); } } else { ... } return createA() }   적절한 함수를 선언하는 즉시 다른 함수를 할당하는 방법  1 2 3 4 5 6 7 8 9  var createA = (function() { if(typeof request != \u0026#34;undefined\u0026#34;) { return function() { return new Request(); } } else { ... } })();     1.4 함수 바인딩   특정한 this 값과 특정한 매개변수를 넘기면서 다른 함수를 호출하는 함수\n  참조 apply, call, bind 에 대해\n1 2 3 4 5 6 7 8 9  var handler = { message: \u0026#34;event\u0026#34;, handleClick: function(event) { console.log(this.message + \u0026#34;:\u0026#34; + event.type); } }; var btn = document.getElementById(\u0026#34;btn\u0026#34;); var bbtn = btn.bind(hadler);     1.5 함수 커링   커링은 단순히 감쌀 함수만 받지만, bind 는 함수와 context 객체를 함께 받음\n1 2 3 4 5 6 7 8 9 10  function add(num1, num2) { return num1 + num2; } function curry(num3) { return add(5, num3); } add(2,3); // 5 curry(3); // 8     2. 쉽게 조작할 수 없는 객체  컨텍스트가 같으면 수정하지 못하게 막을 방법이 없음 일단 객체를 쉽게 조작할 수 없는 객체로 바꾸고나면 이를 취소할 수 없음  2.1 확장 불가능한 객체  Ojbect.preventExtension() 를 통해 프로퍼티나 메소드를 추가할 수 없게 만듦 맴버를 수정하거나 삭제는 가능 Object.isExtensible() 을 통해 확장 여부 확인 가능  2.2 봉인된 객체  Object.seal() 메소드를 사용하며 [[configurable]] 속성이 false 가 됨 Object.isSealed() 를 통해 봉인 여부 확인 가능  2.3 동결된 객체  wirte 조차 불가능한 가장 강력한(?) 객체 ([[set]] 이 지정된 경우만 수정 가능 ) Object.freeze() 를 통해 동결  3. 고급 타이머  setTimeout() 이나 setInterval() 로 타이머를 생성하여 유용한 기능을 만들 수 있지만, 이들은 스레드이며 자바스크립트는 단일 스레드 환경에서 동작함 자바스크립트에서 즉시 실행되는 코드는 존재하지 않음. 모든 코드는 일단 큐에 추가되었다가 실행이 됨 타이머를 15초로 설정하면 코드가 15초 뒤에 실행되는 것이 아니라 15초 뒤에 큐에 추가 되는 것  3.1 타이머 반복   setInterval() 을 사용해 주기적으로 타이머 코드를 큐에 추가 가능\n  타이머 코드가 실행되기 전에 큐에 코드를 삽입할 가능성이 있기 때문에 다른 인스턴스가 큐에 존재하지 않을 때만 추가 하지만, 여기에는 2가지 단점이 있음\n 실행되지 않는 구간이 생길 수 있음 코드 사이의 갭이 예상보다 작을 경우 타이머 코드를 건너뛰게 됨    2번의 경우를 피하려면 setTimeout() 을 재귀호출 해야함\n1 2 3 4 5 6  setTimeout(function() { // sth..  setTimeout(arguments.callee, 50); }, 50);     3.2 프로세스 관리   브라우저는 코드가 일정 시간 이상 실행되거나 일정 숫자 이상의 문장을 실행하지 못하도록 오래 사용되는 스크립트 를 제한 함\n  오래 실행되는 루프의 경우 배열 나누기를 통해 사용자 인터페이스가 잠기는 것을 방지할 수 있음\n1 2 3 4 5 6 7 8  setTimeout(function() { var item = array.shift(); process(item); if(array.length \u0026gt; 0) { setTimeout(arguments.callee, 100); } }, 100)     3.3 함수 감속   짧은 시간 동안 DOM 조작을 너무 많이 하면 브라우저가 멈추기에 타이머를 이용해 감속으로 완화하는 목적\n1 2 3 4 5 6  function throttle(method, context) { clearTimeout(method.tId); methid.tId = setTimeout(function() { method.call(context); }, 100); }     resize 같이 코드를 주기적으로 실행해야 하지만 호출 자체를 제어할 수 없을 때 사용\n  4. 커스텀 이벤트  이벤트는 옵저버 패턴의 일종인데, 코드를 느슨하게 연결하는 테크닉 주체는 이벤트가 일어났음을 알리고, 옵저버는 이들 이벤트를 주시하며 주체를 관찰하기만 함 기본 아이디어는 이벤트를 관리하는 객체를 만들고 다른 객체가 그 이벤트를 주시하게 하는 것 커스텀 이벤트를 사용하면 관련된 객체를 분리하고 기능을 격리하기 쉬움  "
},
{
	"uri": "https://ysjune.github.io/categories/javascript/",
	"title": "javascript",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ysjune.github.io/series/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/",
	"title": "자바스크립트 프로그래밍",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ysjune.github.io/categories/%EC%82%BD%EC%A7%88-log/",
	"title": "삽질 Log",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ysjune.github.io/posts/chatter/jpa_update_problem/",
	"title": "테스트 환경에서 JPA update 안됨",
	"tags": [],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "expect  JPA 를 사용하여 entity 를 변경했을 시 update 가 되야하지만, 테스트 코드에서 동작하지 않음.  situation   Repository 를 상속한 곳에서 flush 메소드를 만든 후 호출\n-\u0026gt; 반응 없음 (sql log 에 update 가 출력 안됨)\n  EntityManager 를 직접 호출하여 flush 수행\n-\u0026gt; No EntityManager with actual transaction available for current thread - cannot reliably process \u0026lsquo;flush\u0026rsquo; call\n  PersistenceContext 어노테이션 추가\n  1 2 3  @PersistenceContext(type = PersistenceContextType.EXTENDED) // type PersistenceContextType.EXTENDED 을 추가 lateinit var entityManager: EntityManager   ​\t-\u0026gt; javax.persistence.TransactionRequiredException: no transaction is in progress\n Test Method 에 @Transactional 을 추가\n-\u0026gt; 정상적으로 업데이트 진행\n  entityManager 의 flush 부분 삭제\n-\u0026gt; 정상적으로 업데이트 진행\n  1에서 진행했던 Repository 의 flush 메소드 호출 부분 삭제\n-\u0026gt; 정상적으로 업데이트 진행\n  @Transactional 은 컨트롤러 상위든 메소드에든 상관 없이 동작\n  Test 메소드가 끝나면 롤백되는 것을 확인\n  삽질을 하면서 AfterEach 사용했었는데.. (junit5 사용)\n-\u0026gt; 어찌보면 당연하겠지만, test 메소드의 라이프 사이클 내에 포함되는 것 같다.\n-\u0026gt; 즉, beforeEach - Test - afterEach 순으로 진행되며, afterEach 가 끝나야 롤백이 됨\n  사용하고자 하는 기능에 @Transactional 이 있기 때문에 Test 메소드에는 필요 없다고 생각했는데, 이게 잘못된 것 같음.\n  flush 를 해주지 않아도 update 가 된다는 것은?? (추측)\n 테스트 코드 부분  1 2 3 4 5 6 7  @Test @DisplayName(\u0026#34;업데이트 성공\u0026#34;) @Transactional internal fun success_update() { val updateReq = UpdateReq() updateService.update(updateReq) }    서비스 코드 부분  1 2 3 4 5 6  @Transactional fun updateBoard(req: UpdateReq) { ..... val board = repository.findById(req.id) board.update(req) }   -\u0026gt; 기존에는 테스트 코드 부분에 Transactional 이 없었기 때문에 서비스 코드 부분의 Transactional 이 계속 진행중? 이었으나, 테스트 코드 부분에 Transactional 을 추가함으로써 서로 격리가 되어, 서비스 부분의 Transactional 이 갖고 있는 context 는 더 진행할 것이 없기 때문에 update 가 되고, 서비스 객체 자체를 Test 의 Transactional 에 넘겨서 Test 에서 처리하게 하는 것이 아닌가 싶다. 아니면 롤백을 할 때는 서비스의 Transactional 을 수행해야 할 것 같으니, 순서? 같은 걸 스냅샷 같은 방법으로 남겨서 넘긴다던가??\n  conclusion  추측은 위험하지만, 당장의 지식으로 현 상황(삽질)을 정리하고 팠기에.. @Transactional 에 대한 정리가 필요하다. (적당히 알았는데, 라이프 사이클이라던가 동작 방식을 확실히 알 필요가 생겼다.) 자세히 모르고 사용하는 JPA 가 문제인가 싶기도 하다. 영속성 컨텍스트 에 대한 이해도 필요하다. (문제해결을 위해 읽어봤으나, 당장 훑어봐서는 이해가 잘 안된다.)  테스트 환경에서 JPA 주의점 을 봤지만 제대로 이해를 못했다. (내가 처한 것과 살짝 다른 것 같은 느낌도 들고 말이지..) JPA 변경 감지 오늘의 글을 쓰게 해준 고마운 아티클 (처음에는 잘 모르는 상태에서 save 를 사용해서 update 를 했음\u0026hellip;)    "
},
{
	"uri": "https://ysjune.github.io/posts/javascript/chapter17/error_debug/",
	"title": "17. 에러 처리와 디버깅",
	"tags": [],
	"categories": [],
	"series": ["자바스크립트 프로그래밍"],
	"description": "",
	"content": "다루는 내용  브라우저의 에러 보고에 대한 이해 에러 처리 자바스크립트 코드 디버그  1. 브라우저의 에러 보고에 대한 이해  주요 웹 브라우저는 자바스크립트 에러를 사용자에게 보고하는 기능을 갖추고 있음 대개 개발자에게만 쓸모있는 정보이므로 개발할 때는 에러 보고 기능을 켜야함  2. 에러 처리  기대할 수 있는 최선의 경우는 사용자가 무슨 일이 일어난 건지 모른 채 다시 시도해보는 것이며, 최악의 경우는 화를 내고 다시 방문하지 않는 것  2-1. try-catch   try 절에서 에러가 생기면 코드 실행을 즉시 멈추고, catch 절을 실행\n  catch 에 담기는 정보는 브라우저에 따라 다르지만, message 프로퍼티는 존재\n  finally 절은 항상 실행됨\n1 2 3 4 5 6 7 8 9 10  function trycatchFunction() { try{ return 2; // 무의미  } catch(error) { console.log(error.message); return 1; // 무의미  } finally { return 0; } }     에러 타입에는 Error, EvalError, RangeError, ReferenceError, SyntaxError, TypeError, URIError 이 있으며 모두 Error 타입을 상속\n  try-catch 문은 에러가 발생할 수도 있지만, 개발자가 컨트롤 할 수 없을 때 이상적\n ex) 라이브러리를 사용하고 에러가 날지 확신이 안 나는 상황에서 라이브러리를 직접 수정할 수 없을 때    2.2 에러 반환   throw 를 통해 언제든 커스텀 에러를 반환할 수 있음\n1 2 3 4 5 6 7 8  function CustomError(message) { this.name = \u0026#34;CustomError\u0026#34;; this.message = \u0026#34;message\u0026#34;; } CustomError.prototype = new Error(); throw new CustomError(\u0026#34;CustomError\u0026#34;);     브라우저는 개발자가 알고 있는 조건을 모르므로 불분명한 메시지 밖에 알릴 수가 없는데, 이럴 때 커스텀 메시지를 사용하면 명확한 단서를 제공할 수 있음\n  코드를 다룰 때 각 함수가 제대로 실행될 수 없는 상황에 대해 특히 주의!\n  커스텀 에러와 try-catch 문을 선택하는 최선의 기준은 해당 에러를 어떻게 처리할지 정확히 알고 있느냐 이다. try-catch 는 브라우저가 에러를 기본 방식대로 처리하지 못하게 막는 것이고, 커스텀 에러의 목적은 에러가 일어난 이유를 제공하는 것\n  2-3. error 이벤트   onerror 이벤트는 DOM 레벨 2 이벤트 표준을 따르지 않으므로 DOM 레벨 0 테크닉을 써서 할당해야 함\n1 2 3  window.onerror = function(message, url, line) { console.log(message); }     try-catch 문을 올바르게 사용사면 에러가 브라우저까지 전달되지 않으며, error 이벤트도 발생하지 않음\n  2-4. 에러 처리 전략  웹 애플리케이션의 자바 스크립트 레벨에서도 에러 처리 전략을 세워야 하며 그 중요성은 서버 레벨과 다르지 않음 미세한 자바스크립트 에러도 웹 페이지의 동작을 멈추게 할 수 있으므로 에러가 왜, 언제 일어나는지 파악해야 함  타입 강제 에러  값의 데이터 타입을 자동으로 바꾸는 연산자나 기타 언어 구조를 사용했을 때 발생 주로 == 와 != 연산자 혹은 if, for 같은 흐름 제어문에서 불리언이 아닌 값을 사용했을 때   데이터 타입 에러  느슨한 타입을 사용하므로 에러가 생기지 않도록 데이터 타입을 체크해줘야 함   통신 에러  URL 이나 데이터 형식이 잘못된 경우 서버의 응답이 예상과 다를 때 발생      2-5. 심각한 에러와 그렇지 않은 에러 구별   심각하지 않은 에러\n 사용자의 주요 작업을 방해하지 않는 에러 페이지의 일부분에만 영향을 끼치는 에러 복구 가능한 에러 다시 시도해보면 일어나지 않을 수 있는 에러    심각한 에러\n 애플리케이션 진행을 완전히 막는 에러 사용자의 주요 목적을 뚜렷이 방해하는 에러 다른 에러를 일으키는 에러    try-catch 를 사용해 에러가 발생해도 독립적으로 처리할 수 있도록 함\n1 2 3 4 5 6 7  for(var i=0, len=mods.length; i\u0026lt;len; i++) { try { modes[i].init(); } catch(ex) { //handle error  } }     3. 자바스크립트 코드 디버그  결국 디버그 정보를 표시할 코드에 삽입하는 식  3-1. 콘솔에 기록   개발자가 직접 콘솔에 기록하는 방식 (책의 예제 코드는 대부분 alert 였는데, 여태 console 로 했던 것)\n  error, info, log, warn 4가지 메소드가 있음\n1 2 3 4 5  var message = \u0026#34;console message\u0026#34; console.error(message); console.info(message); console.log(message); console.warn(message);     디버그가 편해지지만 배포할 때는 반드시 메시지를 모두 제거해야 함\n  alert 보다 더 나은 방법인 이유는 alert 이 프로그램 실행 흐름에 끼어들기 때문에 비동기적 프로세스에서는 결과가 달라질 수 있기 때문\n  3-2 페이지에 메시지 기록  innerHTML 을 통해 기록 콘솔을 지원하지 않는 브라우저에서 디버그 할 때 유용  "
},
{
	"uri": "https://ysjune.github.io/posts/javascript/chapter13/event/",
	"title": "13. 이벤트",
	"tags": [],
	"categories": [],
	"series": ["자바스크립트 프로그래밍"],
	"description": "",
	"content": "다루는 내용  이벤트 흐름에 대한 이해 이벤트 핸들러 다루기 여러 가지 타입의 이벤트 메모리와 성능  1. 이벤트 흐름에 대한 이해  자바스크립트와 HTML 의 상호작용은 문서나 브라우저 창에서 특정 순간에 일어난 일을 가리키는 이벤트에 의해 처리됨 이벤트는 리스너(핸들러) 로 추적하며 리스너는 이벤트가 일어날 때만 실행됨  1.1 이벤트 버블링   익스플로러의 이벤트 흐름\n  문서트리에서 가장 깊이 위차한 요소에서 시작해 거슬러 올라가는 방식\n1 2 3 4 5 6 7 8  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;title\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;myDiv\u0026#34;\u0026gt;click me\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;     \u0026lt;div\u0026gt; 요소를 클릭하면\n  \u0026lt;div\u0026gt; \u0026lt;body\u0026gt; \u0026lt;html\u0026gt; document   의 순서대로 발생\n    1.2 이벤트 캡처링  이벤트 버블링과는 반대로 최상위 노드에서 시작 오래된 브라우저에서는 지원하지 않으므로 이벤트 버블링을 주로 사용함  1.3 DOM 이벤트 흐름  이벤트 캡처링 단계, 타깃 단계, 이벤트 버블링 단계 3가지가 있음 이벤트 캡처링, 이벤트 버블링 두 단계가 다 타깃 단계와 맞물리는 곳이 있으므로 결과적으로 타깃에서 이벤트를 작업할 기회가 두 번 생김 (??)  2. 이벤트 핸들러  사용자 또는 브라우저가 취하는 특정 동작 on 으로 시작함  Ex) onclike, onload 등    2.1 HTML 이벤트 핸들러   이벤트 핸들러 이름을 HTML 속성에 사용하여 할당할 수 있음\n1 2 3 4 5 6 7 8 9 10  \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;click1\u0026#34; onclick=\u0026#34;alert(\u0026#39;clicked\u0026#39;)\u0026#34;/\u0026gt; or \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; function showMessage() { alert(\u0026#34;hello!\u0026#34;); } \u0026lt;/script\u0026gt; \u0026lt;input type=\u0026#34;buttion\u0026#34; value=\u0026#34;click1\u0026#34; onclick=\u0026#34;showMessage()\u0026#34;/\u0026gt;     스코프 체인이 확장되어 함수 내부에서 document 와 해당 요소의 맴버에 마치 로컬 변수처럼 접근이 가능(with 를 통해 이루어짐)\n1 2 3 4  \u0026lt;form method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34; value=\u0026#34;\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;echo\u0026#34; onclick=\u0026#34;alert(username.value)\u0026#34;\u0026gt; \u0026lt;/form\u0026gt;     이벤트 핸들러 코드가 준비되기 전에 HTML 요소가 먼저 화면에 발생하고 사용자가 이를 조작할 경우 에러가 발생할 가능성이 있음\n  이벤트 핸들러 함수의 스코프 체인 확장 결과가 브라우저마다 다름\n  HTML 과 자바스크립트 간의 커플링이 심하게 될 수가 있음 (변경이 어려움)\n  2.2 DOM 레벨 0 이벤트 핸들러   전통적으로는 이벤트 핸들러 프로퍼티를 함수에 할당하는 방법이 있음\n1 2 3 4 5 6 7  var btn = document.getElementById(\u0026#34;myBtn\u0026#34;); btn.onclick = function() { alert(this.id); // myBtn }; // 이벤트 핸들러를 제거할 경우 btn.onclick = null;     2.3 DOM 레벨 2 이벤트 핸들러   addEventListener(), removeEventListener()\n  매개변수 (이벤트 이름, 이벤트 핸들러 함수, 이벤트 핸들러를 캡처 단계에서 호출여부)\n1 2 3 4  var btn = document.getElementById(\u0026#34;myBtn\u0026#34;); btn.addEventListener(\u0026#34;click\u0026#34;, function() { alert(this.id); }, false);     위의 예제에서 함수는 익명함수 이기 때문에 removeEventListener 로 지울 수 없음. 따라서 해당 함수를 추가하고 지우고 하려면\n1 2 3 4 5 6 7 8 9  var btn = document.getElementById(\u0026#34;myBtn\u0026#34;); var handler = function() { alert(this.id); }; btn.addEventListener(\u0026#34;click\u0026#34;, handler, false); //do something  btn.removeEventListener(\u0026#34;click\u0026#34;, handler, false);     2.4 인터넷 익스플로러 이벤트 핸들러  IE8 및 이전 버전에서 사용 attachEvent(), detachEvent()  3. Event 객체 및 타입  DOM 과 관련된 이벤트가 발생하면 관련 정보는 모두 event 객체에 저장 이벤트 핸들러 내부에서 this 객체는 항상 currentTarget 의 값과 일치하며 target에는 이벤트의 실제 타깃만 포함 preventDefault() 메소드는 이벤트의 기본 동작을 취소 (cancelable 이 true) stopPropagation() 메소드는 이벤트 흐름을 멈춰서 이벤트 캡처링이나 버블링을 모두 취소 event 객체는 이벤트 핸들러가 아직 실행 중일 때만 존재하며 이벤트 핸들러가 실행을 마치면 event 객체는 파괴됨  3.1 이벤트 타입  UI 이벤트는 일반적인 브라우저 이벤트이며, BOM 과 상호작용이 포함될 수 있음 포커스 이벤트는 요소가 포커스를 얻거나 잃을 때 마우스 이벤트는 마우스로 어떤 동작을 취할 때 등의 카테고리가 있으며, 이 외에도 HTML5 에서 정의한 이벤트 집합이 있음  3.2 UI 이벤트  사용자와 직접 연관이 없으며, 하위 호환성을 위해 남겨진 것들 load - window 객체의 load 이벤트는 이미지나 자바스크립트 파일, CSS 파일 같은 외부 자원을 포함해 전체 페이지를 완전히 불러왔을 때 발생 unload - load 와는 반대로 문서를 완전히 닫을 때 발생하며 일반적으로 다른 페이지로 이동할 때 각종 참조를 제거하여 메모리 누수를 방지하는 목적으로 사용 resize - 브라우저 창의 높이나 너비를 바꿀 때 발생하며 브라우저별로 발생 시점에 차이가 있으므로 무거운 코드는 사용 지양  3.3 Focus 이벤트  이벤트 요소가 포커스를 받거나 잃을 때 발생 포커스를 잃는 요소에서 focusout, blur, DOMFocusOut 이 발생 포커스를 얻는 요소에서 focusin, focus, DOMFocusIn 이 발생  3.4 마우스 이벤트와 휠 이벤트  click - 사용자가 주요 마우스 버튼을 클릭하거나 엔터키를 누를 때 발생 dbclick - 사용자가 주요 마우스 버튼을 더블클릭할 때 발생 mousedown - 사용자가 마우스 버튼을 누를 때 발생 (키보드 발생 X) mouseenter - 마우스 커서가 요소 밖에서 요소 경계 안으로 처음 이동할 때 mouseleaver - 마우스 커서가 요소 위에 있다가 요소 경계 밖으로 이동할 때 mousemove - 마우스 커서가 요소 주변을 이동하는 동안 계속 발생 mouseout - 마우스 커서가 요소 위에 있다가 다른 요소 위로 이동할 때 발생 mouseover - 마우스 커서가 요소 바깥에 있다가 요소 경계 안으로 이동할 때 발생 mouseup - 사용자가 마우스 버튼을 누르고 있다가 놓을 때 발생    해당 이벤트가 지원되는지 확인하려면\n1 2 3 4 5  var isSupported = document.implementation.hasFeature(\u0026#34;MouseEvents\u0026#34;, \u0026#34;2.0\u0026#34;); or var isSupported = document.implementation.hasFeature(\u0026#34;MouseEvent\u0026#34;, \u0026#34;3.0\u0026#34;);     뷰포트 기준으로는 clientX/clientY, 페이지 기준으로는 pageX, pageY\n  mousewheel 이벤트는 사용자가 마우스 휠을 세로 방향으로 움직일 때 발생\n  웹페이지 접근성을 위해(스크린 리더 등 호환)\n  코드 실행에는 click 사용자에게 새 옵션을 제시할 때 onmouseover 사용 금지 중요한 동작을 dbclick 로 실행 금지     3.5 키보드와 텍스트 이벤트  keydown - 사용자가 키를 처음 누를 때 발생하며, 누르고 있는 동안에 계속 발생 keypress - 사용자가 키를 누른 결과로 문자가 입력되었을 때 처음 발생, 누르고 있는 동안 계속 발생 (textInput 사용 권장) keyup - 사용자가 키에서 손을 뗄 때 발생  3.6 HTML5 이벤트  contextmenu  마우스 우클릭을 했을 때 나오는 메뉴같은 형태로, 컨텐스트 메뉴가 표시되려는 순간에 발생하므로 개발자가 기본 메뉴를 취소하고 커스터마이징 할 수 있음 마우스 이벤트로 간주되므로 커서 위치와 관련된 프로퍼티를 포함   beforeunload  window 에서 발생하며 개발자에게 페이지에서 떠나지 못하게 막을 방법을 제공할 의도로 만들어짐   DOMContentLoaded  항상 load 이벤트보다 먼저 발생하므로 이벤트 핸들러를 등록하거나 다른 DOM 조작을 수행하는 데 쓰임 window 의 load 이벤트가 페이지를 완전히 불러와야 발생하므로 외부 자원이 많을 경우 시간이 걸릴 수 있으므로 그럴 경우 DOMContentLoaded 를 등록   readystatechange  문서나 요소를 불러오는 상황에 대한 정보로 readyState 라는 프로퍼티 uninitialized, loading, loaded, interactive, complete 라는 순서가 있으나 모든 객체가 이 단계를 순서대로 전부 밟지는 않음    4. 메모리와 성능  자바스크립트에서는 페이지에 존재하는 이벤트 핸들러의 개수가 페이지 성능에 직접적으로 영향을 미치는데  각 함수가 메모리를 점유하는 객체이기 때문 이벤트 핸들러를 많이 할당하려면 DOM 접근도 많아지며 이는 전체 페이지의 응답성을 떨어뜨리기 때문    4.1 이벤트 위임   이벤트 핸들러의 갯수에 대해서는 이벤트 핸들러 하나만 할당해서 해당 타입의 이벤트를 모두 처리하는 방법이 있음\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  \u0026lt;ul id=\u0026#34;myList\u0026#34;\u0026gt; \u0026lt;li id=\u0026#34;go1\u0026#34;\u0026gt;go1\u0026lt;/li\u0026gt; \u0026lt;li id=\u0026#34;go2\u0026#34;\u0026gt;go2\u0026lt;/li\u0026gt; \u0026lt;li id=\u0026#34;hi\u0026#34;\u0026gt;hi\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;script\u0026gt; var list = document.getElementById(\u0026#34;myList\u0026#34;); var handler = function() { switch(this.id) { case \u0026#34;go1\u0026#34;: document.title = \u0026#34;go1\u0026#34;; break; case \u0026#34;go2\u0026#34;: document.title = \u0026#34;go2\u0026#34;; break; case \u0026#34;hi\u0026#34;: document.title = \u0026#34;hi\u0026#34;; break; } }; list.addEventListener(\u0026#34;click\u0026#34;, handler, false); \u0026lt;/script\u0026gt;    이벤트가 버블링되어 올라오기 때문에 가능 현실적이기만 하다면 이벤트 타입마다 document 에 이벤트 핸들러 단 하나씩만 등록해서 페이지의 이벤트 전체를 처리하는게 좋음    4.2 이벤트 핸들러 제거   브라우저 코드와 자바스크립트 코드의 연결이 많을 수록 페이지가 느려지는데, 이 문제를 해결하기 위한 다른 방법(하나는 위의 위임 방법)은 더이상 필요하지 않은 이벤트 핸들러를 제거 하는 것\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u0026lt;div id=\u0026#34;myDiv\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;click me\u0026#34; id=\u0026#34;myBtn\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var btn = document.getElementById(\u0026#34;myBtn\u0026#34;); btn.onclick = function() { // doSomething  btn.onclick = null; // 잔류 핸들러 제거  document.getElementById(\u0026#34;myDiv\u0026#34;).innerHTML = \u0026#34;진행중\u0026#34;; }; \u0026lt;/script\u0026gt;     잔류 핸들러가 문제가 되는 다른 상황은 페이지를 떠날 때 이므로, 일반적으로 페이지를 떠나기 전에 onunload 이벤트 핸들러를 사용하여 이벤트 핸들러를 모두 제거하는 편이 좋음\n  onload 에서 한 일은 반드시 onunload에서 취소한다\n  "
},
{
	"uri": "https://ysjune.github.io/posts/java/jpa_annotation/",
	"title": "JPA 어노테이션",
	"tags": [],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "1. NotFound org.hibernate.annotations 에 포함되어 있음\n@JoinColumn 등으로 조인을 했을 시, 조인한 테이블의 값이 null 일 경우\nEntityNotFoundException 이 발생하는데, 이럴 경우\n1 2 3  @JoinColumn(\u0026#34;dto_id\u0026#34;) @NotFound(action = NotFoundAction.IGNORE) private DTO dto;   을 해주면 Exception 이 발생하지 않음. Ignore, Exception 2개의 값이 있는데 default 는 Exception 인 모양이다.\n2. Transient javax.persistence 에 포함되어 있음\nEntity 에 변수는 있으나, 컬럼과의 매핑을 원하지 않는 경우 사용\n1 2  @Transient private String compositeUrl;   주로 결과를 바로 넘기지 않고, 결과값을 조작해서 (filePath 에 fileName 을 더해준다거나..) 새로운 변수에 넣거나 할 때 썼다.\n3. JsonIgnore 엄밀히 말하면 JPA 용 annotation 은 아니지만, 사용할 땐 2번과 연관하여 사용했던 것 같다.\n결과 형태를 json 으로 뿌려줄 때, 해당 변수가 출력되지 않게 함\n1 2  @JsonIgnore private Member member;   4. Embedded, Embeddable Entity 안에 다른 Entity 를 넣을 경우 해당 annotation 들을 사용, 관련있는 것들을 하나로 묶어서 객체로 사용할 때 사용함\nex) Article 이라는 클래스가 있고, 해당 등록 정보를 RegInfo 로 관리한다고 하면\n1 2 3 4 5 6 7 8 9 10  @Entity public class Article { @ID private Long id; private String content; @Embedded private RegInfo regInfo; }   1 2 3 4 5 6 7 8 9  @Entity @Embeddable public class RegInfo { @Column(\u0026#34;reg_id\u0026#34;) private Long regId; @Column(\u0026#34;reg_dt\u0026#34;) private LocalDateTime regDt; }   5. Convert DB에서 사용하는 값과 서버에서 사용하는 타입이 서로 달라 값을 변경해줘야 할 때 사용\n주로 IP (127.0.0.1) 같이 String 으로 받은 값인데, DB 에는 Number 형태로 저장하거나 서버에서는 Boolean 값을 사용하는데 DB 에서는 Y/N 값으로 저장할 때 사용하곤 했다.\n1 2 3  @Convert(converter = YNBooleanConverter.class) @Column(\u0026#34;use_yn\u0026#34;) private Boolean use;   당장 쓰는 것 중에 생소한 것은 이정도 되는 것 같다.\n추후 진행하면서, 새로운 걸 써보면 그 때 추가할 예정.\n"
},
{
	"uri": "https://ysjune.github.io/posts/javascript/chapter11/dom-extension/",
	"title": "11. DOM 확장",
	"tags": [],
	"categories": [],
	"series": ["자바스크립트 프로그래밍"],
	"description": "",
	"content": "다루는 내용  선택자 API 에 대한 이해 HTML5 DOM 확장 사용 브라우저 전용 DOM 확장 사용  1. 선택자 API  CSS 선택자로 패턴을 만들고 그에 맞는 DOM 요소를 선택하는 능력  (Ex. jQuery)    1-1 querySelector()   CSS 쿼리를 받고 패턴에 일치하는 첫 번째 자손 요소를 반환 없으면 null\n1 2 3 4 5 6 7  var body = document.querySelector(\u0026#39;body\u0026#39;); // ID 가 \u0026#39;div1\u0026#39; 인 요소 var div1 = document.querySelector(\u0026#39;#div1\u0026#39;); // 클래스가 selected 인 것 중 첫 번째 var selected = document.querySelector(\u0026#39;.selected\u0026#39;)     Document 타입에서 호출하면 패턴에 맞는 요소를 문서에서 찾으며 Element 타입에서 호출하면 해당 요소의 자손에서만 쿼리\n  1-2 querySelectorAll()   querySelector() 와 비슷하나 일치하는 노드 전체를 반환\n  처음 접근한 상태의 NodeList 의 정적 인스턴스 반환\n1 2 3  var ems = document.getElementById(\u0026#39;myDiv\u0026#39;).querySelectorAll(\u0026#39;em\u0026#39;); var selecteds = document.querySelectorAll(\u0026#39;.selected\u0026#39;);     2. HTML5  마크업 언어와 함께 사용하도록 디자인된 자바스크립트 API 를 상세히 설명하고 정의  2-1 클래스 관련   getElementsByClassName()\n 클래스 이름 문자열을 매개변수로 받음 해당 클래스를 가모두 가진 요소의 NodeList 반환  1 2 3  // div1 의 자손 중 selected 클래스가 있는 요소를 모두 찾음 var selected = document.getElementById(\u0026#39;div1\u0026#39;) .getElementByClassName(\u0026#39;selected\u0026#39;);     classList 프로퍼티\n 클래스 이름을 안전하고 단순하게 조작 가능 DOMTokenList란 컬렉션 타입의 인스턴스 add(value) - 주어진 문자열 값을 목록에 추가 contains(value) - 주어진 값이 목록에 존재하면 ? true : false remove(value) - 주어진 문자열 값을 목록에서 제거 toggle(value) - 값이 목록에 존재하면 ? 제거 : 추가  1 2 3 4 5 6 7 8 9 10 11 12 13  // disabled 클래스 제거 div.classList.remove(\u0026#39;disabled\u0026#39;); // current 클래스 추가 div.classList.add(\u0026#39;current\u0026#39;); // user 클래스 토글 div.classList.toggle(\u0026#39;user\u0026#39;); // bd 클래스 포함여부 확인 if(div.classList.contains(\u0026#39;bd\u0026#39;)) { // do Something }     2-2 포커스 관리   사용자가 지금 페이지를 보고 있는지 알 수 있음\n  document.activeElement, focus()\n1 2 3 4  var button = document.getElementById(\u0026#39;myButton\u0026#39;); button.focus(); console.log(document.activeElement === button); // treu console.log(document.hasFocus()); // true     2-3 HTMLDocument의 변화  readyState : 문서를 불러왔는지 확인  loading - 문서를 불러오는 중 complete - 문서를 완전히 불러옴    2-4 커스텀 데이터 속성   렌더링에 필요한 정보나 시멘틱 값이 아닌 데이터를 접두사 data- 가 붙은 비표준 속성에 제공\n  dataset 프로퍼티로 접근 가능\n1 2 3 4 5 6  \u0026lt;div id=\u0026#34;myDiv\u0026#34; data-appId=\u0026#34;111\u0026#34; data-myName=\u0026#34;snack\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; var div = document.getElementById(\u0026#34;myDiv\u0026#34;); var appId = div.dataset.appId; var myName = div.dataset.myName;     요소에 데이터를 연결해야 하지만, 사용자에게는 보이고 싶지 않을 때 유용\n  2-5 마크업 삽입   innerHTML\n 읽기모드로 사용 시 요소와 주석, 텍스트 노드 등의 자식 노드를 모두 나타내는 HTML 표현을 반환 (직렬화 후 문자열로 반환) 쓰기 모드로 사용 시 주어진 값을 바탕으로 자식 노드를 교체 \u0026lt;script\u0026gt;로 삽입된 것은 실행되지 않음    outerHTML\n 호출한 HTML 요소를 자식 노드와 함께 반환    1 2 3 4 5 6  \u0026lt;div\u0026gt; \u0026lt;span\u0026gt;hi!\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; //innerHTML - div 에서 innerHTML -\u0026gt; \u0026lt;span\u0026gt;만 포함하는 객체 //outerHTML - div 에서 outerHTML -\u0026gt; div 가 포함된 객체     insertAdjacentHTML\n beforebegin - 바로 앞 삽입 afterbegine - 첫 번째 자식으로 삽입 beforeend - 마지막 자식으로 삽입 afterend - 바로 뒤에 삽입    메모리와 성능 문제\n 요소와 이벤트 핸들러 사이의 연결이 메모리에 남기 때문에, 위의 메소드를 사용할 땐 제거할 요소의 이벤트 핸들러나 자바스크립트 객체 프로퍼티를 모두 제거해야 함    2-6 scrollIntoView()   브라우저 창이나 컨테이너 요소를 스크롤해서 해당 요소가 뷰포트에 보이게 함\n1 2  //forms[0] 요소로 이동 document.forms[0].scrollIntoView();     3. 전용 확장 3-1 문서모드  IE에서 도입한 개념으로 각 모드마다 CSS, 자바스크립트 기능이 다름 document.documentMode 특정 문서 모드를 강제할 수 있으며, 페이지가 어떻게 동작할지 힌트를 얻을 수 있음  3-2 children 프로퍼티  요소의 자식 요소만 포함하는 HTMLCollection 요소인 노드만 포함한다는 점을 제외하면 childNodes 와 같음  3-3 contains()   주어진 노드가 다른 노드의 자손인지 확인 가능\n1  document.documentElement.contains(document.body); // true     3-4 innerText, outterText  텍스트 노드를 모두 결합한 값을 반환  1 2 3 4 5 6 7 8 9 10  \u0026lt;P\u0026gt;hello\u0026lt;/P\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;go 1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;go 2\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; ----------------------------- /* result */ hello go 1 go 2    파이어폭스 에서는 textContent outterText 의 경우 자신을 호출한 요소 전체를 변경하기에 사용을 지양  3-5 스크롤  scrollIntoViewIfNeeded(alignCenter) - 호출한 요소가 뷰포트에서 보이지 않을 경우만 해당 요소로 이동  크롬, 오페라 사파리만 구현   scrollByLines(lineCount) - lineCount 의 숫자 만큼 스크롤  파이어 폭스에서만 구현 (참고)   scrollByPages(pageCount) - pageCount 의 숫자 만큼 페이지 스크롤  파이어 폭스에서만 구현 (참고)   모든 브라우저에서 지원하는 것은 scrollIntoView() 이므로 보통 이 메소드만 사용  "
},
{
	"uri": "https://ysjune.github.io/posts/javascript/chapter10/dom/",
	"title": "10. DOM",
	"tags": [],
	"categories": [],
	"series": ["자바스크립트 프로그래밍"],
	"description": "",
	"content": " DOM 을 노드의 계층 구조로 이해 다양한 노드 타입 브라우저들 간의 비호환성을 우회하는 DOM 코딩  1. 노드의 계층 구조   HTML 과 XML 문서는 모두 DOM 을 통해 노드의 계층 구조로 표현 가능\n1 2 3 4 5 6 7 8  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Sample\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Hello\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;    문서 노드(Document) 는 각 문서를 루트로 표현함. 위에서 문서 노드의 자식은  하나 뿐인데 이를 문서요소 라고 함 문서 요소는 문서의 최상위 요소이며 다른 요소는 모두 이 안에 존재 문서 하나에 문서 요소 하나만 있을 수 있음    2. 다양한 노드 타입 2-1 Node 타입   DOM 레벨 1에는 Node 라는 인터페이스가 존재\n  각 노드에는 childNodes 라는 프로퍼티가 있는데 이 프로퍼티에는 NodeList 가 저장됨\n  NodeList는 처음 호출했을 때 얻은 결과를 저장하고 있는 것이 아니라 계속 바뀌므로 살아있는 객체라고 부르기도 함\n1 2 3 4 5 6  var firstChild = someNode.childNodes[0]; var secondChilde = someNode.childNodes.item(1); var count = someNode.childNodes.length; // 2  someNode.childNodes.appendChild(newNode); console.log(count); // 3     각 노드에서는 문서 트리에서 부모를 가르키는 parentNode 프로퍼티가 있으며, childNodes 목록에 각 노드는 형재관계로 previousSibling, nextSibling 으로 접근 가능하며, 부모 입장(parentNode) 에서는 firstChild, lastChild 로 접근 가능\n  노드 조작 메소드\n   appendChild() - childNodes 목록 마지막에 노드 추가\n  insertBefore() - childNodes 특정 위치에 삽입\n  replaceChild() - 기존 노드 교체\n  removeChild() - 노드 삭제\n    replaceChild() 와 removeChild() 는 해당 문서의 소유이긴 하지만 문서에서 위치를 지정받진 못한 상태라 볼 수 있음    cloneNode()\n1 2 3 4 5  // 자손 노드 전체 복사 var deepList = myList.cloneNode(true); // 해당 노드 하나만 복사 var shallowList = myList.cloneNode(false);     2-2 Document 타입   문서 노드를 Document 타입으로 표현\n  window의 프로퍼티이므로 전역에서 접근 가능\n1 2 3 4 5 6  var html = document.documentElement; // \u0026lt;html\u0026gt; var body = document.body; // \u0026lt;body\u0026gt; var doctype = document.doctype; // \u0026lt;!DOCTYPE\u0026gt;  var title = document.title; // title 가져오기 document.title = \u0026#34;new Title\u0026#34;; // title 변경     요소 위치\n1 2 3 4 5 6 7 8 9 10  \u0026lt;img src=\u0026#34;myImage.png\u0026#34; name=\u0026#34;myImage1\u0026#34; id=\u0026#34;myImage\u0026#34;\u0026gt; // 요소 ID 를 매개변수로 받음 var imgById = document.getElementById(\u0026#39;myImage\u0026#39;); // 요소 tag name 을 매개변수로 받음 var imgByTag = document.getElementByTagName(\u0026#39;img\u0026#39;); // 요소 name 을 매개변수로 받음 var imgByName = document.getElementByName(\u0026#39;myImage1\u0026#39;);     문서에 쓰기\n1 2 3 4 5 6 7 8 9 10  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;document.write() Example\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; document.write(\u0026#34;\u0026lt;script type=\\\u0026#34;text/javascript\\\u0026#34; src=\\\u0026#34;file.js\\\u0026#34;\u0026gt;\u0026#34; + \u0026#34;\u0026lt;\\/script\u0026gt;\u0026#34;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;     2-3 Element 타입   HTML 요소\n  Id - 요소의 고유 식별자 title - 요소의 추가정보로 일반적으로 툴팁으로 표현됨 classNmae - 요소의 CSS 클래스인 class 속성     속성 얻기\n   getAttribute()\n  setAttribute()\n  removeAttribute()\n    주로 커스텀 속성을 다룰 때 사용  1 2  div.myColor = \u0026#34;blue\u0026#34;; console.log(div.getAttribute(\u0026#34;myColor\u0026#34;)); // null    대부분의 브라우저에서 이 프로퍼티는 자동으로 요소 속성이 되지는 않으므로 getAttribute()로 같은 이름의 속성에 접근하면 null 을 반환    요소 생성\n1 2 3 4 5 6  var div = document.createElement(\u0026#39;div\u0026#39;); div.id = \u0026#34;myNewDiv\u0026#34;; div.className = \u0026#34;box\u0026#34;; // 생성한 요소를 문서 트리에 추가해야 반영 document.body.appendChild(div);     2-4 Text 타입   평범한 텍스트가 포함되고, 글자 그대로 사용됨\n  이스케이프된 HTML 문자는 포함할 수 있지만, HTML 코드는 포함 불가능\n1 2 3 4 5  var textNode = document.createTextNode(\u0026#34;\u0026lt;strong\u0026gt;hello\u0026lt;/strong\u0026gt; wolrd\u0026#34;); element.appendChild(textNode); document.body.appendChild(element);     2-5 Comment 타입   주석은 DOM 에서 Comment 타입으로 표현\n1  var comment = document.createComment(\u0026#34;comment\u0026#34;);     2-6 CDATASection 타입   XML 기반 문서 전용 (myBatis를 사용하면 자주 봄)\n1  \u0026lt;div id=\u0026#34;myDiv\u0026#34;\u0026gt;\u0026lt;![CDATA[this is some content.]]\u0026gt;\u0026lt;/div\u0026gt;     2-7 DocumentType 타입   문서의 독타입 정보\n\u0026lt;!DOCTYPE HTML PUBLIC \u0026quot;-//W3C\u0026quot; ~~~~\u0026gt; console.log(document.doctype.name); // HTML   3. DOM 다루기  DOM 조작은 단순하며, 자바스크립트를 쓸 때도 일반적인 HTML 코드와 마찬가지로 하면 됨 (언제나 예외는 있지만..)  3-1 동적 자바스크립트   1  \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;client.js\u0026#34; /\u0026gt;     1 2 3 4 5 6 7 8  function loadScript(url) { var script = document.createElement(\u0026#39;script\u0026#39;); script.type = \u0026#34;text/javascript\u0026#34;; script.src = url; document.body.appendChild(script); } loadScript(\u0026#34;client.js\u0026#34;)     3-2 동적 스타일   1  \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;styles.css\u0026#34;\u0026gt;     1 2 3 4 5 6 7 8 9 10  function loadStyles(url) { var link = document.createElement(\u0026#39;link\u0026#39;); link.rel = \u0026#34;stylesheet\u0026#34;; link.type = \u0026#34;text/css\u0026#34;; link.href = \u0026#34;style.css\u0026#34;; var head = document.getElementByTagName(\u0026#39;head\u0026#39;)[0]; head.appendChild(link); } loadStyles(\u0026#34;styles.css\u0026#34;);     3-3 노드리스트 사용   살아있는 객체로 간주되기에 무한 루프가 될 수 있음\n1 2 3 4 5 6 7 8 9 10  var divs = document.getElementByTagName(\u0026#39;div\u0026#39;), i, div; for(i = 0; i \u0026lt; divs.length; i++) { div = document.createElement(\u0026#39;div\u0026#39;); document.body.appendChild(div); } // 루프가 반복될 때마다 i \u0026lt; divs.length 조건을 확인하는데 // divs.length 가 계속 갱신되므로 무한 루프   1 2 3 4 5 6 7 8 9  var divs = document.getElementByTagName(\u0026#39;div\u0026#39;), i, len, div; for(i = 0, len = divs.length; i \u0026lt; len; i++) { div = document.createElement(\u0026#39;div\u0026#39;); document.body.appendChild(div); }     컬렉션에 접근할 때마다 다시 쿼리 하므로, 일반적으로 NodeList 자체에 접근하는 일은 되도록 피하는 것이 좋음. 사용한다면 변수에 저장하여 사용\n  "
},
{
	"uri": "https://ysjune.github.io/posts/chatter/2019retrospect/",
	"title": "2019년 회고",
	"tags": [],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "이전에는 생각만 하고 남겨뒀던 것들을 블로그를 만들고 나니 써봐야 겠다는 생각이 들었다. 그렇게 하여 이번에는 2019년의 생각을 남기고자 한다.\n실제로 작성을 생각했던 건 지난 주 였는데, 이러저러한 사정 때문에 이제서야 쓰게 되었다. (좀 더 늦추면 회고가 아닌 신년 다짐이 될 거 같기에..)\n1. 업무 외적으로 받는 스트레스가 많았던 상반기 현재 회사는 지인의 소개로 작년 9월에 입사했었다. 당시 팀은 AI스피커 를 개발하는 팀이었고, 나름 신기술 셋(스프링 부트, Angular2, Junit5, AIML, 레디스 등) 으로 재밌었다. 하지만, 프로젝트의 중추를 맞고 있는 사수가 건강상의 이유로 퇴사하고 그 이후로는 정말 힘들었다. 새로운 상사가 오고 엄청나게 맞지 않았었고, 그런 업무 스타일로 인해 퇴사까지 결심했었다가 그래도 무슨 오기(?)인지 프로젝트가 끝날 때까지만 하고 나가려고 생각했었다.\n1-1 끝나지 않는 프로젝트 이미 1-2 차례 밀린 적이 있는 프로젝트였다. (중추가 없고, 밀린 프로젝트는 성공 가망성이 없는데, 이 때는 경험도 없거니와 너무 몰랐다.)\n퇴사를 생각했던 시기가 3월 즈음이었고, 프로젝트 오픈 예정은 4월 즈음이었다. 한 달 정도는 버틸만 하다고 생각했다. (그리고 내 쪽은 이전부터 오픈 준비가 되어 있었다\u0026hellip;) 하지만, 또 오픈을 못 하게 되었고, 이번에는 10월인가로 밀려버렸다. 아무 생각도 안 들었다. 이미 상사한테 받는 스트레스는 많았고, 1달 정도는 참을 수 있었지만 10월까진 아니다.\n1-2 다른 방법을 찾아서 3월에 퇴사를 생각하긴 했지만, 너무 억울하단 생각이 들었다. 이 회사에 작년 9월에 왔고, 이제 겨우 6개월인데 나가면 커리어도 엉망이 되고, 무엇보다 상하 관계라는 위치의 한 사람때문에 나가는 게 무척 싫었다. 그래서 다른 팀 팀장님한테 상담을 요청했었다. 당시에는 옮기고 싶다는 직접적인 얘기보다는 상황이 이러한테 제가 어떻게 하면 좋을까요 같은 그런 얘기를\n1-3 팀을 옮기다 프로젝트가 갑자기 뒤로 훅 밀리면 (거의 6개월 가량 밀렸다) , 긴장도 풀어지고 더 늘어지는 것을 경험했다.\n이미 의욕은 없는 상태였다. 회사가 재미가 없고 주도권이 없는데 무슨 의욕이 생기겠는가. 게다가 소속 부서의 분사 얘기까지 나돌았다.\n돌이켜보면 이건 참 좋은 기회였다. 분사를 한다는 얘기가 돌아서 남을 것인지, 분사한 곳에 갈 것인지 의견을 묻는데 난 당연히 갈 이유가 없었다 남는다고 얘기를 했고, 그렇게 팀을 옮기게 되었다.\n 여담이지만, 분사 덕분에 사원 -\u0026gt; 주임 의 진급 누락도 경험해봤다 ㅋㅋㅋ\n(진급 별로 신경도 안 쓰고, 한다해도 연봉이 안 오른다는 얘기를 듣고 더 관심없어졌었다.)\n 2. 새로운 팀에서 (중반기? 이후) 팀을 옮기고 맡은 업무는 백오피스 (관리자 페이지) 에서 오프라인 사업부와 관련된 일을 맡았다.\n당시 오프라인 사업부에서 사용하는 모바일 페이지를 변경한다고 했기에, 그게 새로운 팀에서 맡은 첫 업무(프로젝트?) 였다.\n2-1 보기싫은 레거시 코드와 JqueryMobile 무엇을 개발하든, 처음에는 분석이 필요하기에 기존에 어떻게 구현되어 있는지 코드를 보고 설명을 들었다.\n그리고 알아낸 프로세스는 대략 이랬다.\n 비회원에 대한 정보를 입력 정제라는 프로세스를 진행(비회원으로 등록이 가능한지) 비회원으로 등록되면 익일 배치 프로세스를 통해 체험 회원으로 전환  문제는 2,3 번의 정제, 배치 프로세스가 둘 다 DB 프로시저로 되어 있고,\n몇 천줄 이렇게 되니까 감히 건드를 수가 없었고, 설사 건드린다해도 엄청난 공수가 들 것은 뻔했다.\n게다가 데이터의 대부분을 Map 을 통해 전달하니 일일히 디버그를 통해 데이터를 분석하는 수고도 겸사겸사했다.\n 물론 레거시가 무조건 싫다거나 그런 건 아니다. 일단은 작동하는 코드이기도 하니까.\n단지, 그런 걸 보고도 고칠 역량이 안되는 자신과 욕을 하면서도 그와 비슷한 코드를 생산하는 자신한테 화가 날 뿐이다.\n 그런 의미에서 JqueryMobile 도 꽤나 의문이 많이 들었다. 사이트를 들어가보니 더이상 update 를 안하는 것 같은 느낌에, Jquery도 이젠 거의 사용을 안하는 추세인데 JqueryMobile은 더 그렇지 않을까 하는 생각도 들었고 말이다.\n2-2 그래도 새로운 것도 많이 알았다. 아직은 배울 게 많은 주니어 개발자이다. 그런 의미에서 주변에 좋은 자극을 줄 수 있는 좋은 경험 많은 동료가 있다는 건 좋다.\n오프라인 사업부 일을 어느정도 끝낸 시점에서 회사 서비스의 고도화 프로젝트에 투입되었다. (고도화 내용을 조금씩 쪼개서 진행하는데, 몇 차 까지 있는진 모르겠으나, 어쩌다보니 1,2,3 차 다 참여하게 되었고, 현재는 3차를 진행중이다.)\n대략 생각나는 대로 열거해보면 이렇게 되는 것 같다.\n(물론 대부분은 블로그에 정리해놓은 것들이며, TypeScript 를 손 놓은게 아쉽긴 하다.)\n nGrinder 사용 및 정리 (부하 테스트) Feign 사용 및 정리 (API 통신) wireMock, Mockito 등 테스트 mock 사용 경험 모델 기반에 대한 설계 경험 아파치 설정을 통한 서버 구성 Jenkins 파일을 통한 배포 자동화(?) 경험 등  물론 경험에서 끝내면 안된다, 지속적으로 하고, 정리를 해야 내 것이 되니까.\n그리고 이번에 3차를 진행하면서 Kotlin, JPA 를 경험 하고 있다. 둘 다 새로 사용해보는 것들이라 공부를 많이 해야 겠다.\n2-3 욕심이 많아서 그런걸까 반 년 정도의 시간 동안 많다고 하면 많을 수 있고, 적다고 하면 적을 수 있는 것들을 알게되었다.\n이전 회사에서 여유가 없이 생활을 해서 그런지, 현재 회사의 여유로운 상황에서 뭘 해야 될 지 모르겠다.\n시간적 여유가 생기다보니 깃에 레포를 하나 만들어서 정리도 하게되고, (정리만 하다가 재미없어서 블로그까지 만들게 되었지만..)\n근데 그렇게해도 남는 잉여 시간이 많으니까, 답답함을 느끼게 되는 것 같다.\n내가 겁은 많지만, 그렇다고 마냥 평온을 바라지는 않는 것 같다 ㅋㅋㅋ\n3. 업무 외 적으로는 무엇을 했는가 대부분 하반기부터 시작한 것이긴 하지만, 그래도 올해는 업무 외 적으로 이것저것 시도해본 것 같다.\n경험에 없던 것들이니 차근차근 진행해나가면 도움이 되지 않을까?\n3-1 설계 세미나 회사에서 주니어 개발자들 (5명 정도?) 을 대상으로 최범균 님이 모델, 설계에 대해서 강의 형식으로 알려주신다.\n기존의 MVC 의 개념과 DB 데이터 중심적인 사고에서 벗어나 도메인 중점에 대한 연습을 할 수 있다는 점에서 배우는 점이 많다.\n 기능에는 Input 과 OutPut 이 있다 What 과 How 를 얼마나 잘 나누느냐에 따라 좋은 설계가 된다 관련된 기능을 최대한 한 군데로 모와야 한다 등  많은 도움이 된다. 아쉬운 점이 있다면, 지속적인 연습을 통해 코드에 녹여내야 하는데, 그렇게 못하는 점? (역시 꾸준함이..)\n3-2 리눅스 스터디 회사에서 진행한 스터디로 공통적으로 배우면 좋은 내용이 무엇이 있을까 하여 진행한 스터디로, 리눅스에 대한 전반적인 내용을 다뤘다.\n회사에서 진행한 것이다보니, 빠지는 인원이 없다는 점과 편안하게 진행할 수 있다는 점이 괜찮았다.\n또한, 학부생 때 배웠던 OS 에 대한 내용을 간단히 리마인드 할 수 있는 기회이기도 했다.\n하지만, command line 환경이 아직은 익숙치 않기에\u0026hellip;\n3-3 프로그래밍 패턴 스터디 페이스북 그룹인 신림프로그래머 에서 진행한 스터디로 프로그래밍 패턴에 대한 역사적 흐름을 살펴보는 책인데,\n내 수준에서는 엄청 어려웠으면서도 엄청 자극을 받은 스터디였다.\n(책의 내용에서 자극을 받았다기보단, 같은 스터디원들한테서 자극을 많이 받았다.)\n꽤나 많은 내용이 있었지만, 겨우 코드 이해하고 갔던 정도라 많은 내용이 기억이 남아있진 않다.\n그래도 가끔 아 이런 비슷한 거 어디서 본 거 같은데.. 하고 책을 보면 또 아 이랬지 하고 기억이 나기에 그나마 다행일까?\n3-4 자바스크립트 스터디 이 스터디는 시작하기 전 부터 꽤나 우여곡절이 많았다.\n일단, 자바스크립트에 대해 별로 관심이 있진 않았다. 어차피 난 서버 개발쪽으로 갈 거니까.\n근데, 이게 또 시간이 지나니까 생각이 바뀌더라.\n자바스크립트 시장은 커지고, 어차피 뗄래야 뗄 수 없다면 공부해서 걱정은 안되게 해야지 라고 생각을 변환하기 까지 1년 정도가 걸렸다.\n처음에는 회사에서 모집을 했었다. 그런데 역시나 굳이 자바스크립트 스터디를 해야돼? 라는 인원이 많아서 회사에서는 포기하고, 외부 스터디나 개인적으로 인강이나 들을까 하고 했었다.\n그러다가 프론트팀에 의욕넘치는 대리님이 오고, 같이 스터디 하자고 했기에 어찌어찌 인원을 모와서 진행했다.\n처음에는 5명이었으나, 이직 등의 이유로 현재는 3명으로 조금은 빡새지만, 재밌게 진행하고 있다.\n4. 내년에는 무엇을? 회고를 했기에 미래를 계획해볼 수 있는 자리이지 않을까 싶다.\n물론 이 중에서 무엇을 할지, 내년 회고에서는 어떤 내용이 자리를 차지하고 있을지는 모르겠으나,\n일단 현재 관심사에 대해서 간략하게? 큰 덩어리로? 리스트업 한다면,\n Kotlin Docker 같은 컨테이너? TypeScript + React? 레거시 코드 활용 전략 - 책 (스터디로 하면 좋겠다) Rust? Go? 바이올린 (매년 벼르지만, 매년 못하고 있다.)  4. 맺으며 1년이 짧아보이기도 하지만, 또 이렇게 회고를 하면 결코 짧지만은 않은 시간이다.\n이 글을 쓰기 전에 다른 개발자들의 회고를 읽었는데, 대단한 사람들은 역시 많다.\n내가 1년 동안 있었던 일에 대해 생각해서 쓴 글인데, 누군가는 상반기인데도 이 내용보다 많다.\n예전같았으면, 부럽다라는 생각을 가지면서도 아무것도 안했을 것이다.\n하지만, 지금은 다르다. 물론 부럽다라는 생각이 안들면 거짓말이겠지만, 그 사람은 그 사람이고, 내가 그 사람일 순 없으니, 나는 나대로 내 페이스대로 꾸준히 진행하면 되지 않을까 싶다.\n취미로 참가하는 마라톤 처럼 중간에 포기하지만 않으면 결국 골인 지점은 나오니까 말이다.\n"
},
{
	"uri": "https://ysjune.github.io/categories/%EC%83%9D%EA%B0%81%EA%B1%B0%EB%A6%AC/",
	"title": "생각거리",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ysjune.github.io/posts/java/encapsulation/",
	"title": "캡슐화(encapsulation)",
	"tags": [],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "캡슐화(encapsulation)  객체가 내부적으로 기능을 어떻게 구현하는지를 감추는 것 내부의 기능 구현이 변경되더라도 그 기능을 사용하는 코드는 영향을 받지 않음  내부 구현 변경의 유연함을 줌    1. 절차 지향 방식과의 비교  회원의 서비스 만료 날짜 여부에 따른 처리를 하는 로직  1. 절차 지향 방식 코드 1 2 3 4 5 6  @Getter public class Member { ... private Date expireDate; private boolean male; }   1 2 3 4  if(member.getExpireDate() != null \u0026amp;\u0026amp; member.getExpireDate().getTime() \u0026lt; System.currentTimeMillis()) { // 만료 시 처리 로직 }     Member 의 expireDate 를 현재 시간과 비교해서 만료 여부를 체크한다. 그리고 이와 비슷한 로직은 여러 군데에서 쓰일 것 이다.\n  살아있는 서비스는 시간이 지남에 따라 크기가 커질 것이고, 제약 사항 또한 생길 것이다. 그리고 다음과 같이 정책이 변경되었다고 하면\u0026hellip;\n 여성 회원인 경우 만료 기간이 지났어도 30일 간은 서비스를 이용 가능하게 정책 변경\n 1 2 3 4 5 6 7  long days30 = 1000 * 60 * 60 * 24 * 30; // 30 days if((member.isMale() \u0026amp;\u0026amp; member.getExpireDate() != null \u0026amp;\u0026amp; member.getExireDate().getTime() \u0026lt; System.currentTimeMillis()) || (!member.isMale() \u0026amp;\u0026amp; member.getExpireDate() != null \u0026amp;\u0026amp; member.getExireDate().getTime() \u0026lt; System.currentTimeMillis() - days30)) { // 만료 시 처리 로직 }    비슷한 로직이 여러 군데에서 쓰일 테니, 일일히 변경해줘야 한다. 게다가, 현실과 같이 정책이 수시로 변경된다면..? (ㅁㄴㅇㅁ)    이 부분은 What 과 How 에 대해서도 접근해볼 수 있다고 생각되는데, 지나치게 How 중심적으로(혹은 데이터 중심적으로) 했기 때문에 이런 문제가 발생한 것이다. 그러면 이번엔 객체 지향 방식으로 변경해보자.\n  2. 객체 지향 방식 코드 (캡슐화 진행 코드)  캡슐화는 기능을 내부적으로 어떻게 구현되었는지 숨기는 것  1 2 3 4 5 6 7 8 9 10 11  @Getter public class Member { ... private Date expireDate; private boolean male; public boolean isExpired() { // 만료 여부를 Member 객체 내부에 캡슐화  return expireDate != null \u0026amp;\u0026amp; expireDate.getTime() \u0026lt; System.currentTimeMills(); } }   1 2 3  if(member.isExpired()) { // 만료에 따른 처리 }     다른 클래스에서는 isExpired() 가 어떻게 구현되었는지 알 수 없고, 알 필요도 없다. 그냥 완료되었는지 안 되었는지에 대한 결과만 알면 된다.\n  절차 지향 때와 마찬가지로 정책이 변경된다면?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  @Getter public class Member { private static final long DAYS30 = 1000 * 60 * 60 * 24 * 30; // 30 days  ... private Date expireDate; private boolean male; public boolean isExpired() { // 만료 여부 수정  if(male) { return expireDate != null \u0026amp;\u0026amp; expireDate.getTime() \u0026lt; System.currentTimeMills(); } return expireDate != null \u0026amp;\u0026amp; expireDate.getTime() \u0026lt; System.currentTimeMills() - DAYS30; } }    다음과 같이 isExpired() 를 수정해주면 된다. 그리고 isExpired() 를 사용하는 곳은 수정해줄 필요가 없다. (메소드 내부가 변경되었지, 메소드 이름이 바뀌거나 파라미터가 생긴 것은 아니니까)    2. 캡슐화의 결과  기능을 캡슐화하면 내부 구현이 변경되더라도, 기능을 사용하는 곳의 영향을 최소화할 수 있다. 변경의 유연함을 얻게 되어, 쉽게 구현을 변경할 수 있게 된다.  3. 캡슐화를 위한 2개의 규칙 1. Tell, Don't Ask  데이터를 물어보지 않고, 기능을 실행해 달라고 말하는 것 절차 지향에서는 데이터를 직접 확인했었으나 (member.expireDate()), 캡슐화로 변경했을 시에는 기능 실행을 요청하면 된다. (member.isExpired())  2. 데미테르의 법칙 (Law of Demeter)   메소드에서 생성한 객체의 메소드만 호출\n  파라미터로 받은 객체의 메소드만 호출\n  필드로 참조하는 객체의 메소드만 호출\n1 2 3  member.getExpireDate().getTime() // getExpireDate()가 리턴한 Date 객체의 // getTime() 메소드를 호출했기에 데미테르의 법칙 위반     데미테르의 법칙을 지키지 않는 전형적인 증상\n  연속된 get 메소드 호출\n1  value = object.getA().getB().getValue();     임시 변수의 get 호출이 많음\n1 2 3  A a = object.getA(); B b = a.getB(); value = b.getValue();      두 가지 증상이 보인다면 데미테르의 법칙을 어기고 있을 가능성이 높고, 캡슐화를 약화시켜 코드의 변경을 어렵게 만드는 원인이 된다. 따라서 위 두 증상이 보인다면 확인 후 적극적으로 캡슐화 하도록 노력하자.       참고 : 개발자가 반드시 정복해야할 객체 지향과 디자인 패턴 - 최범균\n  "
},
{
	"uri": "https://ysjune.github.io/posts/javascript/chapter8/bom/",
	"title": "8. 브라우저 객체 모델",
	"tags": [],
	"categories": [],
	"series": ["자바스크립트 프로그래밍"],
	"description": "",
	"content": "다루는 내용  BOM 의 핵심인 window 객체에 대한 이해 창과 프레임, 팝업 컨트롤 location 객체에서 얻는 페이지 정보 navigator 객체를 통한 브라우저 이해  1. window 객체   웹페이지에서 정의한 모든 객체, 변수, 함수에서는 window 가 Global 객체 구실을 함\n1 2 3 4 5 6 7 8  var age = 29; function sayAge() { console.log(this.age); } console.log(window.age); // 29 sayAge(); // 29 window.sayAge(); // 29     var 연산자를 써서 window에 추가한 프로퍼티는 [[Configurable]] 속성이 false 로 지정되기에 delete 를 통해 삭제 불가능\n  페이지에 프레임이 들어있으면 각 프레임은 독자적인 window 객체를 가지며 이 객체들은 frames 컬렉션에 저장됨\n parent 객체는 항상 현재 프레임의 바로 상위인 부모 프레임 프레임을 사용하면 브라우저에 Global 객체가 여럿 존재하며, 각 프레임의 전역 변수는 해당 프레임의 전역 변수    moveTo() / moveBy() 는 최상위 창에서만 동작하며, 기본적으로 비활성화 되어 있음\n1 2  window.moveTo(100,100); // 창을 100,100 위치로 옮김 window.moveBy(0,100); // 창을 아래로 100 만큼 옮김     resizeTo() / resizeBy()\n1 2  window.resizeTo(100,100); // 창 크기를 100 x 100 으로 window.resizeBy(100,50); // 창의 크기를 200 x 150 으로     window.open() 메소드는 URL 로 이동한 후 브라우저 창을 새로 띄움\n1 2 3 4 5 6 7  //\u0026lt;a href=\u0026#34;http://ysjune.github.io\u0026#34; target=\u0026#34;blank\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; window.open(\u0026#34;http://ysjune.github.io\u0026#34;, \u0026#34;blank\u0026#34;); var popup = window.open(\u0026#34;http://ysjune.github.io\u0026#34;,\u0026#34;popup\u0026#34;, \u0026#34;height=400, width=400, top=10, left=10, resizable=yes\u0026#34;); // 400x400 크기에 가로 세로 10 픽셀 씩 떨어져 있으며, 크기 조절 가능  popup.close(); // 팝업 창은 close() 메소드를 통해 닫을 수 있음     팝업 창에는 자신을 연 창(parent) 에 대한 포인터는 존재하지만, 그 역은 존재하지 않음\n  브라우저에서 자바스크립트는 단일 스레드로 실행되지만, 타임 아웃과 인터벌을 통해 코드가 특정 시간에 실행되게끔 조절할 수 있음\n  타임 아웃 : 일정 시간 뒤에 코드를 실행\n1 2 3  setTimeout(function() { console.log(\u0026#34;Hey\u0026#34;); }, 1000);     인터벌 : 페이지가 종료되거나 인터벌을 취소하기 전까지 일정한 시간마다 코드를 실행\n1 2 3  setInterval(function() { console.log(\u0026#34;Hey\u0026#34;); }, 1000)       자바스크립트는 단일 스레드이므로 한 번에 한 가지 코드만 실행가능, 즉 큐를 이용해 코드의 실행을 관리\n  인터벌 사이의 시간을 정확히 보장하기 어렵고, 이따금 일부 인터벌을 건너 뛰기도 해서 실무에서는 잘 사용하지 않는다. 기능을 쓴다면, 아래처럼 setTimeout 을 사용\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  var num = 0; var max = 10; function incrementNum() { num++; if(num \u0026lt; max) { setTimeout(incrementNum, 500); } else { alert(\u0026#34;Done\u0026#34;); } } setTimeout(incrementNum, 500);     시스템 대화 상자\n alert : 확인 창 confirm : yes/no prompt : 입력 파라미터를 받는 창    2. location 객체   현재 창에 불러온 문서 정보와 함께 일반적인 내비게이션 기능을 제공\n  window.location == document.location\n  URL을 파싱해서 정보를 가지고 있음\n hash : \u0026ldquo;#posts\u0026rdquo; - url 해쉬 host : \u0026ldquo;ysjune.github.io:80\u0026rdquo; - 서버 이름과 포트번호 search : \u0026ldquo;?name=snack\u0026rdquo; - URL 쿼리 스트링 등등    쿼리 스트링의 매개변수는 대개 인코드되어 있으므로 decodeURIComponent()로 디코드 하여 사용\n  location 을 사용하여 페이지 이동\n1 2 3 4 5 6 7  location.assign(\u0026#34;http://ysjune.github.io\u0026#34;); == window.location = \u0026#34;http://ysjune.github.io\u0026#34;; == location.href = \u0026#34;http://ysjune.github.io\u0026#34;; // URL 값을 지정하면 assign() 메소드를 호출한 것과 같음     현재 페이지를 다시 불러오는 메소드는 reload()\n1 2  location.reload(); // 가능하면 캐시 location.reload(true); // 항상 서버에서     3. navigator 객체  일반적으로 웹 페이지를 실행 중인 브라우저 타입을 판단하는 데 사용 plugins 배열에서 플러그인 정보를 얻을 수 있음  name - 플러그인 이름 description - 플러그인 설명 filename - 플러그인 파일 이름 length - 플러그인이 처리하는 마임 타입 숫자    4. screen 객체  픽셀 너비와 높이 등 클라이언트 화면에 관한 정보  5. history 객체   창을 첫 번째 연 이후 사용자의 내비게이션 히스토리를 보관\n1 2 3 4 5 6 7  history.go(-1); // 한 페이지 뒤로  history.go(1); // 한 페이지 앞으로  history.back(); // 한 페이지 뒤로  history.forward(); // 한 페이지 앞으로     "
},
{
	"uri": "https://ysjune.github.io/posts/java/caffeine/",
	"title": "Caffeine(캐시 라이브러리) 사용",
	"tags": [],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "이번에 회사에서 학습기에 들어가는 화면에 대한 관리를 하는데,\n자주 바뀌는 사항이 아니다보니, 캐쉬를 적용하자는 말이 나왔다.\n캐시라고 하면 레디스(redis) 를 생각했었는데, caffeine 이라는 것이 나와서, 적용해볼겸 정리해보려고 한다 .\n1. Caffeine  Java 8을 기반으로 하는 High Performance 캐싱 라이브러리 빈도 및 최근 데이터에 따라 사이즈가 넘어갈 경우 eviction(방출?) 최근 접근 or 쓰기 에 따라 만료 시간 설정 비동기적으로 refresh 가능 key, values 가 자동적으로 weak reference 로 wrap cache access 에 대한 statistics 제공  등등.. 이 있다.\n2. 사용   우선, maven 을 사용하므로 pom.xml 에 추가\n1 2 3 4 5  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.ben-manes.caffeine\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;caffeine\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.8.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;     서비스 로직 수정\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  @Service public class DataProvider { private final DataRepository dataRepository; private LoadingCache\u0026lt;String, DataVO\u0026gt; cache; private final String CACHE_KEY = \u0026#34;data\u0026#34;; @Autowired public DataProvider(DataRepository dataRepository) { this.dataRepository = dataRepository; cache = createCache(); } @NonNull private LoadingCache\u0026lt;String, DataVO\u0026gt; createCache() { return Caffeine.newBuilder() .maximumSize(10) // max size  .expireAfterWrite(30, TimeUnit.MINUTES) // 쓴 이후로 30분 후 expired  .build(key -\u0026gt; getData(key)); // 지정한 key 값으로 cache 저장  } private LoginUIData getData(final String key) { return dataRepository.findData(); } public LoginUIData getData() { return cache.get(CACHE_KEY); } }     이전에는 getData() 만 단순히 호출 하는 구조였는데 (서비스 레이어라는 이름이 무색할 정도로..), 생성자에 cache 를 추가해 줬다.\n  이전과 같이 컨트롤러에서 getData() 를 호출하면 cache.get 를 통해 캐시가 있으면 캐시에 있는 값을 가져오고, 없으면 DB 에서 불러와서 캐시에 저장 후, 캐시 값을 읽어온다.\n     간단한 용도로 사용할 예정이었기에 간단하게만 사용했지만, 이 밖에 여러 가지 옵션 들이 있으니, wiki 를 보면서 확인해보자  "
},
{
	"uri": "https://ysjune.github.io/posts/java/simplejdbcinsert_problem/",
	"title": "SimpleJdbcInsert 문제",
	"tags": [],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "이전 jdbcTemplate 를 설명하면서 simpleJdbcInsert 에 대한 칭찬(?)을 했었다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  @Override public Long saveLoginUI(final LoginVO loginVO) { KeyHolder keyHolder = new GeneratedKeyHolder(); jdbcTemplate.update(new PreparedStatementCreator() { @Override public PreparedStatement createPreparedStatement(final Connection connection) throws SQLException { PreparedStatement statement = connection.prepareStatement(\u0026#34;insert into login_ui \u0026#34; + \u0026#34;(ui_name, img_path, use_yn, reg_id, reg_dt, reg_ip) \u0026#34; + \u0026#34;values (?,?,?,?,?,?)\u0026#34;, new String[]{\u0026#34;id\u0026#34;}); statement.setString(1, loginVO.getName()); statement.setString(2, loginVO.imgPath()); statement.setString(3, loginVO.isUse() == true ? \u0026#34;Y\u0026#34; : \u0026#34;N\u0026#34;); statement.setLong(4, loginVO.getRegInfo().getId()); statement.setTimestamp(5, Timestamp.valueOf(loginVO.getRegInfo().getDate())); statement.setLong(6, inetConverter.convertToDatabaseColumn(loginUIData.getRegInfo().getIp())); return statement; } }, keyHolder); loginUIData.setId(keyHolder.getKey().longValue()); return loginUIData.getId(); }   이렇게 작성했던 코드를\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  @Override public Long saveLoginUI(final LoginVO loginVO) { SqlParameterSource sqlParameterSource = new MapSqlParameterSource() .addValue(\u0026#34;ui_name\u0026#34;, loginVO.getName()) .addValue(\u0026#34;img_path\u0026#34;, loginVO.getImgPath()) .addValue(\u0026#34;use_yn\u0026#34;, loginVO.isUse() == true ? \u0026#34;Y\u0026#34; : \u0026#34;N\u0026#34;) .addValue(\u0026#34;reg_id\u0026#34;, loginVO.getRegInfo().getId()) .addValue(\u0026#34;reg_dt\u0026#34;, loginVO.getRegInfo().getDate()) .addValue(\u0026#34;reg_ip\u0026#34;, inetConverter.convertToDatabaseColumn(loginVO.getRegInfo().getIp())); Number id = simpleJdbcInsert.executeAndReturnKey(sqlParameterSource); loginUIData.setId(id.longValue()); return loginUIData.getId(); }   이런식으로 간편하게 만들어 줫었으니 말이다.\n테스트 코드에서도 문제 없고, 로컬에서도 잘 동작하길래 개발 서버에 올렸더니\u0026hellip;\n오늘 한 방 먹었다\u0026hellip;\nCaused by: java.sql.SQLException: Out of range value for column 'reg_ip' at row 1 Query is: INSERT INTO login_ui (ui_name, img_path, use_yn, reg_id, reg_dt, reg_ip, upd_id, upd_dt, upd_ip) VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?), parameters ['test','img_path','N',1522 909,'2019-12-09 15:40:04.143',-1218290558,\u0026lt;null\u0026gt;,\u0026lt;null\u0026gt;,\u0026lt;null\u0026gt;] at org.mariadb.jdbc.internal.util.LogQueryTool.exceptionWithQuery(LogQueryTool.java:153) at org.mariadb.jdbc.internal.protocol.AbstractQueryProtocol.executeQuery(AbstractQueryProtocol.java:254) at org.mariadb.jdbc.MariaDbPreparedStatementClient.executeInternal(MariaDbPreparedStatementClient.java:209) ... 85 common frames omitted ?????\nreg_ip 에 왜 -1218290558 라는 값이\u0026hellip;?\nLong 으로 넘어가는 건 확인했다. 그런데 왜 - 값이 나오는걸까?? 하다가 long -\u0026gt; 숫자.. 어? 생각해보니 overflow !!\nip를 DB 에 저장할 때, 그대로 저장하지 않고, inetConvert 를 통해 long 값으로 저장하는데, 로컬에서는 테스트 할 때 127.0.0.1 은 int 로 변경해도 int의 최대 값 범위 안인데, 다른 아이피의 경우 int 의 최대 값을 넘어가기에 overflow 가 발생하여 - 값이 되는 것이었다.\n그렇다면 왜 long 로 설정한 값이 int 로 강제 형변환이 되어 저장이 되었던 걸까?\n그래서 디컴파일을 통해 찾아봤다.\nSimpleJdbcInsert 의 executeAndReturnKey 를 보면\n 컴파일을 통해 DB 컬럼의 데이터 타입을 알아냄 파라미터 값과 insert 할 컬럼 값을 매칭 insert 실행  이런 식으로 진행되는 것 같다. (자세히는 모르겠지만, 확인한 바로는)\n문제는 컴파일 하는 시점에 DB 컬럼 값의 데이터 타입을 가져와서 java.sql.Types 의 값을 맞추는데, Maria DB 타입에는 int 는 있지만, long 은 없다.\n그렇다보니 DB 컬럼에는 int 로 되어 있기에, 컴파일 할 때 reg_ip 가 int value 가 되는 것이고.. 최대 값을 지나가버린 long value 는 overflow 가 나서 그대로 - 값\u0026hellip;\n이 시점에서 내가 취할 수 있는 선택지는 DB 컬럼 값을 바꾸거나, 이전 jdbcTemplate 을 사용하는 것인데 DB 를 함부로 바꿀 순 없고, 소스를 바꾸는 게 리소스 적으로 좋다고 판단하여 소스를 변경하여서 일단락 되었다.\n역시 잘 알고 써야 한다.. ㅋㅋ\n"
},
{
	"uri": "https://ysjune.github.io/posts/javascript/chapter7/function/",
	"title": "7. 함수 표현식",
	"tags": [],
	"categories": [],
	"series": ["자바스크립트 프로그래밍"],
	"description": "",
	"content": "다루는 내용  함수 표현식의 특징 함수와 재귀 클로저를 이용한 고유(프라이빗) 변수  1. 함수 표현식의 특징  함수를 정의하는 방법은 함수 선언과 함수 표현식 2가지가 있음. 함수 선언에서 뚜렷한 특징은 호이스팅(hoisting)이다. 1 2 3 4 5  sayHi(); function sayHi() { console.log(\u0026#34;hi\u0026#34;); } // 함수 선언부를 다른 코드보다 먼저 읽고 실행함    함수 표현식은 일반적인 변수 할당과 거의 비슷하며 함수 이름이 없어 익명 함수로 간주함 1 2 3 4 5  sayHi(); // error var sayHi = function() { console.log(\u0026#34;hi\u0026#34;); } // 다른 표현식과 마찬가지로 호출 하기 전에 할당해야함    함수 표현식은 다른 함수에서 사용할 수 있도록 함수를 반환하는 형태도 가능 1 2 3 4 5 6 7 8 9 10 11 12 13  function compareFunction(propertyName) { return function(object1, object2) { var val1 = object1[propertyName]; var val2 = object2[propertyName]; if(val1 \u0026lt; val2) { return -1; } else if(val1 \u0026gt; val2) { return 1; } else { return 0; } }; }     2. 함수와 재귀 2-1 재귀  함수가 자기 자신을 호출하는 형태 1 2 3 4 5 6 7 8 9 10 11 12  function factorial(num) { if(num \u0026lt;= 1) { return 1; } else { return num * factorial(num-1); } } var anotherFactorial = factorial; factorial = null; console.log(anotherFactorial(4)); // error // factorial 은 null 인데 anotherFactorial 이 factorial()을 실행하려 하기 때문    arguments.callee 를 호출하면 되지만, 이는 스트릭트 모드에서 접근할 수 없기에, 이름 붙은 함수 표현식을 사용 1 2 3 4 5 6 7  var factorial = (function f(num) { if (num \u0026lt;= 1) { return 1; } else { return num * f(num-1); } });     2-2 클로저  다른 함수의 스코프에 있는 변수에 접근 가능한 함수 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  function compareFunction(propertyName) { return function(object1, object2) { var val1 = object1[propertyName]; var val2 = object2[propertyName]; if(val1 \u0026lt; val2) { return -1; } else if(val1 \u0026gt; val2) { return 1; } else { return 0; } }; } var compare = compareFunction(\u0026#34;name\u0026#34;); var result = compare({name : \u0026#34;snack\u0026#34;}, {name : \u0026#34;gray\u0026#34;});     외부 함수가 실행을 마치고 익명 함수를 반환하면 익명 함수의 스코프 체인은 외부 함수의 활성화 객체와 전역 변수 객체를 포함하도록 초기화되므로, 익명 함수는 외부 함수의 변수 전체에 접근 가능 외부 함수가 실행을 마치면 실행 컨텍스트의 스코프 체인은 파괴되지만, 활성화 객체는 익명 함수가 파괴될 때까지 메모리에 남음 compare = null 을 통해 함수에 대한 참조를 사라지게 하여 GC 가 메모리 회수가 가능하게 함    클로저는 외부 스코프를 보관해야 하므로 메모리를 많이 잡아먹는다. 그러므로 남용은 지양 클로저는 항상 외부 함수의 변수에 마지막으로 저장된 값만 알 수 있음 (전체 변수 객체에 대한 참조를 저장하기 때문) 1 2 3 4 5 6 7 8 9 10 11 12  function createdFunction() { var result = new Array(); for(var i = 0; i \u0026lt; 10; i++) { result[i] = function(num) { return function() { return num; }; }(i); } return result; }     변수 i 를 익명함수에 매개변수로 넘김 함수 매개변수는 값 형태로 전달되므로 i의 현재 값을 매개변수 num 에 복사 익명함수는 num 을 간직한 클로저를 생성하여 반환    this 객체는 런타임에서 함수가 실행 중인 컨텍스트에 묶이는데, 익명함수는 특정 객체에 묶여 있지 않으므로 mode == strict mode ? undefined : window 모든 함수는 호출되는 순간 자동으로 this와 arguments 두 특별한 변수를 갖게되는데, 내부 함수는 결코 외부 함수의 this 와 arguments 에 직접적으로 접근이 불가능, 그러므로 다음과 같이 해서 접근 가능 1 2 3 4 5 6 7 8 9 10 11 12 13 14  var name = \u0026#34;the window\u0026#34;; var object = { name : \u0026#34;my object\u0026#34;, getNameFunc : function() { var that = this; return function() { return that.name; }; } }; console.log(object.getNameFunc()()); // my object    블록 레벨 스코프라는 개념이 없기 때문에 익명 함수를 괄호로 감싸서 흉내낼 수 있음 (고유 스코프라고 부르기도 함) 1 2 3 4 5 6 7 8  function outputFunc(count) { (function () { for(var i=0; i \u0026lt; countl i++) { console.log(i); } })(); console.log(i); // error }     전역 스코프에 추가되는 변수나 함수의 수를 제한하는 용도로 자주 사용 (대규모 어플리케이션에선 전역 스코프에 변수나 함수를 추가하지 않는 편이 좋음) 익명 함수에 대한 참조가 존재하지 않아 클로저의 메모리 문제도 덜함     3. 클로저를 이용한 고유(프라이빗) 변수  자바스크립트에는 private member 이란 개념이 없지만, 고유 변수 라는 개념은 존재 함수 내부에서 정의한 변수는 함수 밖에서 접근할 수 없으므로 모두 고유 변수로 간주 (함수 매개변수, 지역 변수, 내부 함수 등) 다음과 같이 고유 및 특권 맴버를 정의해서 데이터를 직접적으로 수정할 수 없게 보호 가능 1 2 3 4 5 6 7 8 9 10 11 12 13 14  function Person(name) { this.getName = function() { return name; }; this.setName = function(value) { name = value; }; } var person = new Person(\u0026#34;snack\u0026#34;); console.log(person.getName()); // snack person.setName(\u0026#34;gray\u0026#34;); console.log(person.getName()); // gray    생성자 패턴에는 인스턴스가 매번 생성되므로, 이를 방지하기 위해 정적 고유 변수를 사용 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  (function() { // 고유 변수와 함수  var name = \u0026#34;\u0026#34;; function privateFunction() { return false; } //생성자  Person = function(value) { name = value }; // 공용 메소드와 특권 메소드  Person.prototype.getName = function() { return name; }; Person.prototype.setName = function(value) { name = value; }; })(); var person1 = new Person(\u0026#34;snack\u0026#34;); console.log(person1.getName()); // snack person1.setName(\u0026#34;gray\u0026#34;); console.log(person1.getName()); // gray  var person2 = new Person(\u0026#34;john\u0026#34;); console.log(person1.getName()); // john console.log(person2.getName()); // john     각 인스턴스가 독립 변수를 가질 수는 없지만, 프로토타입을 통해 코드 재사용성은 좋아짐    싱글톤 같은 일을 하는 모듈 패턴이 있음 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  var application = function() { //고유 변수와 함수  var components = new Array(); //초기화  components.push(new BaseComponent()); //공용 인터페이스  return { getComponentCount : function() { return components.length; }, registerComponent : function(component) { if(typeof component == \u0026#34;object\u0026#34;) { components.push(component); } } }; }();     애플리케이션 레벨의 정보를 관리할 싱글톤을 두는 경우가 많음 하나의 객체를 반드시 생성하고 몇 가지 데이터를 가지며 또한 고유 데이터에 접근 가능한 공용 메소드를 외부에 노출하도록 초기화해야 할 때 유용    싱글톤 객체가 특정 타입의 인스턴스지만 프로퍼티나 메서드를 추가하여 확장해야 할 때 모듈 확장 패턴 을 사용 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  var application = function() { //고유 변수와 함수  var componens = new Array(); //초기화  components.push(new BaseComponent()); //애플리케이션 인스턴스 생성  var app = new BaseComponent(); //공용 인터페이스  app.getComponentCount = function() { return components.length; } app.registerComponent = function(component) { if(typeof component == \u0026#34;object\u0026#34;) { components.push(component); } }; return app; }();    app 은 application 객체의 로컬 버전\n   "
},
{
	"uri": "https://ysjune.github.io/posts/javascript/chapter2/chapter2/",
	"title": "2. HTML 속의 자바스크립트",
	"tags": [],
	"categories": [],
	"series": ["자바스크립트 프로그래밍"],
	"description": "",
	"content": "다루는 내용  \u0026lt;script\u0026gt; 요소 사용 인라인 스크립트와 외부 스크립트의 비교 문서 모드가 자바스크립트에 미치는 영향 자바스크립트가 비활성화된 상황에 대한 대비  1. \u0026lt;Script\u0026gt; 요소 여섯가지의 속성이 있다.\n async  비동기 옵션으로 스크립트를 받지만, 페이지 로딩은 방해하지 않음. 외부 스크립트를 불러올 때만 유효   charset  코드의 문자셋 지정 (자주 사용X)   defer  문서의 콘텐츠를 완전히 표시할 때까지 스크립트 실행을 지연해도 OK, 외부 스크립트를 불러올 때만 유효   language  Deprecated   src  외부 파일 위치 지정  1  \u0026lt;script src=\u0026#34;example.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;      type  language 대체, 콘텐츠 타입(마임 타입) 지정 application/javascript, text/javascript(생략가능, default값)  1 2  \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; function blah() {}         코드를 가져온 방법과 관계 없이 코드는 위에서 아래로 순차적으로 해석되며, 예외는 defer 과 async 속성이 있을 때 뿐이다.\n 자바스크립트 파일은 보통 *.js 라는 확장자를 붙이지만, 브라우저는 js 파일을 불러올 때 확장자를 확인하지 않기 때문에 필수는 아니다.\n하지만 서버에서 종종 파일 확장자를 기준으로 응답에 쓸 마임 타입을 결정하는 경우도 있으므로 염두해 둬야 함\n   \u0026lt;script\u0026gt; 와 \u0026lt;/script\u0026gt; 사이에 스크립트 코드가 있고 src 속성을 사용하고 있다면 인라인 코드는 무시됨\n  일반적으로 자바스크립트 코드를 모두  요소 안에 페이지 콘텐츠 마지막에 쓰는데, 자바스크립트 파일을 전부  요소에서 불러온다면\n전부 받고, 파싱하고, 해석이 끝날 때까지 페이지 랜더링이 멈추기 때문임 (페이지 렌더링이 지연되면 흰 화면만 보임)\n  1 2 3 4 5 6 7 8 9  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt; title \u0026lt;title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!--contents --\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;example1.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;     defer 속성을 설정하면 해당 요소를 만나는 즉시 코드를 내려받지만 실행은 지연한다.\n외부 스크립트를 불러올 때만 유효하며, 인라인 스크립트의 defer 속성은 무시한다.\n  async 속성은 defer 와 같이 외부스크립트에만 적용된다는 점은 비슷하나, 스크립트가 순차적으로 실행된다는 보장이 없다.\n비동기는 페이지의 load 이벤트 전에는 실행되지만, DOM ContentLoaded 이벤트보다 반드시 앞선다는 보장이 없으므로 (비동기니까) DOM 을 조작하는 스크립트는 async 으로 불러오지 않는 편이 좋음\n   2.인라인 코드와 외부 파일  가능한 자바스크립트는 외부 파일로 분리하는게 좋음  괸리 용이 캐싱되어 빠른 로딩속도     3.문서 모드  퀵스모드 표준모드   4. 요소  브라우저가 스크립트 미지원  1 2 3 4 5 6 7 8 9 10 11  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt; title \u0026lt;/title\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;example.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;noscript\u0026gt; \u0026lt;a\u0026gt;not support\u0026lt;/a\u0026gt; \u0026lt;/noscript\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;    생각해볼 점  script 옵션에 대해서 알게되었다. 이전에는 src와 type 밖에 몰랐는데, async 와 defer 에 대해서 알게되었다.\nasync 는 자바에서도 익숙하므로 비동기라 생각하면 되겠고, defer 는 promise 에 나오는 deferred 와 관련이 있으려나? (추후 공부하면서 알아보는 걸로)\n또한 type 의 text/javscript는 기본값이라 적지 않아도 된다는 사실은 깨알팁 ~async 와 defer 는 상당히 헷갈리는 개념(?) 인 것 같다. 둘 다 외부스크립트를 불러올 때만 유효하며, 당장 실행하지 않는다.\n실제로 책의 내용을 보면 async 와 defer 는 async 가 실행순서를 보장하지 않는다 라는 차이점을 들어 설명하는데\ndefer 쪽의 설명을 보면 하지만 현실에서는 defer 속성으로 지연시킨 스크립트가 항상 순서대로 실행되지는 않으며... 라고 하는데\u0026hellip;?~\n구글링을 통해 알게되었다! 실행시점에 차이가 있다 xhtml 에 대한 내용은 그냥 읽어보고 지나갔는데, 많은 브라우저가 아직은 비호환이라는 말과 실제로도 많이 본 적이 없기에\u0026hellip;?  "
},
{
	"uri": "https://ysjune.github.io/posts/javascript/chapter3/basic_of_language/",
	"title": "3. 언어의 기초",
	"tags": [],
	"categories": [],
	"series": ["자바스크립트 프로그래밍"],
	"description": "",
	"content": "다루는 내용  문법 데이터 타입 제어문 함수  1. 문법  대소문자를 구분 식별자 -\u0026gt; 변수, 함수, 프로퍼티, 함수 매개변수의 이름으로 관습적으로 카멜 케이스를 사용  camelCase\n  스트릭트 모드 (엄격하게 체크하는? 것으로 자바스크림트가 실행되는 방식이 매우 많이 바뀜)  \u0026lsquo;use strict\u0026rsquo;\n  문장 마지막에 세미콜론을 꼭 써야 하는 건 아니지만, 세미콜론을 쓰길 권장 제어문에서 문장 하나만 실행하더라도 항상 코드 블록을 쓰길 권장  1 2 3  if(test) { console.log(test); }    키워드 : 특정 조작 목적 (ex. break, case etc) 예약어 : 키워드로 쓸 가능성이 있음 (ex. abstract, enum etc) 키워드와 예약어는 식별자든 프로퍼티 이름에든 쓰지 않는 편이 과거와 미래 버전 호환에 좋음  2. 데이터 타입  느슨한 변수 타입을 사용하기에 var 을 사용 var 연산자는 변수를 로컬 스코프에서 정의함 (var 사용을 하지 않을 경우 전역이 되는데 관리 및 의도 파악이 어려우므로 지양\n스트릭트 모드에서는 ReferenceError) 기본적인(primitive) 타입이 존재 : Undefined, Null, Boolean, 숫자, 문자열 과 key-value 쌍의 객체 타입이 존재 변수를 초기화하지 않으면 자동으로 undefined 가 되지만, 변수는 항상 초기화를 권장 null 은 빈 객체를 가리키는 포인터, 즉 null 에 typeof 를 하면 object 반환 null == undefined \u0026ndash;\u0026gt; true ( == 연산자가 암시적으로 타입 변환하기 때문) Boolean 은 true/false 만 갖는데, true는 1 이 아니며 false 는 0 이 아님 숫자를 0으로 나눌 경우 NaN을 반환  2-1. 객체 타입의 프로퍼티와 메소드  constructor - 객체 생성자 hasOwnProperty(propertyName) - 해당 프로퍼티를 객체가 가지고 있는지 (고유, 상속x) isPrototpyeOf(object) - 해당 객체가 다른 객체의 프로토 타입인지 확인 propertyIsEnumerable(propertyName) - 해당 프로퍼티를 반복문에서 사용할 수 있는지 toString() - 객체를 문자열로 반환 valueOf() - 객체를 나타내는 타입을 반환(숫자, 문자 등)  2-2. 연산자  덧셈연산에서 피연산자 중 하나가 문자열이라면 다른 피연산자를 문자열로 변환하고 두 문자열을 합침  1 2  var result = 5 + \u0026#34;25\u0026#34;; console.log(result) // \u0026#34;525\u0026#34;    관계연산에서 피연산자가 모두 문자열이라면 문자열의 코드(아스키 코드) 를 비교  1 2  var result = \u0026#34;Banana\u0026#34; \u0026lt; \u0026#34;apple\u0026#34; // true // 아스키코드에서 \u0026#34;B\u0026#34;는 66, \u0026#34;a\u0026#34; 는 97    NaN은 무엇과 비교해도 다 false (심지어 NaN 과 비교해도\u0026hellip;) == 는 값이 일치하면 true , === 는 값, 타입 다 일치해야 true  3. 제어문  if문 (조건문)  1 2 3 4 5  if(condition) { statement1 } else { statement2 }   while문 (반복문)  1 2 3  while(condition) { statement } // 조건이 만족하면 계속 실행   do-while문 while 을 실행하기 전에 한 번은 실행  1 2 3 4  var i = 0; do { i = i+2 } while(i\u0026lt;10);   for문 while 과 비슷한 반복문  1 2 3 4  for(var i=0; i\u0026lt;10; i++) { // 초기식;조건식;증감문 statement }   for-in문 객체의 프로퍼티를 나열하는 반복문  1 2 3  for(var i in arrays) { console.log(i) // arrays 에 있는 프로퍼티들을 출력(순서 무관) }   break, continue 문 반복문을 빠져나가거나 (break) 반복문을 한 번 넘기거나(continue) 하며 제어  1 2 3 4 5 6 7 8 9 10  for(var i=0; i\u0026lt;10; i++) { // for1  if(i==4) { continue; // i가 4가 되면 for2를 실행하지 않고 i를 5로 넘김  } for(var j=0;j\u0026lt;10;j++) { // for2  if(j==3) { break; // j가 3이 되면 for2 를 종료  } } }   switch 문  1 2 3 4 5 6  switch(condition) { case value : statement break; default : statement } // condition 과 case 의 value 가 일치하면 statement 실행 혹은 출력   4. 함수  함수는 function 키워드로 정의 그 뒤에 매개변수와 함수 본문을 순서대로 씀  1 2 3  function example(args0 ... argsN) { statments }    함수에서 매개변수를 2개 받도록 만들었어도, 꼭 2개 넘겨야 하는 건 아님 (매개변수가 일종의 배열처럼 들어가기 때문) 첫 번째 매개변수를 arguments[0] 으로 받을 수도 있음. value1 로 받은 매개변수와 arguments[0] 의 값은 같아도, 다른 메모리 공간을 사용함. -\u0026gt; 즉 two-way 바인딩이 아니라 단방향 반영  value1 의 값을 바꾸더라도 arguments[0] 의 값은 바뀌지 않음\n  함수 시그너처(매개변수의 타입과 개수)가 없기에 오버로딩이 불가능\n(매개변수가 내부적으로 배열로 표현되기에 어떻게 보면 당연한 결과\u0026hellip;)   생각해볼 점  꽤 길고 많은 내용이 들어있지만 컴퓨터 관련 전공을 들었거나, 다른 언어를 알고 있다면 아, 그렇구나 하고 쭉 훑어보면서 차이점을 알아가는(?) 정도인 것 같다. 기초(base)는 아무리 강조해도 지나치지 않듯이 어떻게 보면 가장 중요한 부분인 것 같다.\n(실제로 이정도만 알아도 코드를 짜긴 힘들어도 어느정도 읽을 순 있지 않을까?) js 코드는 많이 접할 기회가 없는데, 스트릭트 모드를 얼마나 많이 쓰는 진 잘 모르겠다 (es6 와 타입스크립트인 요즘 추세에)  "
},
{
	"uri": "https://ysjune.github.io/posts/javascript/chapter4/variable_scope_memory/",
	"title": "4. 변수, 스코프, 메모리",
	"tags": [],
	"categories": [],
	"series": ["자바스크립트 프로그래밍"],
	"description": "",
	"content": "다루는 내용  변수의 원시값과 참조값 실행 컨텍스트의 이해 가비지 컬렉션의 이해  1. 원시값과 참조값  원시값은 기본타입(문자열, null, undefined etc), 참조값은 메모리에 저장된 객체(객체의 프로퍼티) 대부분의 언어에서는 문자열을 참조값으로 침 (Ex. Java String) 참조값의 경우 동적 프로퍼티가 가능 (원시값은 불가) 1 2 3 4 5 6 7 8 9  1) 참조값 var person = new Object(); person.name = \u0026#34;snack\u0026#34;; console.log(person.name); // snack  2) 원시값 var name = \u0026#34;snack\u0026#34;; name.age = 29; console.log(name.age); // undefined    값을 복사할 경우에도 원시값과 참조값은 서로 다름 1 2 3 4 5 6 7 8 9 10 11 12 13  1) 원시값 // 값이 각각 다른 곳에 저장 var num1 = 1; var num2 = num1; num1 = 10; console.log(num1); // 10 console.log(num2); // 1  2) 참조값 // 힙에 저장된 레퍼런스를 가리키기 때문 var obj1 = new Object(); var obj2 = obj1; obj1.name = \u0026#34;snack\u0026#34;; console.log(obj2); // snack    매개변수는 모두 값으로 전달됨 1 2 3 4 5 6 7 8 9 10 11 12 13 14  function setName(obj) { obj.name = \u0026#34;snack\u0026#34;; obj = new Object(); obj.name = \u0026#34;Gray\u0026#34;; } var person = new Object(); setName(person); console.log(person.name); // sanck  /* * setName() 의 매개변수인 obj 가 전역변수인 person 을 가리키기 때문에 반영이 됨 * obj 가 값이 아니라 참조로 전달되었다면, console.log 가 Gray 가 나왔을 것 */    원시 타입에서는 typeof 참조 타입에서는 instanceof  2. 실행 컨텍스트와 스코프  변수나 함수의 실행 컨텍스트는 다른 데이터에 접근할 수 있는지, 어떻게 행동하는지를 규정 이 코드 하나로 실행 컨텍스트가 대강 설명이 될 거 같다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  var color = \u0026#34;blue\u0026#34;; function changeColor() { var anotherColor = \u0026#34;red\u0026#34;; function swapColors() { var tempColor = anotherColor; anotherColor = color; color = tempColor; // swapColors 내부에서는 color, anotherColor, tempColor 전부 접근 가능  } // changeColor 내부에서는 color, anotherColor 만 접근 가능  swapColors(); } // color 만 접근 가능 changeColor();    블록 레벨 스코프가 없기에 if, for 같은 제어문은 조심 1 2 3 4 5  if(true) { var ex1 = \u0026#34;good\u0026#34;; } console.log(ex1); // good;      for(var i=0; i \u0026lt; 10; i++) { doSomething(i); }\nconsole.log(i); // 10\n- 식별자 검색은 로컬 컨텍스트에서 점점 범위를 넓혀 전역 컨텍스트까지 찾고, 정의되어 있지 않으면 undefined ```javascript var color = \u0026quot;green\u0026quot; function getColor() { var color = \u0026quot;dark\u0026quot;; return color; } console.log(getColor()); // dark // green 을 불러오고 싶다면 window.color 3. 가비지 콜렉션  필요한 메모리를 자동으로 할당하고 사용하지 않는 메모리는 자동으로 회수 가능한한 최소한의 메모리를 사용해야 페이지 성능을 올릴 수 있으므로 참조가 끝나 필요없어진 데이터는 null 을 할당해 참조를 제거 하는 게 좋음  3.1 표시하고 지우기  가장 널리 쓰이는 방법 변수 전체에 표시를 남기고, 컨텍스트에 있는 변수, 컨텍스트가 참조하는 변수등에 대해 표시를 지움. 이후 표시가 남아있는 변수 삭제 후 메모리 회수  3.2 참조 카운팅  각 값이 얼마나 많이 참조되었는지를 카운팅 참조할 경우 카운팅 증가, 참조 변수에 다른 값을 할당하면 카운팅 감소 상호 참조, 순환 참조의 경우 카운팅이 감소되지 않아 메모리 회수가 안되는 문제가 있을 수도 있음   생각해볼 점  내용은 짧지만, 다루고 있는 내용은 짧다는 느낌이 안 듦 힙, 스택 메모리 영역에 대한 이해가 다시금 필요할 것 같음  "
},
{
	"uri": "https://ysjune.github.io/posts/javascript/chapter5/reference_type/",
	"title": "5. 참조 타입",
	"tags": [],
	"categories": [],
	"series": ["자바스크립트 프로그래밍"],
	"description": "",
	"content": "다루는 내용  객체로 작업하기 배열 생성하고 조작하기 자바스크립트의 데이터 타입 이해 원시 데이터 및 원시 래퍼로 작업하기  1. 객체로 작업하기  객체란 참조 타입이며 클래스와는 다르다.  1-1. Object 타입  가장 많이 사용하는 타입으로 new 연산자 혹은 객체 리터럴로 생성할 수 있다.  1 2 3 4  1) var person = new Person(); 2) var person = {};    객체 리터럴 표기법을 사용하면 Object 생성자를 호출하지 않으며, 프로퍼티가 여러개 일 때 가독성을 위해 사용하길 권함.  1-2. Array 타입  배열의 크기는 동적으로 할당되며, 배열 element 에 어떤 데이터 타입도 가능 Object 와 비슷하게 new 연산자 혹은 배열 리터럴로 생성 가능  1 2 3 4 5  1) var colors1 = new Array(20); var colors2 = new Array(\u0026#34;green\u0026#34;, \u0026#34;dark\u0026#34;); 2) var color = [\u0026#34;red\u0026#34;, \u0026#34;blue\u0026#34;];    Array.isArray(value) 를 통해 배열을 판단할 수 있음 join() 을 통해 배열을 문자열로 나타낼 수 있음  1 2  var color = [\u0026#34;red\u0026#34;, \u0026#34;green\u0026#34;, \u0026#34;black\u0026#34;]; console.log(color.join(\u0026#34;,\u0026#34;)); // red,green,black    push() 와 pop() 을 통해 LIFO 인 스택 처럼 동작이 가능 배열 순서를 조작하는 매서드는 sort(), reverse() 가 있음.  1 2 3 4 5 6 7  var values = [1,3,2,4]; console.log(values.reverse()); // 4,2,3,1 - 단순 순서 조작 console.log(values.sort()); // 1,2,3,4  // sort 의 경우 var val = [1,5,10]; val.sort() // 1,10,5 - 문자열로 비교한 결과가 나오므로 보통 비교함수를 넘겨서 처리함    concat() 의 경우 현재 배열 데이터를 기반으로 매개변수를 더한 새로운 배열을 생성 slice() 의 경우 데이터의 일부를 가진 새 배열을 생성 splice() 의 경우 중간에 데이터를 삽입하고자 할 때 사용하며 삭제한 데이터의 배열을 반환함  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  var sliceNumber = [1,2,3,4,5,6] sliceNumber(1); // 2,3,4,5,6 sliceNumber(1,4); // 2,3,4  --------------------------------- var color = [\u0026#34;red\u0026#34;, \u0026#34;blue\u0026#34;]; var removed = color.splice(0,1); color // blue removed // red  removed = color.splice(1,0,\u0026#34;yellow\u0026#34;); color // blue, yellow remove // \u0026#34;\u0026#34;  removed = color.splice(1,1,\u0026#34;green\u0026#34;) color // blue, green removed // yellow    위치를 검색할 때는 indexOf() 와 lastIndexOf() 가 있으며, 2개의 매개변수 (검색할 데이터, 검색을 시작할 인덱스) 이다. 반복 메소드로는 every(), filter(), forEach(), map(), some() 5가지가 있음  every : 배열의 모든 데이터가 true 면 true 반환 filter : 반환값이 true 인 것만 새 배열에 저장하여 반환 forEach : for 문과 같으며 반환값이 없음 map : forEach 와 비슷하지만, 결과를 반환함 some : 배열의 반환 값 중 하나라도 true 면 true 반환   감소메소드 reduce(), reduceRight() 가 있으며, 배열을 모두 순회하며 값을 하나 만들어 반환  1-3 Date 타입 1 2  var now = new Date(); var someDate = new Date(\u0026#34;November 11, 2019\u0026#34;);   1-4 RegExp 타입  정규표현식  1  var expression = /pattern/flags;    g : 전역모드, i : 대소문자 비구분, m : 여러줄 모드  1 2 3 4 5 6  var pattern1 = /[bc]at/i; var pattern2 = new RegExp(\u0026#34;[bc]at\u0026#34;, \u0026#34;i\u0026#34;); // pattern1과 pattern2 는 같은 표현  var text = \u0026#34;Cat is bat\u0026#34; pattern1.test(text) // 정규표현식 테스트   1-5 Function 타입  함수는 사실 객체이다. (함수 이름은 단순히 함수 객체를 가리키는 포인터일 뿐)  1 2 3  var sum = function(num1, num2) { return num1 + num2; }    함수 선언과 함수 표현식은 약간 차이점이 있는데, 함수 선언은 불러오기 전에 실행이 가능하고, 함수 표현식은 해당 코드가 실행이 되야 사용할 수 있다. 이는 호이스팅 때문  1 2 3 4 5 6 7 8 9 10  sum(10,10) // 정상 function sum(num1, num2) { return num1 + num2; } ----------------------------- sum(10,10) // error var sum = function(num1, num2) { return num1 + num2; }    함수 이름은 단순히 객체일 뿐이므로, 다른 함수의 매개변수로 가능  1 2 3 4 5 6 7 8 9  function callSomeFunction(someFunction, someArg) { return someFUnction(someArg); } function add10(num) { return num + 10; } var ret = callSomeFunction(add10, 10); // ret = 20    this는 함수가 실행 중인 컨텍스트 객체에 대한 참조이며, call apply, bind 에 대한 내용은 따로 정리  1-6 원시 래퍼 타입  Boolean, Number, String 이 있으며 각 원시타입에 대응 읽기 모드로 접근할 때 원시 래퍼 객체의 인스턴스가 만들어지며, 이를 통해 데이터 조작 래퍼 객체는 원시 값을 조작하는 문장이 실행되는 즉시 파괴  1-7 내장된 싱글톤 객체  Global, window, Math Global 객체는 모든 전역 변수와 함수를 프로퍼티 형태로 포함하며, 접근할 수 있는 방법이 없기에 웹브라우저에서는 window 를 통해 가능  "
},
{
	"uri": "https://ysjune.github.io/posts/javascript/chapter6/object_oriented/",
	"title": "6. 객체 지향 프로그래밍",
	"tags": [],
	"categories": [],
	"series": ["자바스크립트 프로그래밍"],
	"description": "",
	"content": "다루는 내용  객체 프로퍼티의 이해 객체의 이해와 생성 상속의 이해  1. 객체 프로퍼티의 이해  객체는 특별한 순서가 없는 값의 배열 (key-value 쌍의 그룹) 가장 단순한 방법은 1 2 3 4 5 6 7 8 9 10 11 12  var person = new Object(); person.name = \u0026#34;snack\u0026#34;; person.sayName = function() { console.log(this.name) }; var person = { name : \u0026#39;snack\u0026#39;, sayName: function() { console.log(this.name); } };    프로퍼티에는 데이터 프로퍼티와 접근자 프로퍼티 두 가지가 있음. 데이터 프로퍼티에는   [[Configurable]] - 프로퍼티의 속성을 바꾸거나 접근자 프로퍼티로 변환할 수 있음을 의미 (default : true) [[Enumerable]] - for-in 루프에서 해당 프로퍼티를 반환함을 나타냄 (default : true) [[Writable]] - 프로퍼티의 값을 바꿀 수 있음을 나타냄 (default : true) [[Value]] - 프로퍼티의 실제 데이터 값을 포함 (default : undefined)   1 2 3 4 5 6 7 8 9  var person = {}; Object.defineProperty(person, \u0026#34;name\u0026#34;, { writable: false, value: \u0026#34;snack\u0026#34; }); console.log(person.name); // snack person.name = \u0026#34;gray\u0026#34;; console.log(person.name); // snack    접근자 프로퍼티는   [[Configurable]] - 프로퍼티의 속성을 바꾸거나 데이터 프로퍼티로 변환할 수 있음 [[Enumerable]] - for-in 루프에서 해당 프로퍼티를 반환함을 나타냄 [[Get]] - 프로퍼티를 읽을 때 호출 (default : undefined) [[Set]] - 프로퍼티를 바꿀 때 호출 (default : undefined)   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  var book = { _year : 2004, edition : 1 }; Object.defineProperty(book, \u0026#34;year\u0026#34;, { get: function() { return this._year; }, set: function(newValue) { if(newValue \u0026gt; 2004) { this._year = newValue; this.edition = this.edition + newValue - 2004; } } }); book.year = 2005; console.log(book.edition); // 2    다중 프로퍼티를 사용할 경우에는 Object.defineProperties() 를 사용 각 프로퍼티의 속성값을 알고 싶은 경우 Object.getOwnPropertyDescription() 을 사용  2. 객체의 이해와 생성  팩토리 패턴 : 특정 객체를 생성하는 과정을 추상화 하는 것 1 2 3 4 5 6 7 8 9 10  function createPerson(name) { var o = new Object(); o.name = name; return o; } var person1 = createPerson(\u0026#39;snack\u0026#39;); var person2 = createPerson(\u0026#39;gray\u0026#39;); // 코드의 중복은 해결했으나, 객체가 어떤 타입인지는 알 수 없음    생성자 패턴 1 2 3 4 5 6  function Person(name) { this.name = name; } var person1 = new Person(\u0026#39;snack\u0026#39;); var person2 = new Person(\u0026#39;gray\u0026#39;);    생성자 패턴의 주요 문제는 인스턴스마다 메소드가 생성된다는 점 (함수 이름이 같아도 인스턴스가 다르면 다른 함수로 취급) 프로토 타입 패턴 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  function Person() { } Person.prototype.name = \u0026#34;snack\u0026#34;; Person.prototype.sayName = function() { console.log(this.name); } var person1 = new Person(); person1.sayName(); // snack  var person2 = new Person(); person2.sayName(); // snack  console.log(person1.sayName == person2.sayName); // true    프로토타입 프로퍼티와 같은 이름의 프로퍼티를 인스턴스에 추가하면 인스턴스에 추가될 뿐 프로토타입까지 올라가지 않음 1 2 3 4 5 6 7 8 9 10 11 12 13 14  function Person() { } Person.prototype.name = \u0026#34;snack\u0026#34;; Person.prototype.sayName = function() { console.log(this.name); } var person1 = new Person(); var person2 = new Person(); person.name = \u0026#34;gray\u0026#34;; console.log(person1.name); // gray - 인스턴스 console.log(person2.name); // snack - 프로토타입    hasOwnProperty() 를 통해 인스턴스의 프로퍼티인지 프로토타입의 프로퍼티인지 확인 가능 프로토 타입은 리터럴로 생성이 가능 1 2 3 4 5 6 7 8 9 10  function Persion() { } Person.prototype = { // constructor : Person - 생성자 타입이 중요하다면 명시적으로 설정 가능  name : \u0026#34;snack\u0026#34;, sayName: function() { console.log(this.name); } };    인스턴스는 프로토타입을 가리키는 포인터를 가질 뿐 생성자와 연결된 것은 아니기에, 프로토타입을 다른 객체로 바꾸면 연결이 깨짐 네이티브 타입(Object, Array 등)의 메서드 역시 생성자의 프로토타입에 정의 (ex:Array.prototype.sort) 프로토 타입에 존재하는 프로퍼티는 모두 인스턴스에 공유되는데, 참조 값을 포함하게 될 경우 문제가 생김 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  function Person() { } Person.prototype = { constrouctor : Person, name: \u0026#34;snack\u0026#34;, friends : [\u0026#34;gray\u0026#34;, \u0026#34;berry\u0026#34;] } var person1 = new Person(); var person2 = new Person(); person1.friends.push(\u0026#34;cheese\u0026#34;); console.log(person1.friends); // \u0026#34;gray,berry,cheese\u0026#34; console.log(person2.friends); // \u0026#34;gray,berry,cheese\u0026#34;    생성자와 프로토타입 패턴의 장점만 취한 패턴 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  function Person(name) { this.name = name; thus.friends = [\u0026#34;cheese\u0026#34;, \u0026#34;berry\u0026#34;] } Person.prototype = { constructor: Person, sayName: function() { console.log(this.name); } } var person1 = new Person(\u0026#34;snack\u0026#34;); var person2 = new Person(\u0026#34;muz\u0026#34;); person1.friends.push(\u0026#34;cake\u0026#34;); console.log(person1.friends); // cheese, berry, cake console.log(person2.friends); // cheese, berry    프로퍼티에 직접 접근할 수 없게 하는 durable 생성자 패턴이 있음(캡슐화?) 1 2 3 4 5 6 7  function Person(name) { var o = new Object(); o.sayName = function() { console.log(name); }; return o; }     3. 상속의 이해  함수 시그너쳐가 없으므로 인터페이스 상속은 불가능하고, 구현 상속만 지원 (대게 프로토타입 체인) 프로토 타입 체인 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  function SuperType() { this.property = true; } SuperType.prototype.getSuperValue = function() { return this.property; }; function SubType() { this.subproperty = false; } //SuperType 상속 SubType.prototype = new SuperType(); SubType.prototype.getSubValue = function() { return this.subproperty; }; var instance = new SubType(); console.log(instance.getSuperValue()); // true    모든 참조 타입은 기본적으로 프로토 타입 체인을 통해 Object 를 상속 프로토타입 체인 상속 역시 참조값을 포함한 경우 문제가 될 수 있음 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  function SuperType() { this.colors = [\u0026#34;red\u0026#34;,\u0026#34;green\u0026#34;,\u0026#34;blue\u0026#34;]; } function SubType() { } SubType.prototype = new SuperType(); var instance1 = new SubType(); instance1.color.push(\u0026#34;black\u0026#34;); console.log(instance1.colors); // red, green, blue, black  var instance2 = new SubType; console.log(instance2.colors); // red, green, blue, black    참조 값에 얽힌 문제를 해결하고자 \u0026lsquo;constructor stealing\u0026rsquo;(생성자 훔치기) 를 사용 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  function SuperType() { this.colors = [\u0026#34;red\u0026#34;,\u0026#34;green\u0026#34;]; } function SubType() { SuperType.call(this); } var instance1 = new SubType(); instance1.colors.push(\u0026#34;black\u0026#34;); console.log(instance1.colors); // red, green, black  var instance2 = new SubType(); console.log(instance2.colors); // red, green    생성자 훔치기의 경우, 메소드를 생성자 내부에서만 정의해야 하므로 함수 재사용이 불가능. 또한 상위 타입에서 정의된 메소드는 하위 타입에서 접근 불가 프로토 타입 체인과 생성자 훔치기 패턴을 조합한 조합 상속이 있음 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  function SuperType(name) { this.name = name; this.colors = [\u0026#34;red\u0026#34;, \u0026#34;green\u0026#34;]; } SuperType.prototype.sayName = function() { console.log(this.name); } function SubType(name, age) { SuperType.call(this, name); this.age = age; } SubType.prototype = new SuperType(); SubType.prototype.sayAge = function() { console.log(this.age); } var instance1 = new SubType(\u0026#34;snack\u0026#34;, 29); instance1.colors.push(\u0026#34;black\u0026#34;); console.log(instance1.colors); // red, green, black instance1.sayName(); // snack instance1.sayAge(); // 29  var instance2 = new SubType(\u0026#34;gray\u0026#34;, 28); console.log(instance2.colors); // red, green instance2.sayName(); // gray instance2.sayAge(); // 28    프로토 타입 상속 1 2 3 4 5 6 7 8 9 10  var person = { name: \u0026#34;snack\u0026#34; }; var anotherPerson = object(person); anotherPerson.name = \u0026#34;gray\u0026#34; // EcmaScript 5 var anotherPerson2 = Object.create(person); anthoerPerson2.name = \u0026#34;chees\u0026#34;;    기생 상속 1 2 3 4 5 6 7 8 9 10 11 12 13 14  function createAnother(original) { var clone = object(original); clone.sayHi = function() { console.log(\u0026#34;hi\u0026#34;); }; return clone; } var person = { name : \u0026#34;snack\u0026#34; }; var anotherPerson = createAnother(person); anotherPerson.sayHi(); // hi    조합상속은 자주 쓰이는 상속 패턴이지만, 상위 타입 생성자가 항상 두번 호출된다는 비효율적인 면도 있음 기생 상속 조합은 생성자 훔치기를 통해 프로퍼티 상속을 구현하지만, 메소드 상속에는 프로토타입 체인을 혼용 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  function inheritPrototype(subType, superType) { var prototype = object(superType.prototype); // 객체 생성  prototype.constructor = subType; // 객체 확장  subType.prototype = prototype; // 객체 할당 } function SuperType(name) { this.name = name; this.colors = [\u0026#34;red\u0026#34;, \u0026#34;green\u0026#34;]; } SuperType.prototype.sayName = function() { console.log(this.name); }; function SubType(name, age) { SuperType.call(this, name); this.age = age; } inheritPrototype(SubType, SuperType); SubType.prototype.sayAge = function() { console.log(this.age); };     "
},
{
	"uri": "https://ysjune.github.io/posts/javascript/etc/apply_call_bind/",
	"title": "Apply,Call,Bind 에 대해",
	"tags": [],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "apply, call, bind 서버 사이드인 java 의 this 와 javascript 의 this 가 헷갈리는 부분이 많은데,\nthis 와 관련된 내용인 call, apply, bind 에 대한 내용이 5장(참조 타입) 에 나와 이 부분은 따로 정리해보고자 한다.\nthis  우선 this.. java 에서는 자기 자신을 가리키지만, javascript 에서는 다르다.\njavascript 에서의 this 는 함수가 어떻게 호출되었는지에 따라 다르게 동적으로 매핑? 된다.  1 2 3 4 5 6 7 8 9 10  var foo = function() { console.log(this); } foo(); // this == window  var obj = {foo : foo}; obj.foo(); // this == obj  var instance = new foo(); // this == instance   하지만 이렇게만 된다면 간단하겠지.. 다음을 보면\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  1) function foo() { console.log(this); // this == window \tfunction bar() { console.log(this); // this == window \t} bar(); } foo(); 2) var obj = { foo : function() { console.log(this); // this == obj \tfunction bar() { console.log(this); // this == window \t} bar(); } }; obj.foo();   이외에도 더 있겠지만, 내부함수의 경우에는 this 는 전역을 가리키는 것을 알 수 있다.\n찾아보면 이 부분은 설계 결함으로\n 메소드가 내부함수를 사용하여 자신의 작업을 돕게 할 수 없다는 것을 의미한다 라고 하는데, 들어도 무슨 말인지 잘\u0026hellip;\n여하튼 이런 문제로 인해 this 가 전역을 회피하는 방법이 있는데, 그것이 바로 apply, call, bind 이다.\n(물론 이전 회사에서 사용했던 var me = this 이런 방식도 있긴 함..)\n apply  this 를 특정 객체에 명시적으로 바인딩 Function.prototype.apply  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  obj.apply(thisArg, [argsArray]) //thisArg : 함수 내부의 this 에 바인딩할 객체 // argsArray : 함수에 전달할 argument 배열  -------------------------------------- var person = function(name) { this.name = name; } var foo = {}; person.apply(foo, [\u0026#39;snack\u0026#39;]); console.log(foo); // {name : snack}    call  apply()와 기능은 같지만, 2번째 파라미터가 배열이 아닌 하나의 인자  1 2 3 4 5  person.apply(foo, [1,2,3]); person.call(foo, 1,2,3);   콜백 함수 같이 내부 함수의 this 를 위해서 사용된다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  function Person(name) { this.name = name; } Person.prototype.doSomething = function (callback) { if(typeof callback == \u0026#39;function\u0026#39;) { callback.call(this); } }; function foo() { console.log(this.name); } var p = new Person(\u0026#34;snack\u0026#34;); p.doSomething(foo); // \u0026#39;snack\u0026#39;   bind  apply, call 과는 다르게 함수에 인자로 전달된 this 가 바인딩된 새로운 함수를 반환한다.  1 2 3 4 5 6 7 8 9  window.color = \u0026#34;red\u0026#34;; var o = {color : \u0026#34;blue\u0026#34;}; function sayColor() { console.log(this.color); } var objectSayColor = sayColor.bind(o); objectSayColor(); // blue    apply, call 과 방법은 비슷하지만, 호출을 하지 않고 함수만 반환한다는 점이 다르다.  1  call(this, 1,2,3) == bind(this)(1,2,3) // bind(this) 는 반환 (1,2,3)이 실행   "
},
{
	"uri": "https://ysjune.github.io/posts/javascript/etc/object.assign/",
	"title": "Object.assign 에 대해",
	"tags": [],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "자바스크립트 4장에서 객체 복사에 대한 내용을 다루다가\nObject.assign() 을 통해 복사가 가능하다는 얘기를 잠깐 했었는데,\n자세히 모르니 이번 기회에 짚고 넘어가보자\nObject.assign() 우선 MDN 에서 하는 설명을 보면\n The Object.assign() method is used to copy the values of all enumerable own properties from one or more source objects to a target object. It will return the target object.\n 대상 객체로 하나 또는 그 이상의 열거 가능한 프로퍼티를 타겟오브젝트 복사할 때 사용.. 한다고 하는데, 글만 봐서는 잘 모르겠다.\n우선 문법을 살펴보면,\n Object.assign(target, \u0026hellip;sources)\n parameter\n  target sources       return\n  target Object     첫번째 파라미터인 target 은 설명의 target object 를 가리키고, sources 는 1개 혹은 그 이상의 열거 프로퍼티를 가리키는 것을 알 수 있다.\n그리고 반환값은 target object 이다.\n문법을 알아봤으니, 간단한 예제를 보면.\n1 2 3 4 5 6  const obj = { a: 1 }; const copy = Object.assign({}, obj); console.log(copy); // { a: 1 } obj.a = 2; console.log(obj); // { a: 2 } console.log(copy); // { a: 1 }   {} 에 obj의 프로퍼티를 복사(?) 했고, obj 와 copy 는 별개의 객체로 볼 수 있다. 이같이 obj 의 속성이 값일 경우엔 별 문제가 되지 않는다. 하지만 객체를 복사할 경우에는 얘기가 달라지는데\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  let obj1 = { a: 0 , b: { c: 0}}; let obj2 = Object.assign({}, obj1); console.log(obj2); // { \u0026#34;a\u0026#34;: 0, \u0026#34;b\u0026#34;: { \u0026#34;c\u0026#34;: 0}}  1) obj1.a = 1; console.log(obj1); // { \u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: { \u0026#34;c\u0026#34;: 0}} console.log(obj2); // { \u0026#34;a\u0026#34;: 0, \u0026#34;b\u0026#34;: { \u0026#34;c\u0026#34;: 0}}  2) obj2.a = 2; console.log(obj1); // { \u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: { \u0026#34;c\u0026#34;: 0}} console.log(obj2); // { \u0026#34;a\u0026#34;: 2, \u0026#34;b\u0026#34;: { \u0026#34;c\u0026#34;: 0}}  3) obj2.b.c = 3; console.log(obj1); // { \u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: { \u0026#34;c\u0026#34;: 3}} console.log(obj2); // { \u0026#34;a\u0026#34;: 2, \u0026#34;b\u0026#34;: { \u0026#34;c\u0026#34;: 3}}   1과 2의 경우에서는 값 자체이므로 서로 영향을 미치지 않는다.\n하지만, 3과 같이 객체의 경우에는 얕은 복사 를 하기 때문에 참조값을 복사하게 된다.\nMDN 에서는 깊은 복사를 하기 위해서는 다음과 같은 방법을 하라고 얘기하는데\n1 2 3 4 5  obj1 = { a: 0 , b: { c: 0}}; let obj3 = JSON.parse(JSON.stringify(obj1)); obj1.a = 4; obj1.b.c = 4; console.log(obj3); // { a: 0, b: { c: 0}}   JSON 을 통하여 obj1 을 문자열로 변환하고, 다시 객체로 만드는 과정을 통하는 것이다. (문자열로 만든 시점에서 참조 주소고 뭐고 없을 것 같긴 하다.)\n알고자해서 작성한 내용은 여기서 끝이지만, assign 을 사용하는 방법은 여러가지 방법이 있으니, 좀 더 적어보겠다.\n1. 객체 병합 1 2 3 4 5 6 7 8 9 10  const o1 = { a: 1, b: 1, c: 1 }; const o2 = { b: 2, c: 2 }; const o3 = { c: 3 }; const obj1 = Object.assign({}, o1, o2, o3); console.log(obj1); // { a: 1, b: 2, c: 3 } // 뒤에 값에 의해 덮어쓰기  const obj2 = Object.assign(o1, o2, o3); console.log(obj2) // { a: 1, b: 2, c: 3 } console.log(o1) // { a: 1, b: 2, c: 3 } // 대상 자체가 변경    이후의 부분은 자바스크립트에 대해 공부를 더 한 후 개념을 알면 후술하는 것으로\u0026hellip;  2. 심볼 타입 프로퍼티 복사 3. 프로토타입 체인의 속성, 열거불가 프로퍼티는 복사 불가 4. 프리미티브 는 객체로 래핑 1 2 3 4 5 6 7 8 9  var v1 = \u0026#39;abc\u0026#39;; var v2 = true; var v3 = 10; var v4 = Symbol(\u0026#39;foo\u0026#39;); var obj = Object.assign({}, v1, null, v2, undefined, v3, v4); // Primitives will be wrapped, null and undefined will be ignored. // Note, only string wrappers can have own enumerable properties. console.log(obj); // { \u0026#34;0\u0026#34;: \u0026#34;a\u0026#34;, \u0026#34;1\u0026#34;: \u0026#34;b\u0026#34;, \u0026#34;2\u0026#34;: \u0026#34;c\u0026#34; }   문자열만 열거 가능한 프로퍼티를 가지고 있기 때문에 문자열만 복사가 됨을 알 수 있다.\n5. 복사중 예외 발생 6. 접근자 복사  적어보려고 했으나 모르는 게 너무 많다.\n참고로, Object.assign() 의 경우 익스플로러에서는 동작하지 않는다고 한다.\n"
},
{
	"uri": "https://ysjune.github.io/posts/model/2019_6_3/",
	"title": "Aggregate, Value",
	"tags": [],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "중요한 도메인 로직은 도메인으로 하자.\nService Layer 에 set 메소드가 있으면 일단 의심 -\u0026gt; 이 부분을 도메인 영역으로 변경할 수 있도록 하자\nAggregate Entity + Value 의 개념 (포함관계에 있다, 즉 여러개의 Entity + Value 의 모음이 될 수 있음.) (라이프 사이클이 동일할 가능성이 높다)\nAggregate 에 Root 를 만들고, 일관성(Consistency)이 깨지지 않도록 Root에 책임을 부여\n 일관성이란 구성요서들 간의 불일치가 존재하지 않는 것. 즉, Root 를 통해서만 하위 Value 들을 변경할 수 있도록 함.  (여기서 value 가 자신만의 pk 를 가지고 있지 않기 때문에 value 임.. Entity는 DB 로 봤을 때 pk가 포함된 테이블이라 볼 수 있으니..)\nValue 변경  Set 을 통하여 기존값을 변경하는 방법 New 를 하여 기존값을 변경하지 않고 새로 만드는 방법  2가지 방법이 존재.\n하지만, 2번 방법을 추천 이유는 new 를 사용할 경우 불변(Immutable) 이 되며, 불변이 되었을 경우 코드 분석이 용이하다.\n(생각해보면, 당연할 수도 있는 것\u0026hellip; 특히 Map 같은 Collection 객체들로 움직일 때, Map 을 넣어서 Map 을 받고\u0026hellip; Map 의 Key 값이 변경되는 경우도 있어서 사전정보로 알 수 없는 것들을 get 으로 가져오는 경우 그것이 이전부터 있던 값인지, 신규값인지는 해당 메소드 혹은 쿼리 쪽을 직접 까보지 않는 한 모름)\n  불변에 대해서 생각해보면 일리는 있다고 생각함. 근데 자바에서 불변으로 사용하려면 final 을 붙여서 사용하는데, 객체나 Map 같은 건 final 키워드를 사용해도 변경할 수 있는 걸로 알고 있음.. 이 부분은 따로 더 찾아봐야 할 주제)\n  Repository = Aggreate 단위로 존재\n(이 부분은 좀 헷갈림. Repository 를 여태 DB 테이블 단위로 생각하고 있었고, Entitry = Repository 로 생각하고 있었음.\n근데 갑자기 저런 등호가 성립된다고 하면\u0026hellip;? 포함관계가 성립된다고는 하나 3개의 관계가 명확하게 잡히는 것은 아님)\n  추후에는 Aggregate 는 어디까지 정의할 수 있는지 확인해보도록 함.\n"
},
{
	"uri": "https://ysjune.github.io/posts/model/2019_6_5/",
	"title": "What-How 에 대해 (1)",
	"tags": [],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "What - How 에 대해 What 상위 수준의 개념적인? 그런 느낌의 말\nEx) 좌회전을 한다.\nHow 실제로 어떻게 했는가? 에 대한 What 에 대한 대답?\nEx) 핸들을 좌측으로 돌린다, (기어를 어쩌구 저쩌구\u0026hellip;.라는 상세한 말이 될 수도 있고)\n What 에는 의도(Intent) 가 들어있음. How 는 다른 How 의 What 이 될 수 있음. 개발자의 단점이자 장점 = 구현부터 생각함 (근데 이건 당연한 것이라 생각함. 개발자라는 건 일종의 Creator 라고 생각함. 즉 무언가를 실제적인 결과물로 만들어내는 것이 개발자임. 당연히 누군가가 추상적인 말을 했을 때 그것을 어떻게 구현할까라는 건 당연한 귀결이라 생각, 하지만 이로 인해 요구사항을 곡해하면 그건 그것대로 문제\u0026hellip;) What 의 장점이란 How 를 몰라도 구현은 할 수 있음. (이 내용을 들으면서 어탭터 패턴인가? 그 부분이 생각났음. 어디서 읽었는지는 기억 안나는데, 서로 바깥부분만 맞춰놓고 개발한 후에 마지막 연동때만 테스트를 했던가. 뭐 그런 내용) 고수준 정책(HighLevel Policy) \u0026lt;-\u0026gt; 저수준 상세(LowLevel Detail) : 고수준에서는 개념적인 내용이 나오므로 Interface 가 되고 저수준에서는 실제 디테일한 개발이 필요하므로 Implement 에 해당된다.   어떻게 보면 이런 부분은 리펙토링에서도 많이 보이는 내용이다. 항상 의식은 하지만, 습관이 들지 않아 아직 미숙한 형태의 그런 내용. 이런 부분은 의식적인 연습도 많이 필요하겠지만, 그것보다는 책을 많이 읽는다던가(?) 등을 통해 What 과 How 를 분리를 잘 해야 할 것 같다. 실제로 잘못분해해서 이상하게 만들수도 있을 것 같고 말이지. 특히 How 는 다른 How 의 What 이 될 수 있다. 어찌보면 귀에 걸면 귀걸이 코에 걸면 코걸이..  "
},
{
	"uri": "https://ysjune.github.io/posts/model/2019_6_12/",
	"title": "What-How 에 대해 (2)",
	"tags": [],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "What - How (2) What 이란 개념적인 용어로 설명? 해야한다.\nhasCardBoard() 이런걸로 만들면 How의 연장선상이 될 수 있음 (이 부분이 들으면서 어려웠던 부분이고, 다시 생각하게 하는 부분. 여태까지 if(ass == 1) 이런 형식만 단어로 바꾸듯 했는데,\n크게 생각하지 않고 했던 것 같음. 분명 저런 식으로 바꾼 게 있을 것임. 앞으로는 그 부분을 생각하면서 최대한 추상적(?) 으로 이름을 지을 수 있게 해야겠음)\n\u0026ndash;\u0026gt; 결론 : 이름을 잘 짓자(?!)\n What 과 How 를 잘 불리하는 방법은   Extract Method static Method 1의 경우는 메소드 추출 자체는 나름 한다고 생각한다. 하지만, IntelliJ 에서 메소드 추출하는 방법은 자세히 모름 -\u0026gt; 이 부분 상세히 알아서 다음부터는 단축키를 통해 메소드를 추출할 수 있도록!\nstatic Method 의 경우는 주로 Util 클래스 같은 곳에서 본 것인데, 그런 건가??  What 이 내포하는 것? 구현을 생각하지 않는 것.\n구현하려하는 것의 현실적인(개념적인?) 로직\nEx) 주문이라는 Aggregate 가 있을 때 MemberId 는 속성이 아닐 수 있다. -\u0026gt; 도메인적으로 생각하면 MemberId 보단 주문한 회원이 됨, 물론 주문한 회원을 MemberId 로 표현할 가능성도 있음 (있지만 굳이..?)\n결국 What 은? 추상화를 가능하게 하며, 의미를 부여해준다.\n 아에 백지인 상태에서 들었으면 오히려 이해가 빠르게 됐을 것 같다.\n기존에 구현하던 구조(?) 를 생각하면서 아, 이게 여기에 매칭하면 되겠고, 저건 저기에 매칭할 수 있겠다 라고 생각했더니, Repo 영역이 나오고 하면서 더 헷갈려 지고 있다.\nInfra 쪽을 Mapper 혹은 XML 쪽으로 생각했는데, 설명을 듣다보면 또 아닌거 같고, 계속 듣다보면 어라 외부 통신인가? DB 직접인가? 그러면 내가 생각하는 부분은 어딜로 생각해야 하는거지? 의문이 계속드는데\u0026hellip;\n기본이 부실하니 더 그런것 같다. 역시 Back To Basic 인가..?  "
},
{
	"uri": "https://ysjune.github.io/posts/model/2019_5_24/",
	"title": "기능, 역할, 책임",
	"tags": [],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "회사에서 진행하는 모델에 관한 세미나를 듣고 내용을 정리하고자 함. (1시간 가량 진행)\n중간중간 개인 의견 들어갈 수 있음.\n1. 기능 기능이란 사용자 \u0026lt;-\u0026gt; 시스템 간의 상호작용\nInput -\u0026gt; 기능 -\u0026gt; Output 으로 간단하게 말하면 Input 과 Output 이 키포인트라고 할 수 있음.\nInput과 Output 는 각각 2가지가 있을 수 있음.\n Input   파라미터 DB 같은 곳에서 들어오는 정보 (이 부분은 이해가 갈 듯하면서 뭔가 파라미터 보다는 개념적인 느낌이 들었기에 확실하게 이해가 되진 않았던 부분)   Output   return 직접적인 return 보다는 한 행위로 인해 실행되는 결과? (예를 들면, 1.의 return 은 성공,실패 등의 상태값이 될 수 있고, 2.는 행위라고 생각됨)  기능은 상황에 따라 다르게 존재 혹은 동작할 수 있음.\n2. 역할, 책임 High Cohesion\nLow Coupling\n(정처기 한창 공부할 때 기억나는 High Chesion, Loose Coupling 의 개념)\n저 두 단어면 다 설명이 됨. -\u0026gt; 결과적으로 기능 수정이나, 유지보수가 용이해짐.\n기능에는 여러 하위 기능이 있을 수 있으며, 기능에 하위 기능을 도출하는 연습을 많이 해야 함.\n물론 처음에는 잘 보이지 않고, 크기가 큰 클래스 혹은 메소드 일 수록 쪼개기가 어렵다. (메소드 추출 방식 등..)\n메소드 추출을 하다보면 크기가 오히려 커지고, 구조가 복잡해질 수 있다. (이 부분은 공감하는 부분이고 실제로 경험.. 하면서도 이게 맞는건가 의구심이 든 적도 있음)\n역할, 책임에 대해서는 객체지향 원리랄까 그 부분이 생각나는 부분이었음. (단일책임원칙, 캡슐링 - 캡슐링이 맞던가..)\n이런 자리를 회사 내부에서 업무 시간에 갖는다는 것은 좋은 것 같다.\n잘 응용해서 반푼이가 아닌 멀쩡한 개발자가 되도록\u0026hellip;\n"
},
{
	"uri": "https://ysjune.github.io/posts/model/2019_5_29/",
	"title": "모델",
	"tags": [],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "Model user - 상호작용(UI) -\u0026gt; 로직(Service) \u0026lt;-\u0026gt; 인프라 (DB, 메일등)\n으로 구성되어 있다고 했을 때,\n로직 \u0026lt;-\u0026gt; 인프라 는 관계는 없으나, 없으면 안되는 그런 존재이다.\n기존의 Service - DAO\nDTO 구조는 관련된 것이 한 곳에 모이지 않음. (High Cohension 이 되지 않음, 즉 구조 파악이 어려움) 그리고, 도메인을 잘 표현하지 못한다.\n여기서 의문은 도메인 이라는 말의 개념인데.. (이 부분은 추후에 따로 알아보도록 함) 일단, Data + 기능 이라고 할 수 있다.\n도메인은\n  Entity - DB의 pk에 준하는 변수를 가지고 있으며, Value 를 가지고 있음. 본인 변수에 대한 제어를 하며 자기 자신의 라이프 사이클을 가지고 있다고 할 수 있다.\nEx) AS 접수\n  Value - 개념적인 값의 하나를 표현한다고 할 수 있다. (속성은 많을 수 있음)\nEx) 요청자 (라는 개념적인 일종의 하위 Entity? Name, PhoneNum 같은 변수들이 들어갈 수 있음)\n  Domain 은 기능이라고 볼 수 있으며,\nSvc(Service) 는 흐름제어를 담당한다.\nApp - Svc 가 있고, Domain 에 AS 접수, AS접수 Repo 가 있다.\nAS접수 Repo (findOne, save\u0026hellip; 같은 것들)\n Domain 로직은 한 곳에 모으도록 해야한다.  "
},
{
	"uri": "https://ysjune.github.io/categories/%EB%AA%A8%EB%8D%B8-%EC%84%B8%EB%AF%B8%EB%82%98/",
	"title": "모델 세미나",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ysjune.github.io/posts/linux/book/chapter1/",
	"title": "1장. 컴슈터 시스템 개요",
	"tags": [],
	"categories": [],
	"series": ["그림과 실습으로 배우는 리눅스"],
	"description": "",
	"content": " 애플리케이션 : 사용자가 직접 사용, 컴퓨터의 오피스 프로그램 또는 스마트폰 앱등 미틀웨어 : 여러 애플리케이션이 공통으로 사용하는 처리를 묶어서 애플리케이션의 실행을 도와줌 OS(운영체제) : 하드웨어를 직접 조작하여 애플리케이션이나 미들웨어의 실행에 필요한 기능을 제공  OS 는 여러 가지 프로그램을 프로세스 라고 하는 단위로 실행\n소프트웨어(프로그램)은 1개 또는 여러 개의 프로세스로 구성\nCPU 에는 커널 모드와 사용자 모드, 2가지의 모드가 있다.\n디바이스 드라이버 동작 - 커널 모드\n프로세스 동작 - 사용자 모드\nOS 의 핵심 부분이 되는 처리(프로세스 관리, 스케쥴링, 메모리 관리 등)를 모아 담당하는 프로그램을 커널이라고 부름.\n커널에서는 시스템에 탑재된 CPU 나 메모리 등의 리소스를 관리, 리소스의 일부를 각 프로세스에 적절히 분배\n전체적으로 앞으로 커널에 대해 어떻게 풀어나가겠다 하는 인덱스를 풀어서 설명한 느낌.\n"
},
{
	"uri": "https://ysjune.github.io/posts/linux/book/chapter2/",
	"title": "2장. 사용자모드로 구현되는 기능",
	"tags": [],
	"categories": [],
	"series": ["그림과 실습으로 배우는 리눅스"],
	"description": "",
	"content": "OS는 커널 이외에도 사용자 모드에서 동작하는 다양한 프로그램으로 구성\n라이브러리 형태, 단독 프로그램으로 동작 이 부분은 다양..\n시스템 콜, OS가 제공하는 라이브러리, OS가 제공하는 프로그램에 대한 설명 및 필요 이유\n시스템 콜 프로세스에서 커널의 도움이 필요할 때 시스템 콜을 이용해 도움 요청\n 프로세스 생성, 삭제 메모리 확보, 해제 네트워크 파일 시스템 등등  CPU의 모드 변경 프로세스는 보통 사용자 모드로 실행, 처리를 위해 시스템 콜을 호출하면 CPU 에서 인터럽트 발생\n그 후 커널 모드에서 해당 동작을 실행, 완료 후 사용자 모드로 원복\n커널 모드로 가기 전에 프로세스의 요구가 유효한지 확인을 거침 -\u0026gt; 맞지 않으면 시스템 콜 실패 (인터럽트를 하고, 확인을 할까? 아니면 확인 후 인터럽트일까? 아마 후자..?)\n시스템 콜 없이 직접 CPU 모드를 변경하는 방법은 존재 X\n시스템 콜 호출의 동작 순서 프로세스가 어떤 시스템 콜을 호출했는가는 strace 명령어를 통해 확인 가능\nstrace 각각의 줄은 1개의 시스템 콜 호출을 의미\n실험 프로세스가 사용자 모드와 커널 모드 중 어느 쪽에서 실행되고 있는지의 비율은 sar 명령어로 확인 가능\nsar -P ALL 1\n사용자 모드에서 프로세스를 실행하는 시간의 비율 = %user + %nice\nCPU코어가 커널 모드에서 시스템 콜 등의 처리를 실행하고 있는 시간의 비율은 %system\n 대체로 %System 수치가 크면(수십 이상) 시스템 콜이 너무 많이 호출되고 있거나, 시스템에 과부하가 걸려있는 듯 좋지 않은 상태를 의미  시스템 콜의 wrapper 함수 시스템 콜은 보통의 함수 호출과는 다르게 C 언어 등의 고급언어에서는 직접 호출이 불가능.\n만약 OS 에 도움이 없었다면 각 프로그램은 시스템 콜을 호출할 때마다 아키텍처에 의존하는 어셈블리 언어를 써서 어셈블리 코드를 호출해야 했음.\n(이 부분도 약간의 관심은 있음. 시간이 되면 리버스 엔지니어링 책을 보자\u0026hellip;)\nOS는 내부적으로 시스템 콜을 호출하는 일만 하는 함수를 제공하는데 이를 시스템 콜 wrapper 라고 함.\n표준 C 라이브러리 (일단은 정리하는 차원에서 적는다. C라이브러리를 알아야하는지, 혹은 써먹을 일이 있는지에 관해서는 글쎄..)\nISO 에 의해 정해진 표준 라이브러리가 존재하며, 리눅스에도 제공하고 있음.\n보통 GNU 에서 제공하는 glibc 를 표준으로 사용.\n프로그램이 어떠한 라이브러리를 링크하고 있는가는 ldd 명령어를 사용하여 확인 가능.\nOS가 제공하는 프로그램  시스템 초기화 : init OS의 동작을 바꿈 : sysctl, nice, sync 파일 관련 : touch, mkdir 텍스트 데이터 가공 : grep, sort, uniq 성능 측정 : sar, iostat 컴파일러 : gcc 스크립트 언어 실행 환경 : perl, python, ruby 셸 : bash 윈도우 시스템 : X  음.. 일단 모르는 말 투성이라 정리는 해봤으나, 자주봐서 눈에 익히는 수 밖에 없는 것 갇다.\n주사용 언어가 자바라서 자바의 strace 를 계산해보려고 했으나, 리눅스가 안 깔려 있으므로\u0026hellip; fail, powershell 에서 될까 싶었는데, 역시 안되더라.\n마지막에 나오는 OS 가 제공하는 프로그램에서는 사용해본 것도 있지만, 사용하지 않은 것들이 더 많으므로, 이 부분은 사용하면서 리눅스 카테고리에 정리도 할까 함..\n"
},
{
	"uri": "https://ysjune.github.io/posts/linux/book/chapter3/",
	"title": "3장. 프로세스 관리",
	"tags": [],
	"categories": [],
	"series": ["그림과 실습으로 배우는 리눅스"],
	"description": "",
	"content": " 가상 기억장치가 없는 단순한 경우만 나타낸다. 실제 프로세스의 생성 및 삭제는 5장에서 자세히 다룸  프로세스 생성의 목적  같은 프로그램의 처리를 여러 개의 프로세스가 나눠서 처리, 예를 들어 웹 서버처럼 리퀘스트가 여러 개 들어왔을 때 동시에 처리해야 하는경우 전혀 다른 프로그램을 생성합니다. 예를 들어 bash 로부터 각종 프로그램을 새로 생성하는 경우 fork(), execve() 함수를 사용 (시스템 내부에서는 clone() 과 execve() 시스템 콜을 호출)  fork() 함수 목적 1의 경우에는 fork() 함수만을 사용.\nfork() 함수를 실행하면 실행한 프로세스와 함께 새로운 프로세스가 1개 생성, 이를 각각 부모, 자식 프로세스라 부름\n 자식 프로세스용 메모리 영역을 작성하고 거기에 부모 프로세스의 메모리를 복사 fork() 함수의 리턴 값이 각기 다른 것을 이용하여 (부모는 자식 프로세스의 ID, 자식은 0을 리턴) 부모 프로세스와 자식 프로세스가 서로 다른 코드를 실행하도록 분기  execve() 함수 서로 다른 프로그램을 생성할 때에 사용\n 실행 파일을 읽은 다음 프로세스의 메모리 맵에 필요한 정보를 읽어 들임 현재 프로세스의 메모리를 새로운 프로세스의 데이터로 덮어씀 새로운 프로세스의 첫 번째 명령부터 실행  \u0026ndash;\u0026gt; 전혀 다른 프로그램을 생성하는 경우 프로세스의 수가 증가하는 것이 아니라 기존의 프로세스를 별도의 프로세스로 변경하는 방식으로 수행.\n실행 파일은 프로세스의 실행 중에 사용하는 코드와 데이터 이외에도 다음과 같은 정보가 필요.\n 코드를 포함한 데이터 영역으 파일상 오프셋 사이즈, 메모리 맵 시작 주소 코드 외의 변수 등에서 데이터 영역에 대한 같은 정보 (오프셋, 사이즈, 메모리 맵 시작 주소) 최초로 실행할 명령의 메모리 주소 (엔트리 포인트 : entry point)  엔트리 포인트에서부터 프로그램을 실행. 리눅스의 실행 파일은 ELF(Executable Linkable Format) 형식 사용.\n전혀 다른 프로세스를 생성할 때는 부모가 될 프로세스로부터 fork() 함수를 호출한 다음 돌아온 자식 프로세스가 exec() 함수를 호출하는 방식, 즉 \u0026lsquo;fork and exec\u0026rsquo; 라는 방식을 주로 사용 종료 처리 프로그램 종료는 _exit() 함수 사용 (내부에서는 exit_group() 시스템 콜 호출\n직접 _exit()를 호출하는 경우는 매우 드물며, 보통은 표준 C 라이브러리의 exit() 함수를 호출\n"
},
{
	"uri": "https://ysjune.github.io/posts/linux/book/chapter4/",
	"title": "4장. 프로세스 스케쥴러",
	"tags": [],
	"categories": [],
	"series": ["그림과 실습으로 배우는 리눅스"],
	"description": "",
	"content": "프로세스 스케줄러 여러 프로그램을 동시에 동작 시킴 (정확히는 동시에 동작하는 것처럼 보이게 함)\n 하나의 CPU는 동시에 하나의 프로세스만 처리 가능 하나의 CPU에 여러 개의 프로세스를 실행해야 할 때는 각 프로세스를 적절한 시간으로 쪼개서 (타임 슬라이스) 번갈아 처리  첫 번째 실험 스케줄러의 동작 확인을 위한 실험, 1개의 논리 CPU 에서만 수행.\n(실험을 진행하는 동안에서는 시스템에서 다른 프로그램이 동작하지 않아야 정확성이 올라감. 이는 보통 설능 측정 실험을 할 때의 기본 원칙)\n 실험 4-A : 동작 프로세스 1개 실험 4-B : 동작 프로세스 2개 실험 4-C : 동작 프로세스 3개  실험 4-A  1개의 프로세스가 항상 동작 1개의 프로세스 외에는 동작하는 프로세스가 없으므로 진행도는 단순 경과시간에 의해 비례  실험 4-B  2개의 프로세스가 서로 번갈아가며 CPU 사용 (다시 말하면 동시에 사용하는 것은 아님) 2개의 프로세스는 대략 같은 양의 타임 슬라이스를 가짐 단위 시간별 진행도는 프로세스가 1개일 때와 비교하여 약 절반, 처리 완료까지 걸린 시간은 4-A 보다 2배  실험 4-C  각 프로세스가 동시에 동작하는 일은 없음. 또한 1회마다 타임 슬라이스는 매우 적지만, 균등하게 CPU를 사용 경과 시간은 프로세스가 1개 (실험 4-A)일 때보다 약 4배 걸림  고찰  동시에 프로세스를 여러개 실행하더라도 특정 순간에 논리 CPU에서 동작되는 프로세스는 1개 뿐 첫 번째 프로세스부터 마지막 프로세스까지 한 바퀴 돌면 다시 첫 번째로 가는 라운드로빈 방식 각 프로세스는 대략 같은 타임 슬라이스 종료할 때 까지의 경과 시간은 프로세스 수에 비례 하여 증가  컨텍스트 스위치 논리 CPU 상에서 동작하는 프로세스가 바뀌는 것을 칭함.\n어떤 프로세스가 어떤 프로그램을 실행 중이더라도 타임 슬라이스를 모두 소비하면 발생. But, foo() 직후에 바로 bar() 가 실행된다고는 보장 못함\n이 문제를 이해하면 이후에 처리 시간이 오래 걸렸을 때, 처리 자체의 문제보다는 \u0026lsquo;처리 중에 컨텍스트 스위치가 발생해서 다른 프로세스가 움직였다\u0026rsquo; 라는 관점도 가질 수 있음\n프로세스의 상태 ps ax | wc -l  실행 상태 - 현재 논리 CPU를 사용하고 있습니다. 실행 대기 상태 - CPU 시간이 할당되기를 기다리고 있습니다. 슬립 상태 - 이벤트가 발생하기를 기다리고 있으며 이벤트 발생까지는 CPU 시간을 사용하지 않습니다. 좀비 상태 - 프로세스가 종료된 뒤 부모 프로세스가 종료 상태를 인식할 때까지 기다리고 있습니다.\n  STAT 필드의 첫 글자가 장시간 동안 D인 상태로 있다면   스토리지의 I/O가 종료되지 않은 상태로 되어 있음 커널 내의 뭔가 문제가 발생하고 있음  상태 변환 프로세스는 살아 있는 동안 실행, 실행 가능, 슬립 상태를 몇 번이고 오간다.\nidle 상태 프로세스가 CPU에서 \u0026lsquo;아무것도 하지 않는\u0026rsquo; 특수한 상태\n논리 CPU를 휴식 상태로 만들어 하나 이상의 프로세스가 실행 가능한 상태가 될 때까지 소비 전력을 낮춰 대기 상태로 만듦\n스루풋과 레이턴시  스루풋 : 단위 시간당 처리된 일의 양으로 높을수록 좋습니다. (완료된 프로세스의 수 / 경과 시간) 레이턴시 : 각각의 처리가 시작부터 종료까지의 경과된 시간으로 짧을수록 좋습니다. (처리 종료 시간 - 처리 시작 시간)  논리 CPU가 여러 개 일 때의 스케쥴링 스케줄러 안의 논리 CPU를 여러 개 다루기 위해 \u0026lsquo;로드밸런서\u0026rsquo; 혹은 \u0026lsquo;글로벌 스케줄러\u0026rsquo; 라는 기능이 동작\n로드밸런서를 간단하게 설명하면, 여러 개의 논리 CPU에 프로세스를 공평하게 분배해주는 역할\n"
},
{
	"uri": "https://ysjune.github.io/posts/linux/book/chapter6/",
	"title": "6장. 메모리 계층",
	"tags": [],
	"categories": [],
	"series": ["그림과 실습으로 배우는 리눅스"],
	"description": "",
	"content": "구체적으로 크기와 성능에 얼마나 차이가 있습니까? 이런 차이를 고려하여 하드웨어나 리눅스는 어떤 구조로 되어 있습니까? 라는 두 질문이 이 장에서 풀어나갈 내용.\n캐시 메모리 컴퓨터의 동작 흐름은 다음과 같다.\n 명령어를 바탕으로 메모리에서 레지스터로 데이터를 읽습니다. 레지스터에 있는 데이터를 바탕으로 계산합니다. 처리 결과를 메모리에 씁니다. 컴퓨터에서 처리 2가 아무리 빨라도 처리1 과 처리3에서 속도 상의 병목이 생겨 느려질 수 있음.\n캐시 메모리는 이런 레지스터 안에서 계산하는 것과 메모리에 접근하는 것, 양쪽의 처리 시간의 차이를 메우는데 필요.\n메모리에서 레지스터로 데이터를 읽어올 때는, 일단 캐시 메모리에 읽어온 뒤 같은 내용을 다시 레지스터로 읽어 들입니다. 이 때 읽어오는 크기는 CPU에서 정한 \u0026lsquo;캐시 라인 사이즈'만큼\n데이터를 덮어 쓸 때 쓰는 단위도 캐시 라인 사이즈 이며, 변경되었음을 나타내는 플레그를 사용하는데, 이를 \u0026lsquo;더티\u0026rsquo; 라고 부름\n이 \u0026lsquo;더티\u0026rsquo; 플레그가 붙어 있는 데이터는 나중에 백그라운드 처리로 메모리에 다시 기록되는데, 이러한 방법을 라이트 백(write back) 이라고 부르며, 더티가 아니게 됨\nCPU가 캐시 메모리에 있는 데이터에만 접근할 때에는 모든 접근이 캐시 메모리의 속도로 처리되므로 캐시 메모리가 없는 경우보다 훨씬 빠르게 처리됨.  캐시 메모리가 가득 찬 경우 기존의 캐시 메모리 중 1개를 파기, 그 후 비워진 캐시라인에 데이터를 복사\n파기하는 캐시가 더티라면 대응되는 메모리에 덮어쓴 다음 버리는 동기화 작업이 일어남\n만약, 캐시 메모리가 가득 차고 다 더티라면, 캐시 라인 안의 데이터가 자주 바뀌게 되는 스레싱(thrashing) 이 발생하여 성능이 크게 감소할 수 있음.\n계층형 캐시 메모리 최근의 CPU는 캐시 메모리가 계층형으로 되어 있음.\n계층형 구조를 구성하는 각 캐시 메모리는 L(Level)1, L2, L3 등의 이름이 붙어 있으며 번호가 늘어날 수록 레지스터로부터 멀어지며 용량이 커지고 속도가 느려짐.\n메모리 참조의 국소성 프로세스의 데이터가 전부 캐시에 있는 동안에는 데이터에 접근하는 속도는 메모리에 접속하는 속도가 아니라 이보다 빠른 캐시에 접근하는 속도.\n프로그램은 대부분 메모리 참조의 국소성(locality of reference) 이라고 하는 특성이 있음.\n 시간 국소성 : 특정 시점에서 접근하는 데이터는 가까운 미래에 다시 접근할 가능성이 큼, 전형적인 예로 루프 처리 중인 코드 영역 공간 국소성 : 특정 시점에 어떤 데이터에 접근하면 그 데이터와 가까운 주소에 있는 데이터를 접근할 확률이 높음, 전형적인 예로 배열의 전체 검색\n이러한 이유로 프로세스는 짧은 시간을 높고 생각해보면 자신이 획득한 메모리의 총량보다 훨씬 좁은 범위의 메모리에 접근하는 성향이 있음.  정리 속도를 중요시 하는 프로그램이라면 캐시 메모리의 효과를 최대한으로 끌어내기 위해 데이터의 배열이나 알고리즘 혹은 설정을 연구해서 단위 시간 당 메모리 접근 범위를 작게 하는 것이 중요. 한편, 시스템 설정을 변경했을 때 프로그램의 성능이 크게 나빠진 경우에는 프로그램의 데이터가 캐시 메모리에 전부 들어가지 않았을 가능성이 있음.\nTranslation Lookaside Buffer 프로세스는 다음과 같은 순서에 따라 가상 주소의 데이터에 접근\n 물리 메모리상에 존재하는 페이지 테이블을 참고하여 가상 주소를 물리 주소로 변환 1에서 구한 물리 메모리에 접근 캐시 메모리를 사용하여 고속화하는 것은 2뿐 (1은 물리 메모리상에 있는 페이지 테이블에 접근해야 하므로)\n이 때문에 CPU에는 가상 주소에서 물리 주소로의 변환표를 보관하는 한편, 캐시 메모리와 똑같이 고속으로 접근 가능한 TLB라는 영역이 있고, 이를 가지고 1을 고속화함  페이지 캐시 CPU로부터 메모리에 접근하는 속도에 비해 저장 장치에 접근하는 속도는 엄청나게 느림.\n페이지 캐시는 캐시 메모리와 매우 비슷, 캐시 메모리가 메모리의 데이터를 캐싱하는 것과 비슷하게 저장 장치 내의 파일 데이터를 메모리에 캐싱\n캐시 메모리는 캐시 라인 단위로 데이터를, 페이지 캐시는 페이지 단위로 데이터를 다룸\n프로세스가 파일의 데이터를 읽어 들이면 커널은 프로세스의 메모리에 파일의 데이터를 직접 복사하는 것이 아니라 일단 커널의 메모리 내에 있는 페이지 캐시라는 영역에 복사한 뒤 이 데이터를 프로세스 메모리에 복사.\n이 방법은 저장 장치에 직접 접근하는 경우에 비해 훨씬 빠르며, 페이지 캐시는 전체 프로세스 공유의 자원이므로 읽어들인 프로세스는 최초에 파일 데이터에 접근한 프로세스와 다른 프로세스여도 상관 없음\n캐시와 비숫하게 더티 페이지가 존재.\n각 프로세스가 접근하는 파일의 데이터가 전부 페이지 캐시에 있으면 시스템 파일의 접근 속도는 저장 장치가 아닌 메모리 접근 속도에 근접하므로 시스템 전체가 빠르게 동작\n동기화된 쓰기 페이지 캐시에 더티 페이지가 있는 상태로 시스템의 전원이 강제로 꺼지면, 데이터가 사라짐. 이런 사태가 벌어지지 않게 하기 위해서는 Open() 시스템 call 로 파일을 열 때, O_SYNC 플레그를 설정 이렇게 하면 파일에 write() 시스템 call을 수행할 때마다 데이터는 페이지 캐시 외에 저장 장치에도 동기화되어 쓰기가 수행됨\n버퍼 캐시 페이지 캐시와 비슷한 구조. 페이지 캐시와 버퍼 캐시를 합쳐서 저장 장치 안의 데이터를 메모리에 넣어두는 방식\n튜닝 파라미터 페이지 캐시를 제어하기 위한 튜닝 파라미터가 존재\n더티 페이지의 라이트 백이 발생하는 주기 sysctl vm.dirty_writeback_centisecs 기본값은 5초에 1번 라이트 백\n시스템 메모리가 부족할 때 라이트 백 부하가 커지는 것을 방지 sysctl vm.dirty_background_ratio 기본 값은 10\n더티 페이지가 차지하는 비율이 지정된 퍼센트를 초과할 경우 동기적인 라이트 백을 수행 sysctl vm.dirty_ratio 기본 값은 20\n이러한 파리미터를 잘 조절해서 시스템 메모리가 부족해 갑자기 더티 페이지의 라이트 백이 자주 발생하는 일이 없도록 하는 것이 좋음\n정리 파일의 데이터가 페이지 캐시에 있다면 없는 경우와 비교해서 파일 접근이 매우 빨라짐. 설정 변경이나 시간이 지나면서 시스템의 성능이 갑자기 느려졌다면 파일의 데이터가 페이지 캐시에 제대로 들어가지 못했을 수 있음. sysctl 파라미터를 잘 튜닝한다면 페이지 캐시의 라이트 백이 자주 발생하여서 생기는 I/O 부하를 막을 수 있음.\n하이퍼스레드 CPU의 계산 처리 소요 시간에 비해 메모리 접근의 레이턴시가 매우 느림. 거기에 캐시 메모리의 레이턴시도 CPU의 계산 처리에 비교하면 비교적 느린 편. 그렇기에 대부분의 시간이 메모리 혹은 캐시 메모리로부터 데이터를 기다리는 일로 낭비됨\n하이퍼스레드의 기능은 CPU 코어 안의 레지스터 등 일부 자원을 여러개 (일반적으론 2개) 준비해두고, 시스템 입장에서는 각각 논리 CPU로써 인식되는 하이퍼스레드라는 단위로 분할되는 하드웨어 기능\n베스트 케이스라고 할지라도 2배의 성능을 내는 것은 아니며 현실적으론 20~30% 의 성능 향상이 나오면 훌륭하다고 할 수 있음.\n하이퍼스레드는 항상 성능이 좋다고 할 수 없으므로, 하이퍼스레드가 있는 경우와 없는 경우의 성능 측정을 한 다음, 사용 여부를 판단하는 것이 좋음.\n"
},
{
	"uri": "https://ysjune.github.io/posts/linux/command/link/",
	"title": "Link",
	"tags": [],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "리눅스 Ln ln 은 Link 의 약자, 리눅스에서 링크파일을 만드는 명령어로 하드링크와 심볼릭 링크 2가지가 존재\n1. 하드 링크 (Hard Link) 한 개의 파일 혹은 디렉토리를 가리키는 이름을 하나 더 만드는 것.\nA가 원본이고 B가 하드 링크를 건 파일일 때, A의 내용을 수정하면 B도 수정됨.\n하지만, A,B 중 하나를 지웠을 때 하드 링크는 이름을 하나 더 만드는 것이기에 A를 삭제하였다고 해도 B는 그대로 남아 있다.\n따라서 파일을 지우고자 한다면 두 개 파일을 모두 지워야 한다.\n 명령어 : ln [원본파일명] [하드링크파일명]\n  2. 심볼릭 링크 (Symbolic Link) 어떤 파일 혹은 디렉토리를 가리키는 것을 말함. (ex. windows 의 바로가기와 비슷한 개념)\n심볼릭 링크를 사용할 경우\nls -ali 를 사용하면 해당 파일이 어느 곳에 링크가 되어 있는지 확인 가능\nex) a를 b에 심볼릭 링크를 사용할 경우 a -\u0026gt; b\n 명령어 : ln -s [원본파일명] [링크파일명]\n * 추가적으로 ln 에 관련된 옵션  -b : 링크파일 생성시에 대상파일이 이미 존재하면 백업파일을 만든 후에 링크파일을 생성 -d : 디렉토리에 대한 하드링크파일생성을 가능하게 함 -s : 심볼릭 링크파일을 생성 -S : 백업파일 생성시에 원하는 접미사(suffix)를 지정할 수 있음 -t, \u0026ndash;target-directory=DIRECTORY : 링크파일을 생성할 디렉토리를 지정  "
},
{
	"uri": "https://ysjune.github.io/categories/linux/",
	"title": "linux",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ysjune.github.io/series/%EA%B7%B8%EB%A6%BC%EA%B3%BC-%EC%8B%A4%EC%8A%B5%EC%9C%BC%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%A6%AC%EB%88%85%EC%8A%A4/",
	"title": "그림과 실습으로 배우는 리눅스",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ysjune.github.io/posts/linux/command/mv/",
	"title": "파일명 변경",
	"tags": [],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "리눅스 파일명 혹은 디렉토리 명 변경 리눅스 파일명을 변경하는 것인데, 심볼릭 링크로 링크를 건 후 해당 파일 혹은 디렉토리의 이름을 변경할 수 없을까 하여 찾아봤다. 사용법은 간단. \n mv 파일명 변경파일명\n mv before.txt after.txt \n 혹은\n mv 디렉토리명 변경디렉토리명\n mv before after\n\n 찾아보니, 이름을 변경과 동시에 이동도 가능하다고 한다.   mv before.txt /home/contents/after.txt\n"
},
{
	"uri": "https://ysjune.github.io/posts/java/db_insert_id_retrun/",
	"title": "DB Insert 시 자동생성된 id 를 알아내기",
	"tags": [],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "DB Insert 시 자동생성된 id 를 알아내기 1.Mybatis 1 2 3 4 5 6 7 8 9 10 11  \u0026lt;insert id=\u0026#34;insertStudent\u0026#34; parameterType=\u0026#34;studentDto\u0026#34; useGeneratedKeys=\u0026#34;true\u0026#34; keyProperty=\u0026#34;id\u0026#34;\u0026gt; INSERT INTO student ( name, grade, phone ) VALUES ( #{name}, #{grade}, #{phone} )   사용하는 데이터베이스가 Auto Increment 가 된다면 (e.g. MySQL, Maria) 다음을 통해 id 를 알아낼 수 있다.\n1 2 3 4 5 6 7 8 9  StudentDTO student = StudentDTO.builer(). .name(\u0026#34;snack\u0026#34;) .grade(1) .phone(01011112222) .build(); mapper.insertStudent(student); student.getId() // get ID   2. KeyHolder 를 사용한 방법 MyBatis 를 사용하지 않고, jdbcTemplate 를 사용하는 경우로,\n이번 작성을 하게 만든 주인공이다. jdbcTemplate 을 사용한 경험이 거의 없기에, insert 후 pk id 를 어떻게 불러올까 했는데, 이런 방법이 있었다.\n(알았어도, 학부 이후로 jdbcTemplate를 사용한 적이 없기에 까먹었을 수도..)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  public Long saveStudent(final StudentDTO studnet) { KeyHolder keyHolder = new GeneratedKeyHolder(); jdbcTemplate.update(new PreparedStatementCreator() { @Override public PreparedStatement createPreparedStatement(Connection conn) throws SQLException { PreparedStatement pstmt = conn.prepareStatement( \u0026#34;INSERT INTO student (name, grade, phone) VALUES (?, ?, ?)\u0026#34;, new String[] {\u0026#34;id\u0026#34;}); pstmt.setString(1, student.getName()); pstmt.setInt(2, student.getGrade()); pstmt.setString(3, student.getPhone()); return pstmt; } }, keyHolder); student.setId(keyHolder.getKey().longValue()); return student.getId(); }   다음과 같이 하면 생성된 student 의 id 를 알 수 있다.\n(필자는 delete 와 update 에 대한 테스트 코드를 짜는데 id 가 필요했었다.)\n덧붙여서 람다를 사용하면,\n1 2 3 4 5 6 7 8 9 10 11 12  public Long saveStudent(final StudentDTO studnet) { KeyHolder keyHolder = new GeneratedKeyHolder(); jdbcTemplate.update(conn -\u0026gt; { PreparedStatement pstmt = conn.prepareStatement( \u0026#34;INSERT INTO student (name, grade, phone) VALUES (?, ?, ?)\u0026#34;, new String[] {\u0026#34;id\u0026#34;}); ... ... }, keyHolder); student.setId(keyHolder.getKey().longValue()); return student.getId(); }   같이 표현할 수 있다.\n(추가) 3. SimpleJdbcInsert 사용 keyHolder 에 대해 찾아보다가 이런 방식도 있다는 것을 알고 추가해본다.\n(출처 : baeldung)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  @Repository public class StudentDaoImpl implements StudentDao { private final SimpleJdbcInsert simpleJdbcInsert; public StudnetDaoImpl(DataSource datasource) { this.simpleJdbcInsert = new SimpleJdbcInsert(datasource) .withTableName(\u0026#34;student\u0026#34;).usingGeneratedKeyColumns(\u0026#34;id\u0026#34;); } @Override public Long saveStudent(final StudentDTO studnet) { SqlParameterSource sqlParameterSource = new MapSqlParameterSource() .addValue(\u0026#34;name\u0026#34;, student.getName()) .addValue(\u0026#34;grade\u0026#34;, student.getGrade()) .addValue(\u0026#34;phone\u0026#34;, student.getPhone())); Number id = simpleJdbcInsert.executeAndReturnKey(sqlParameterSource); student.setId(id.longValue()); return student.getId(); } }   이름만큼 insert 에 최적화 되어 있는 것 같다. 특히 타입을 Object 로 받기 때문에 타입을 크게 타지 않는 것 같다.\n(이전 PreparedStatement 를 사용할 때는 시간 값에 대해 timestamp 값으로 변경해서 넣어줘야 했는데, 이건 안해도 잘 들어간다.)\n"
},
{
	"uri": "https://ysjune.github.io/posts/java/feign1/",
	"title": "Feign 사용 (1)",
	"tags": [],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "이번 API 통신을 하면서 Feign 을 사용해봤는데, 어떻게 사용했는지 적어보고자 함.\nFeign 이란?  Java to HTTP client binder Netflix 에서 개발함 https://github.com/OpenFeign/feign  이라고 간단하게만,\nAPI 통신을 이용해서 개발할 필요가 생겼는데, API 를 통하여 개발해 본 적이 없기에\n그래서 무작정 구글링 시작 -\u0026gt; httpClient 를 이용해서 통신하는 것을 알게 됨 -\u0026gt; 관련 코드를 보면서 분석 시작 -\u0026gt; Spring 에서는 restTemplate 를 이용한다는 얘기를 들음 -\u0026gt; restTemplate 구글링 및 테스트 코드 작성 -\u0026gt; Feign 이라는 것을 들음 -\u0026gt; Feign 적용해보자 라는 흐름으로 진행. (무려 하루만에 진행된 흐름..)\n테스트 코드를 작성하면서 wireMock, MockMvc, Mockito 등도 사용했는데, 이는 추후에 따로.. 1. 의존성 추가  maven 을 사용하므로 pom.xml 에 의존성 추가  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.github.openfeign\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;feign-jackson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;10.2.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.github.openfeign\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;feign-okhttp\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;10.2.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.github.openfeign\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;feign-slf4j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;10.2.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   2. Feign 인터페이스 작성 FeignClient Annotation이 있으나 깃 readme 에 있는 basic 방법을 사용.\n1 2 3 4 5 6 7 8 9 10 11 12  public interface AAAClient { @RequestLine(\u0026#34;GET /list\u0026#34;) ApiResponse\u0026lt;Data\u0026gt; getList(@QueryMap SearchRequest SearchRequest); @RequestLine(\u0026#34;GET /{boardId}\u0026#34;) ApiResponse\u0026lt;BoardDetail\u0026gt; getDetail(@Param(value = \u0026#34;boardId\u0026#34;) long boardId); @RequestLine(\u0026#34;PUT /{boardId}\u0026#34;) @Headers(\u0026#34;Content-Type: application/json\u0026#34;) ApiResponse\u0026lt;String\u0026gt; putBoard(@Param(\u0026#34;boardId\u0026#34;) long boardId, BoardDetail boardDetail); }    Annotation 사용에 대해  @RequestLine - requestMapping 과 같은 개념, url 앞에 붙여주는 GET, POST, PUT, DELETE 으로 Rest 적용 @Param - 넘길 파라미터 @QueryMap - Param과 같으나, param 의 파라미터가 3개 이상이 안되므로 3개이상의 경우 QueryMap 사용  ex) param -\u0026gt; list?start=1 , QueryMap -\u0026gt; list?start=1\u0026amp;end=2\u0026amp;limit=3   @Headers - 해더를 추가해줌, 응답측에서 requestBody 를 사용할 경우 Content-Type: application/json 과 같이 추가해줘야 함. 이외에도 @Body 와 @HeaderMap 이 있음.    3. ClientConfig 작성 2에서 만든 인터페이스에 대해 config 작성\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  @Configuration public class AAAClientConfig { @Value(\u0026#34;${url}\u0026#34;) private String url; @Bean public AAAClient aAAClient() { return Feign.builder() .retryer(new Retryer.Default()) .client(new OkHttpClient()) .encoder(new JacksonEncoder()) .decoder(new JacksonDecoder()) .logger(new Slf4jLogger(AAAClient.class)) .target(AAAClient.class, url); } }    빌더 패턴을 사용한 것을 알 수 있음. 익숙한(?) httpClient 가 보임.  4. Service 생성 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  @Service public class BoardService { private final AAAClient aAAClient; public static final Logger LOGGER = LoggerFactory.getLogger(BoardService.class); @Autowired public BoardService(AAAClient aAAClient) { this.aAAClient = aAAClient; } public ApiResponse\u0026lt;Data\u0026gt; getList(SurveySearchRequest vo) { ApiResponse\u0026lt;Data\u0026gt; response; try { response = aAAClient.getList(vo); } catch (FeignException ex) { LOGGER.error(\u0026#34;FeignException {}\u0026#34;, ex); } return response; } // 생략 }   5. Test 코드 생성  API 와 직접 통신할 필요는 없음 해당 서비스 로직이 정상적으로 작동하는지 여부만 확인  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  public class ServiceTest { @Rule public WireMockRule wireMockRule = new WireMockRule(); @Rule public MockitoRule rule = MockitoJUnit.rule(); private BoardServiceService service; @Before public void setUp() { AAAClient aAAClient = Feign.builder() .client(new OkHttpClient()) .encoder(new JacksonEncoder()) .decoder(new JacksonDecoder()) .logger(new Slf4jLogger(SurveyClient.class)) .logLevel(Logger.Level.FULL) .target(AAAClient.class, \u0026#34;http://localhost:8080\u0026#34;); service = new AAASurveyService(aAAClient); } @Test public void 목록_test() { SearchRequest req = new SearchRequest(); req.setStart(0); req.setLimit(10); StubMapping accept = stubFor( get(urlPathMatching(\u0026#34;/list\u0026#34;)) .withQueryParam(\u0026#34;start\u0026#34;, equalTo(req.getStart().toString())) .withQueryParam(\u0026#34;limit\u0026#34;, equalTo(req.getLimit().toString())) .willReturn(aResponse() .withStatus(200) .withHeader(\u0026#34;content-type\u0026#34;, \u0026#34;application/json\u0026#34;) .withBody(\u0026#34;{}\u0026#34;) ) ); ApiResponse\u0026lt;Data\u0026gt; ret = service.getList(req); assertEquals(\u0026#34;200\u0026#34;, ret.getCode()); assertEquals(\u0026#34;OK\u0026#34;, ret.getMessage()); } // 생략 }   Feign 설정 및 적용은 이렇게 해서 끝.\n추후 컨트롤러를 통해 실제 API 와 연결되는지 테스트가 필요. (MockMvc 사용)\n"
},
{
	"uri": "https://ysjune.github.io/posts/java/feign2/",
	"title": "Feign 사용 (2)",
	"tags": [],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "Circuit Breaker 적용 API 통신에서 서킷 브레이커를 적용해야 한다는 얘기를 들었고, 이 역시 처음 듣는 용어라 일단 이해를 위해..\nCircuit Breaker 란?  회로차단기로 불리며, 전기적 회로를 과전압 등으로부터 보호하기 위한 장치 시스템에서 장애의 확산을 막기위해 (결함을 격리) 사용되는 패턴의 일종 Netflix 의 Hystrix가 있음  즉, 통신에 문제가 있을 때, pool 을 계속 점유하는 현상을 막기 위해, 차단기를 open 하여 격리한다고 생각하면 될 거 같다.\n뭔가 개념적으로는 이해가 되면서도 헷갈리는 개념이랄까나.. (이해안됐다는 소리\u0026hellip;?)\n여하튼 본론으로 들어가서 이전에 적용했던 Feign 에 서킷브레이커를 적용시켜보도록 함.\n resilience4j-feign 을 사용 resilience4j-circuitbreaker docs - 서킷브레이커 설명이 잘 나온거 같다.  1. 의존성 추가 이전과 같이 maven 을 사용하므로 pom.xml 에 추가해줌.\n1 2 3 4 5 6 7 8 9 10  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.github.resilience4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;resilience4j-feign\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.17.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.github.resilience4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;resilience4j-circuitbreaker\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.17.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   2. Config Decorating  (1)에서 작성한 AAAClientConfig 를 변경  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  @Configuration public class AAAClientConfig { @Value(\u0026#34;${url}\u0026#34;) private String url; CircuitBreakerConfig config = CircuitBreakerConfig.custom() .failureRateThreshold(50) // 실패 임계치 50% 로 설정  .ringBufferSizeInClosedState(20) // 20번 시도  .ringBufferSizeInHalfOpenState(10) // 10초 후 10번 시도  .waitDurationInOpenState(Duration.ofSeconds(3L)) // Open 후 3초 기다림  .build(); CircuitBreaker circuitBreaker = CircuitBreaker.of(\u0026#34;AAAClientCB\u0026#34;, config); FeignDecorators decorators = FeignDecorators.builder().withCircuitBreaker(circuitBreaker).build(); @Bean public AAAClient aAAClient() { return Resilience4jFeign.builder(decorators) .client(new OkHttpClient()) .encoder(new JacksonEncoder()) .decoder(new JacksonDecoder()) .options(new Request.Options(3000, 5000)) .retryer(Retryer.NEVER_RETRY) .logger(new Slf4jLogger(AAAClient.class)) .logLevel(Logger.Level.FULL) .target(AAAClient.class, url); } }   3. Test 코드 작성  정상적인 경우 일부러 실패를 했을 때의 서킷브레이커 open close 확인  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109  public class CBTest { @Rule public WireMockRule wireMockRule = new WireMockRule(); private AAAClient client; @Before public void setUp() { CircuitBreakerConfig config = CircuitBreakerConfig.custom() .failureRateThreshold(50) // 실패 임계치 50% 로 설정  .ringBufferSizeInClosedState(20) // 20번 시도  .ringBufferSizeInHalfOpenState(10) // 3초 후 10번 시도  .waitDurationInOpenState(Duration.ofSeconds(3L)) // Open 후 3초 기다림  .build(); CircuitBreaker circuitBreaker = CircuitBreaker.of(\u0026#34;AAAClientCB\u0026#34;, config); FeignDecorators decorators = FeignDecorators.builder().withCircuitBreaker(circuitBreaker).build(); aAAClient = Resilience4jFeign.builder(decorators) .client(new OkHttpClient()) .encoder(new JacksonEncoder()) .decoder(new JacksonDecoder()) .options(new Request.Options(3000, 5000)) .retryer(Retryer.NEVER_RETRY) .logger(new Slf4jLogger(AAAClient.class)) .logLevel(Logger.Level.FULL) .target(AAAClient.class, \u0026#34;http://localhost:8080\u0026#34;); } @Test public void 정상인경우_Test() { stubFor( get(urlPathMatching(\u0026#34;/1\u0026#34;)) .willReturn( aResponse() .withStatus(200) .withHeader(\u0026#34;content-type\u0026#34;, \u0026#34;application/json\u0026#34;) .withBody(\u0026#34;{}\u0026#34;) ) ); boolean allSuccess = IntStream.range(0, 40) .mapToObj(i -\u0026gt; Try.of(() -\u0026gt; client.getDetail(1))) .allMatch(t -\u0026gt; t.isSuccess()); assertThat(allSuccess).isTrue(); } @Test public void 서킷브레이커_Open_Close_Test() { stubFor( get(urlPathMatching(\u0026#34;/71\u0026#34;)) .willReturn( aResponse() .withStatus(200) .withHeader(\u0026#34;content-type\u0026#34;, \u0026#34;application/json\u0026#34;) .withBody(\u0026#34;{}\u0026#34;) ) ); stubFor( get(urlPathMatching(\u0026#34;/72\u0026#34;)) .willReturn( aResponse() .withStatus(500) .withHeader(\u0026#34;content-type\u0026#34;, \u0026#34;application/json\u0026#34;) .withBody(\u0026#34;{}\u0026#34;) ) ); // 에러 비율 50% 이상  IntStream.range(0, 10).forEach(i -\u0026gt; Try.of(() -\u0026gt; client.getDetail(72))); // 3초간 오픈 상태에서 바로 에러  sleep(1000); Try\u0026lt;ApiResponse\u0026gt; failFast1 = Try.of(() -\u0026gt; client.getDetail(71)); sleep(1500); Try\u0026lt;ApiResponse\u0026gt; failFast2 = Try.of(() -\u0026gt; client.getDetail(71)); // 3초 후 반 오픈  sleep(1000); Try.of(() -\u0026gt; client.getDetail(71)); Try\u0026lt;ApiResponse\u0026gt; realEx = Try.of(() -\u0026gt; client.getDetail(72));// 1개 실패로는 50% 비율 안 됨  // 반 오픈 후 다시 열리지 않으면 모두 성공  boolean allSuccess = IntStream.range(0, 40) .mapToObj(i -\u0026gt; Try.of(() -\u0026gt; client.getDetail(71))) .allMatch(t -\u0026gt; t.isSuccess()); SoftAssertions.assertSoftly(softly -\u0026gt; { softly.assertThat(failFast1.getCause()).isInstanceOf(CallNotPermittedException.class); softly.assertThat(failFast2.getCause()).isInstanceOf(CallNotPermittedException.class); softly.assertThat(realEx.getCause()).isNotInstanceOf(CallNotPermittedException.class); softly.assertThat(allSuccess).isTrue(); }); } private void sleep(int sleepTime) { try { Thread.sleep(sleepTime); } catch (InterruptedException e) { } } }    SoftAssertions은 각 assertThat 이 실패해도 검증을 계속 실행하고 마지막에 결과를 한꺼번에 보여줌  (마지막에 softly.assertAll() 추가)   softly.assertAll() 을 사용하지 않을 경우에 대해선 AssertJ 의 Collect all errors with soft assertions 부분 참조  "
},
{
	"uri": "https://ysjune.github.io/posts/java/handlermethodargumentresolver/",
	"title": "HandlerMethodArgumentResolver 사용",
	"tags": [],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "이전에 회사에서 다른 프로젝트 소스를 보다가 http 헤더에서 보낸 정보를 controller 단에서 바로 vo 로 매핑해주는 코드를 발견했다.\n당시에 이거 꽤 유용하게 쓸 수 있겠네. 하고 지나가기만 했었는데, 이번에 기회가 생겼다.\n목표  클라이언트의 IP 를 컨트롤러 단에서 바로 받아서 처리하고자 함.  1. ClientInfo 생성 1 2 3 4 5 6  @Data @NoArgsConstructor @AllArgsConstructor public class ClientInfo { private String clientIp; }    바인딩될 객체를 생성  2. ClientResolver 어노테이션 생성 1 2 3 4  @Target(ElementType.PARAMETER) @Retention(RetentionPolicy.RUNTIME) public @interface ClientResolver { }   3. ClientHandlerMethodArgumentResolver 생성 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  public class ClientHandlerMethodArgumentResolver implements HandlerMethodArgumentResolver { @Override public boolean supportsParameter(final MethodParameter methodParameter) { return methodParameter.getParameterType().equals(ClientInfo.class); } @Override public Object resolveArgument(final MethodParameter methodParameter, final ModelAndViewContainer modelAndViewContainer, final NativeWebRequest nativeWebRequest, final WebDataBinderFactory webDataBinderFactory) throws Exception { ClientInfo clientInfo = new ClientInfo(clientIp(nativeWebRequest)); return clientInfo; } private String clientIp(final NativeWebRequest request) { String clientIp = request.getHeader(\u0026#34;X-Forwarded-For\u0026#34;); if (StringUtils.isEmpty(clientIp) || \u0026#34;unknown\u0026#34;.equalsIgnoreCase(clientIp)) { clientIp = request.getHeader(\u0026#34;Proxy-Client-IP\u0026#34;); } if (StringUtils.isEmpty(clientIp) || \u0026#34;unknown\u0026#34;.equalsIgnoreCase(clientIp)) { clientIp = request.getHeader(\u0026#34;WL-Proxy-Client-IP\u0026#34;); } if (StringUtils.isEmpty(clientIp) || \u0026#34;unknown\u0026#34;.equalsIgnoreCase(clientIp)) { clientIp = request.getHeader(\u0026#34;HTTP_CLIENT_IP\u0026#34;); } if (StringUtils.isEmpty(clientIp) || \u0026#34;unknown\u0026#34;.equalsIgnoreCase(clientIp)) { clientIp = request.getHeader(\u0026#34;HTTP_X_FORWARDED_FOR\u0026#34;); } if (StringUtils.isEmpty(clientIp) || \u0026#34;unknown\u0026#34;.equalsIgnoreCase(clientIp)) { HttpServletRequest nativeRequest = (HttpServletRequest) request.getNativeRequest(); clientIp = nativeRequest.getRemoteAddr(); } return clientIp; } }    supportsParameter 는 현재 파라미터를 resolver이 지원하는지에 대한 boolean resolveArgument 는 바인딩할 객체  4. resolver 등록 1 2 3 4 5 6 7 8 9 10  @Configuration public class WebMvcCustomConfiguration extends WebMvcConfigurerAdapter { ... @Override public void addArgumentResolvers(final List\u0026lt;HandlerMethodArgumentResolver\u0026gt; argumentResolvers) { argumentResolvers.add(new ClientHandlerMethodArgumentResolver()); } }    스프링4.x 를 사용하고 있어서 WebMvcConfigurerAdapter 를 상속받아 사용한 것 같지만,\nspring boot 에서는 WebMvcConfigurer 을 구현해주면 되는 것 같다.  1 2 3 4 5 6 7 8 9 10 11  @Configuration public class WebConfig implements WebMvcConfigurer { @Autowired private ClientHandlerMethodArgumentResolver clientHandlerMethodArgumentResolver; @Override public void addArgumentResolvers(List\u0026lt;HandlerMethodArgumentResolver\u0026gt; argumentResolvers) { argumentResolvers.add(clientHandlerMethodArgumentResolver); } }   5. Controller 생성 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  @Controller public class IntroCreationController { private final IntroCreationService introCreationService; @Autowired public IntroCreationController(IntroCreationService introCreationService) { this.introCreationService = introCreationService; } @RequestMapping(value = \u0026#34;/api/save/intro\u0026#34;, method = RequestMethod.POST) public ApiResponse createIntro(@RequestBody IntroCreationRequest request, @ClientResolver ClientInfo clientInfo) { ApiResponse apiResponse; try { AdminIntroData intro = introCreationService.createIntro(request, clientInfo); apiResponse = ApiResponse.success(intro); } catch (Exception e) { apiResponse = ApiResponse.fail(e.getMessage()); } return apiResponse; } }    컨트롤러 매소드의 파라미터에 커스텀 어노테이션을 사용하면 된다.  "
},
{
	"uri": "https://ysjune.github.io/posts/java/wiremock/",
	"title": "WireMock 사용",
	"tags": [],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "순서가 어긋난 감이 있긴 하지만, 지난 번 API 통신을 위해 Feign 을 사용했었는데,\n테스트를 진행할 때 실제로 API 접속을 할 수는 없으니 Mock Web 서버를 만드는 기술인 WireMock 를 사용한 내용을 올리고자 한다.\nWireMock 이란?  HTTP-based API를 위한 시뮬레이터 Mock 으로 만드는 웹서버 http://wiremock.org/  1. 의존성 추가  Maven 을 사용하므로 pom.xml 에 의존성 추가  1 2 3 4 5 6 7  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.tomakehurst\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;wiremock-jre8\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.24.1\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt;   2. 테스트 코드 작성 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  public class Test { @Rule public WireMockRule wireMockRule = new WireMockRule(8089); // 작성하지 않을 경우 default 8080  private BoardServiceService service; ... @Test public void 목록_test() { StubMapping accept = stubFor( get(urlPathMatching(\u0026#34;/board/([a-zA-Z0-9/-]*)\u0026#34;)) // board/71 같은 걸 찾기 위해 정규표현식 사용  .willReturn(aResponse() .withStatus(200) .withHeader(\u0026#34;content-type\u0026#34;, \u0026#34;application/json\u0026#34;) .withBody(\u0026#34;Hello world!\u0026#34;) ) ); ApiResponse\u0026lt;Data\u0026gt; ret = service.getBoard(71); // 서비스에서 API 호출 (/board/71)  assertEquals(\u0026#34;200\u0026#34;, ret.getCode()); assertEquals(\u0026#34;OK\u0026#34;, ret.getMessage()); ... } }    Junit 을 지원하기에 좀 편하게 테스트할 수 있음. (5에서도 가능할 것 같긴한데\u0026hellip;) sample 은 간단하게 작성하였지만, 제공하는 기능들이 많다. (https, proxy, 상태저장 등) 좀 더 자세한 내용은 WireMock 페이지에서 확인 가능  "
},
{
	"uri": "https://ysjune.github.io/posts/setting/docker/mariadb_setting/",
	"title": "mariaDB 설치 (feat. Docker)",
	"tags": [],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "이상하게 맥에서 로컬 mysql 이든 mariadb든 다 제대로 설치가 안되서,\n주변에서 도커로 설치해보라는 얘기를 듣고\u0026hellip; 도커로 설치 진행 (현재 진행된 부분도 삽질을 많이 하면서 왔기 때문에.. 다시 설치할 경우 최소한 검색시간이라도 줄이기 위해 적어둔다)\n도커 설치  Mac : https://docs.docker.com/docker-for-mac/install/  mariadb OR mysql 설치  # mysql $ docker run --name mysql-db -p 3306:3306 -e MYSQL_ROOT_PASSWORD=secure -d mysql # mariadb $ docker run --name maria-db -p 3306:3306 -e MYSQL_ROOT_PASSWORD=secure -d mariadb  mariadb 도커 컨테이너 실행  docker container run -d -p 13306:3306 \\ -e MYSQL_ROOT_PASSWORD=root \\ -v /Users/Shared/data/mariadb:/var/lib/mysql \\ --name mariadb_local mariadb  볼륨 로컬에서 저장하는 건 처음에는 *-v pwd/wp_db:/var/lib/mysql * 뭐 이런식으로 하려고 했는데 맥에서 진행하니 권한이니 뭐니 나와서 빠르게 포기\n컨테이너 접속  # 도커에 있는 mysql 컨테이너 접근 docker exec -it mariadb_local bash # 접속방법 mysql -u root -p # 도커로그 보기 docker logs -f --tail=10 maria  컨데이너 접속했을 시 vi가 동작 안하면..  apt-get update apt-get install vim  ###127.0.0.1:3306 으로 접속이 안될 시 (포트 변경 방법알기 전까지 임시) \u0026ndash; https://stackoverflow.com/questions/46069446/unable-to-connect-to-mysql-container-with-sequel-pro-client\n"
},
{
	"uri": "https://ysjune.github.io/posts/setting/setress_test/ngrinder/",
	"title": "nGrinder 부하 테스트",
	"tags": [],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "nGrinder 란?  Stress Test Platform 테스트 스크립트 작성, 테스트 실행, 대상 서버 모니터링 및 결과 작성 nGrinder Github   nGrinder 구조  Controller : 테스팅을 위한 인터페이스 제공 (스크립트 작성 및 수정, 테스트 코디네이트) Agent : 타겟 서버에 부하를 가함 (프로세스, 스레드)   설치 방법 (1/2 컨트롤러 설치)  nGrinder Controller 파일 Tomcat 을 이용한 로컬 설치 방법  다운로드 받은 war 파일을 ${TOMCAT_HOME}/webapps 에 놓는다.  (Context-Path 를 변경하고 싶지 않을 경우 ROOT.war 로 파일명 변경)   catalina.sh 혹은 catalina.bat 파일에 라인 추가  JAVA_OPTS=\u0026quot;-Xms600m -Xmx1024m -XX:MaxPermSize=200m\u0026quot; # for catalina.sh set JAVA_OPTS=-Xms600m -Xmx1024m -XX:MaxPermSize=200m # for catalina.bat   톰캣 실행 (startup.sh 혹은 startup.bat) 브라우저 실행 (http://localhost:8080/ngrinder-controller-X.X)  (ROOT.war 로 한 경우 http://localhost:8080)       설치 방법 (2/2 에이전트 설치)  실행방법의 1. 로그인  을 진행 후, 2. 메인 화면 에서 진행  \n 다운로드 된 에이전트 파일을 압축 해제 후 run_agent.sh 혹은 run_agent.bat 실행  \n  Agent Management 에서 에이전트 확인\n  하나의 Agent 에서 Multi Agent 를 실행할 경우\n Controller 는 Ip 와 Host Id 의 조합으로 에이전트를 판별함  각각 다른 곳에 설치  1st : ~/apps/ngrinder_agent_1 2nd : ~/apps/ngrinder_agent_2   host 이름을 변경하여 각 에이전트 사용 (커멘트 라인 사용)  1st : cd ~/apps/ngrinder_agent-1; ./run_agent.sh \u0026ndash;agent-home ~/.ngrinde-agent-1 \u0026ndash;host-id first-agent 2nd : cd ~/apps/ngrinder_agent-1; ./run_agent.sh \u0026ndash;agent-home ~/.ngrinde-agent-2 \u0026ndash;host-id second-agent         Docker 를 이용한 가상 설치 방법 (추후 작성 예정)  \n실행 방법  1. 로그인 \n admin/admin 으로 로그인   2. 메인 화면 \n URL 을 입력하여 바로 테스트를 진행할 수 있음   3. 스크립트 \n 스크립트 목록이 나오며 Create a script 로 스크립트를 작성할 수 있음  \n Sample.groovy 파일을 만들어서 스크립트 작성 스크립트 파일은 Groovy 와 Jython, Groovy Maven Project 3가지 형태로 작성 가능 작성 샘플 파일은 Script Collection 참조   4. 테스트 작성 \n 상단에 Performance Test 선택 하면 테스트 목록이 나오며, Create Test 를 통해 테스트 생성  \n 테스트 이름, Agent 갯수, Vuser 갯수, Script 등을 설정  Vuser 란?  가상 사용자로 스레드에 매핑됨, 즉 1000개의 스레드가 있는 경우 1000명의 가상 사용자가 있음을 의미   Target Host  하나의 도메인에 여러 개의 아이피 혹은 포트가 지정되어 있는 경우(클러스터링) Domain 과 IP 를 적어줌.   Duration / Run Count  Duration : 테스트를 얼마나 진행할 것인지 Run Count : 테스트를 몇 번 진행할 것인지 (Ex. Run Count : 2, Vuser : 6, agent : 2 -\u0026gt; 262 = 24)   Enabled Ramp-Up  스레드 혹은 프로세스 수를 점진적으로 증가시키고 싶을 경우 사용      \n 테스트를 시작할 때 바로 시작하거나 스케쥴을 지정해서 시작할 수 있음   5. 테스트 진행 \n 테스트 진행 중  \n 테스트 완료 후 Detail Repoprt 를 통해 상세 리포트를 보거나 코멘트를 남길 수 있음   6. 테스트 리포트 \n  \n 테스트 리포트를 통해 상세한 내용을 볼 수 있으며, CSV 파일로 다운 받을 수도 있음  "
},
{
	"uri": "https://ysjune.github.io/posts/setting/apache_dev/apache/",
	"title": "아파치 설정",
	"tags": [],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "이번 개발 서버를 구성하면서 설정했던 것들을 까먹지 않도록 작성.\n목표 - QA 용 관리자 서버 구성 필요한 단계  톰캣 설정 아파치 설정 젠킨스 배포 설정 DNS 추가  1. 톰캣 설정 톰캣은 기본 설정의 톰캣 사용 따라서, bin, conf 내용만 수정\n conf 디렉토리에서 server.xml   기존에 있던 톰캣을 복사해서 그런지 conf 에서의 내용은 따로 수정한 것은 없으나, 한 서버에서 여러개의 톰캣을 돌린다면 server.xml 을 수정해줘야 할 필요가 있다.  port 부분을 고정하는 것이 아닌 ${tomcat.port.http} 같은 형식으로 변경    bin 디렉토리에서 tomcat.sh  server_name, tomcat_http_port 등의 설정 기입 JAVA_OPTS 추가 (보통 로컬에서 톰캣을 올릴 때 쓰는 옵션을 여기에 적는 것 같다. -Dspring.profiles.active 도 있는데 이건 배포 시점에 분리할 수 있지 않을까?) 설정을 추가하고, 실행 sh 파일을 모와놓은 곳에서 이 tomcat.sh 를 불러오도록 설정해줘야 함.    2. 아파치 설정  httpd.conf 파일 수정  각 conf 파일과 ssl.conf 파일이 각각 있으므로 각 conf 파일에 설정 추가     conf 파일   \u0026lt;VirtualHost *:80\u0026gt; ServerName '사용할 DNS 명' DocumentRoot '데이터 파일 경로'  ssl.conf 파일   \u0026lt;VirtualHost *:443\u0026gt; ServerName '사용할 DNS 명' DocumentRoot '데이터 파일 경로' ssl.conf 는 말 그대로 ssl 으로 관련 추가 설정이 있으면 추가\nworkers.properties 수정  로드 밸런서를 위해 추가     worker.list = qa worker.QAServer.reference=worker.template worker.QAServer.host=127.0.0.1 worker.QAServer.port=6609 # configuration loadbalancer worker.qa.type=lb worker.qa.retries=2 worker.qa.method=Session worker.qa.sticky_session=true worker.qa.max_reply_timeouts=300 worker.qa.balance_workers=QAServer uriworkermap.properties 추가   /*.jsp=qa /*.java=qa /*.do=qa workers.properties 에 balance_workers 를 찾아가는 것 같다. ex) uriworkermap_QAServer.properties\n아파치 재실행  설정을 해줬으므로 \u0026gt; ./apachectl restart 를 통해 재실행 (아마 설정에서 만들어준 DocumentRoot 가 없으면 에러가 떳던 것으로 기억.. 디렉토리를 만들어 주고 재실행..)    3. 젠킨스 배포 설정  젠킨스로 자동 빌드를 하기 전에 서버 설정이 제대로 맞는지 확인을 함.  로컬에서 war 파일로 묶은 다음 서버에서 압축 해제 후 톰캣 실행 ex) /data/was/QAServer 에는 소스 data/web/QAServer 에는 리소스 제대로 올라오는 지 확인   젠킨스 아이템 만들고 파이프라인 설정  Pipeline Script From SCM 을 선택 SCM 에 git 정보 입력 Script Path 에 Jenkinsfile 입력 ex) dev_QA.Jenkinsfile   젠킨스 파일에 각종 설정을 입력 (이 부분은 shell script 영역 같은데\u0026hellip;.)  4. DNS 추가 톰캣도 올리고, 아파치 설정도 했고, 젠킨스로 배포 자동화도 했음.\n그러나, DNS 세팅을 안해서 접속할 때 ip 를 입력해서 들어가야 함.\nDNS 를 추가하자.\n 윈도우의 경우 C:\\Windows\\System32\\drivers\\etc 에 hosts 파일에 추가 ex) 111.111.11.111 dev.qaserver.com 인터넷을 찾아보면 리눅스의 hosts 파일을 변경해주면 된다고 하는데, 회사의 SE 분이 서버 hosts 는 막 수정하는 거 아니래서 로컬에서 적용(이 부분은 이유를 들었는데, 까먹음..)  회사에서 개발서버를 구축하면 이렇게 하면 되는 것 같다.\n장소나 환경에 따라 어느정도의 차이는 있겠지만, 참고해서 진행하면 되겠지\u0026hellip;?\n"
},
{
	"uri": "https://ysjune.github.io/categories/%ED%99%98%EA%B2%BD-%EC%84%A4%EC%A0%95/",
	"title": "환경 설정",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ysjune.github.io/posts/interview/hashtable-vs-hashmap/",
	"title": "HashTable vs HashMap",
	"tags": [],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "HashTable VS HashMap  메모리 내에 key/value 짝으로 되어있는 데이터이다. 두 데이터 타입의 차이점을 알아보고자 한다.  1. 비슷한 점  추가, 삭제, 접근이 비슷하다.    get() : 키를 통해 아이템 검색 remove() : 키를 통해 삭제 put() : 아이템을 추가    java.util 패키지 내에 속해있다.   2. 다른 점  두 데이터 타입은 매우 많은 다른 점이 존재하지만, 주된 것 몇 가지만 알아보자    HashTable 의 경우 암묵적으로 동기화되어 멀티 스레드 환경에서 동작하기 용이하다.  엑세스 시 스레드는 HashTable 을 락해 다른 스레드가 동시에 변경하는 것을 방지한다.  반대로 HashMap 의 경우에는 단일 스레드 환경에서 적합하다. 만약 멀티 스레드 환경에서 HashMap 을 사용하고자 한다면  ConcurrentHashMap 을 사용할 수 있다.    HashTable 의 경우 단일 스레드 환경에서도 각 메소드 호출할 때 암묵적으로 동기화를 하기 때문에 HashMap 보다 느리다.    HashMap 은 Null 을 저장할 수 있지만, HashTable 은 저장할 수 없다.    HashMap 의 경우 fail-fast 로 고려되어지는 Iterator 을 사용할 수 있다. 즉, iterator 하고 있는 도중에  다른 스레드가 Map 을 변경할 경우 ConcurrentModificationException 을 던진다. 하지만, HashTable 의 경우 fail-fast 가 아닌 Enumerator 로 순회한다.    HashMap 의 경우 LinkedHashMap 과 TreeMap 을 구현함으로써 정렬이 가능하지만, HashTable 은 그렇지 못하다.    결국 HashTable 은 deprecate 되거나 공식적으로 ConcurrentHashMap 으로 대체된다고 합니다.  HashTable 의 경우 좀 생소했습니다. ConcurrentHashMap 은 사용해본 적이 있지만요.  어찌보면 차이점은 동기화 라고 볼 수도 있을 것 같은데, 그것도 ConcurrentHashMap 이 나오면서 해결이 된 느낌이네요. 그러면 드는 생각은 HashTable vs ConcurrentHashMap 인데요. 이 부분도 나중에 찾아봐야겠군요.  [출처] - https://www.programmergate.com/hashtable-vs-hashmap/\n"
},
{
	"uri": "https://ysjune.github.io/categories/%EB%A9%B4%EC%A0%91%EC%A4%80%EB%B9%84/",
	"title": "면접준비",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ysjune.github.io/posts/interview/class-vs-instance/",
	"title": "클래스 vs 인스턴스",
	"tags": [],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "클래스 vs 인스턴스 정말 흔하게 쓰는 단어이고, 사용도 할 줄 알지만 항상 그렇듯, 남에게 제대로 설명하지 못하면 결국은 도루묵이기에.. 이번 기회에 간단하게나마 정리해보고자 한다.\n1. 클래스 클래스는 데이터와 로직을 묶어서 누구나 동일한 기능을 사용할 수 있게 하고, 누구나 필요한 자기만의 데이터를 보관하기 위해서 스펙을 결정해둔 것을 의미. 예를 들어 MP3 라면 곡 데이터는 전부 다르지만, 음악 감상 기능은 모든 MP3 가 동일한 기능이 지원되는 것\n여기서 데이터는 변수, 로직은 메소드가 되겠다.\n 클래스는 연관되어 있는 변수와 메소드의 집합이다.\n 2. 인스턴스 클래스라는 일종의 설계도를 통해 제품을 만드는데, 이 제품을 인스턴스라고 한다.  예를 들면 MP3 myMp3 = new MP3(); 에서 myMp3 가 인스턴스가 된다.\n번외. 객체 클래스와 인스턴스는 설계도와 제품이라고 볼 수 있는데, 그러면 객체는 클래스일까 인스턴스일까?  이 글을 쓰면서 두 군데를 참고하면서 쓰고 있는데, 내용이 비슷하면서도 다르다고 할까? (포함관계적인 의미에서?)  우선 열혈강의 책에서는 \u0026ldquo;객체지향 프로그래밍에서 인스턴스라는 말과 객체라는 용어는 같은 의미로, 어떤 틀의 역할을 하는 클래스에서 나온 복사본의 존재를 의미합니다.\u0026rdquo;  이고, 생활 코딩에서는 \u0026ldquo;일반적으로 설계도인 클래스가 구체적인 실체인 인스턴스가 되었을 때 객체라고 부른다. 보통은 구체적인 코드 상에서 나타나는 객체를 인스턴스라 부르고, 로직을 설계할 때 나타나는 인스턴스를 객체라고 부른다. 또는 클래스, 인스턴스의 구분 없이 포괄적으로 객체라는 말을 쓰기도 한다.\u0026rdquo;  단어를 사용함에있어 따로 의식은 하지 않았지만, 인스턴스라는 용어는 잘 사용을 안했고, 주로 클래스, 객체 이렇게 사용을 했었네요.\n번외2. 변수 변수는 상태라고도 표현합니다.  상태라고 배웠기도 했습니다. 하지만, \u0026lsquo;속성\u0026rsquo; 이라는 말을 더 많이 썼기에 속성이 익숙했고, 현업을 하면서 \u0026ldquo;**는 상태를 가지고 있어서 관리하기 힘들어\u0026rdquo; 라는 말을 들었을 때 상태가 대체 뭐지? 하면서 엄청 헤맸던 기억이 있네요. 그래서 이 기회에 한 번 더 써봤습니다.\n\n 참고  생활코딩 : https://opentutorials.org/course/1223/5400 열혈강의 객체 중심 Java    "
},
{
	"uri": "https://ysjune.github.io/posts/clean-code/chapter1/",
	"title": "1. 깨끗한 코드",
	"tags": [],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "1. 깨끗한 코드 코드가 존재하리라 어느 수준에 이르면 코드의 도움 없이 요구사항을 상세하게 표현하기란 불가능 하기에 코드가 사라질 가망은 없다.  궁극적으로 코드는 요구사항을 표현하는 언어라는 사실을 명심 \n나쁜코드 나쁜 코드에 발목이 잡혀 고생한 기억은 많다. 실제로 고행이라는 이름도 있다. 어째서 나쁜 코드를 짰는가? -\u0026gt; 당장 급해서, 서두르느라 자신이 짠 쓰레기 코드를 쳐다보며 나중에 고쳐야겠다고 생각한다. But, 나중은 오지 않는다. (르블랑의 법칙) \n나쁜 코드로 치르는 대가 나쁜 코드는 개발 속도를 크게 떨어뜨린다. -\u0026gt; 코드를 고칠 때마다 엉뚱한 곳에서 문제가 생기기 때문 -\u0026gt;  결국 생산성이 0에 수렴 -\u0026gt; 재설계를 시작 -\u0026gt;  기존의 것을 100% 수용하지 않으면 관리층에서는 대체하려고 하지 않을 것이고,  오래 지속되다보면 이탈 맴버가 생겨 흐지부지하게 된다. \nConclusion.  시간을 들여 깨끗한 코드를 만드는 노력이 비용을 절감하는 방법이며, 전문가로서 살아남는 길 \n태도 우리는 프로다. 나쁜 코드의 위험을 이해하지 못하는 관리자 말을 그대로 따르는 행동은 전문가(프로)답지 못하다. \n원초적 난제 빨리 가려고 나쁜 코드를 양상하는 경우가 있다. 하지만 이는 잘못된 판단으로 빨리가는 유일한 방법은 언제나 코드를 깨끗하게 유지하는 습관이다. \n깨끗한 코드라는 예술? 깨끗한 코드와 나쁜 코드를 구분할 줄 안다고 깨끗한 코드를 작성할 줄 안다는 뜻은 아니다. 열쇠는 코드 감각이다. \u0026lsquo;코드 감각'이 없는 프로그래머도 나쁜 모듈을 알아보긴 하지만 거기서 끝이다. \n우리는 저자다 Javadoc 에서 @author 필드는 저자를 소개 저자는 독자와 잘 소통할 책임이 있다. 코드를 읽는 시간 대 코드를 짜는 시간 비율이 10 대 1을 훌쩍 넘는다. 우리는 끊임없이 코드를 읽는다. 그렇기에 읽기 쉬운 코드를 짜야 한다. \n보이스카우드 규칙 캠프장은 처음 왔을 때보다 더 깨끗하게 해놓고 떠나라 \n결론 예술에 대한 책을 읽는다고 예술가가 된다는 보장은 없다. 책은 단지 다른 예술가가 사용하는 도구와 기법, 그리고 생각하는 방식을 소개할 뿐이다. 이 책을 어떻게 활용할지는 독자에게 달렸다. \n사견을 덧붙이자면..? 돌아보면 항상.. 안되는 것보단 굴러가는 쓰레기라도 만든다는 느낌으로 일단 구현을 우선했던 것 같다. 물론, 만들면서 더 좋은 건 없을까 고민은 했지..만 잠깐일 뿐이다. 구현을 다 하면 다른 거 하기 바쁜 그런 생활을 보냈던 것 같다. 그리고 \u0026lsquo;코드 감각\u0026rsquo; 이라는 얘기가 나오는데, 이 부분은 리펙토링 책에 나오는 \u0026lsquo;냄새\u0026rsquo; 와 비슷하지 않은가 싶었다.  어느 정도 경험에 의해 생기는 그런..? 보이 스카우트 규칙이야 워낙 유명하니.. (남자고 군필자라면 다 알거다..) 마지막에 나오는 결론은 많은 생각을 하게 한다.\n 예술에 대한 책을 읽는다고 예술가가 된다는 보장은 없다.  클린 코드는 이전에 한 번 읽었었다. 읽을 때마다 이렇게 해야지 하는 마음은 생기는데, 막상 코드 앞에서의 나는 책의 내용을 많이 실천하지는 못하는 것 같다. 이번에는 읽은 챕터마다 정리를 할 예정이니 자주 보면서 많이 실천하려고 노력하지 않을까? 싶다 :)\n "
},
{
	"uri": "https://ysjune.github.io/posts/clean-code/chapter10/",
	"title": "10. 클래스",
	"tags": [],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "10. 클래스 클래스 체계 공개에서 비공개 형식으로 진행되어 추상화 단계가 순차적으로 내려간다.\n캡슐화 변수와 유틸리티 함수는 가능한 공개하지 않는 편이 낫지만 반드시 숨겨야 한다는 법칙도 없다.  테스트에서 사용한다면 protected 도 고려할만하다. 하지만, 그 전에 비공개 상태를 유지할 온갖 방법을 강구한다.  캡슐화를 풀어주는 결정은 언제나 최후의 수단이다.\n클래스는 작아야 한다. 클래스는 작아야 한다. 클래스를 설계할 때도 함수와 마찬가지로 \u0026lsquo;작게\u0026rsquo; 가 기본 규칙이다.  그렇다면 얼마나 작아야 할까? 함수는 물리적인 행 수로 크기를 측정했다.  클래스에서는 클래스가 맡은 책임을 센다.  클래스 이름은 해당 클래스 책임을 기술해야 한다.  실제로 작명은 클래스 크기를 줄이는 첫 번째 관문이다. 간결한 이름이 떠오르지 않는다면 필시 맡은 역할이 너무 많이 때문이다.\n단일 책임 원칙(SRP : Single Responsibility Principle) 클래스나 모듈을 변경할 이유가 하나, 단 하나뿐이어야 한다는 원칙이다.  책임, 즉 변경할 이유를 파악하려 애쓰다 보면 코드를 추상화하기도 쉬워진다. 더 좋은 추상화가 더 쉽게 떠오른다.  단일 책임 원칙은 설계자가 가장 무시하는 규칙중 하나이다.  소프트웨어를 돌아가게 만드는 활동과 소프트웨어를 깨끗하게 만드는 활동은 완전히 별개다.  우리는 주로 \u0026lsquo;깨끗한\u0026rsquo; 보다는 \u0026lsquo;돌아가는\u0026rsquo; 에 초점을 맞추기 때문이다.  물론 중요하긴 하지만, 문제는 돌아가는 데에서 끝낸다는 것이다. 다음 관심사인 깨끗한 에는 관심을 기울이지 않는다. 규모가 어느정도 되는 시스템은 논리가 많고 복잡하다.  이런 복잡성을 다루려면 체계적인 정리가 필수다.  그래야 개발자가 어디에 무엇이 있는지 쉽게 찾을 수 있고, 변경을 했을 때 직접적인 영향을 미치는 컴포넌트만 알아도 충분하다. 큰 클래스 몇 개로 이뤄진 것보다 작은 클래스 여럿으로 이뤄진 시스템이 훨씬 바람직하다\n응집도 클래스는 인스턴스 변수 수가 작아야 한다.  각 클래스 메서드는 클래스 인스턴스 변수를 하나 이상 사용해야 한다.  일반적으로 메서드가 변수를 더 많이 사용할수록 메서드와 클래스는 응집도가 더 높다.  \u0026lsquo;함수를 작게, 매개변수 목록을 짧게\u0026rsquo; 라는 전략을 따르다보면 때때로 몇몇 메서드 만이 사용하는 인스턴스 변수가 많아지는 경우가 생기는데,  이는 새로운 클래스로 쪼개야 한다는 신호다.  응집도를 유지하면 작은 클래스 여럿이 나온다.\n변경하기 쉬운 클래스 대다수 시스템은 지속적인 변경이 가해진다.  그리고 뭔가 변경할 때마다 시스템이 의도대로 동작하지 않을 위험이 따른다.  새 기능을 수정하거나 기존 기능을 변경할 때 건드릴 코드가 최소인 시스템 구조가 바람직하다.  이상적인 시스템이라면 새 기능을 추가할 때 시스템을 확장할 뿐 기존 코드를 변경하지는 않는다.\n변경으로부터 격리 요구사항은 변하기 마련이다. 따라서 코드도 변하기 마련이다.  객체 지향에서 구체적인 클래스는 상세한 구현을 포함하며 추상 클래스는 개념만 포함한다고 배웠다.  상세한 구현이 의존하는 클라이언트 클래스는 구현이 바뀌면 위험에 빠진다.  그렇기에 인터페이스와 추상 클래스를 사용해 구현에 미치는 영향을 격리한다.  시스템의 결합도를 낮추면 유연성과 재사용성도 더욱 높아진다.  결합도가 낮다는 소리는 각 시스템 요소가 다른 요소로부터 그리고 변경으로부터 잘 격리되어 있다는 의미다.  결합도를 최소로 줄이면 자연스럽게 또 다른 클래스 설계 원칙인  DIP (Dependency Inversion Principle) 를 따른 클래스가 나온다.  이 원칙은 상세한 구현이 아니라 추상화에 의존해야 한다는 원칙이다.\n사견을 덧붙이면\u0026hellip;? 이번 장은 직접 보여주는 코드가 많은 장이다. 살짝 고민을 하긴 했다. 코드를 넣을지 말지. 하지만, 이 정리를 할 때 \u0026lsquo;최대한 글 위주로 하자\u0026rsquo; 란 생각을 했기에..  서론은 넘어가고, 클래스를 작성할 때 항상 해당 클래스가 어디에 위치하면 좋을지, 이 클래스가 어느부분까지 역할을 맡아야 하는지 고민하는 나에겐  이번 단일책임원칙 은 고개를 끄덕이게 한다. 하지만, 아직까지 구현이 우선인 생활을 하는 나에겐 정리가 쉽진 않다.  그래도 어느정도 책으로 배운 예측 통해 평소에 조금조금씩 수정하는 마음가짐을 가져야겠지\n"
},
{
	"uri": "https://ysjune.github.io/posts/clean-code/chapter11/",
	"title": "11. 시스템",
	"tags": [],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "11. 시스템 시스템 제작과 시스템 사용을 분리하라 제작과 사용은 다르다.  체계적이고 탄탄한 시스템을 만들고 싶다면 흔히 쓰는 손쉬운 기법으로 무듈성을 깨서는 안된다. 설정 논리는 일반 실행 논리와 분리해야 모듈성이 높아진다.\nMain 분리 시스템 생성과 시스템 사용을 분리하는 한 가지 방법으로,  생성과 관련한 코드는 모두 main 이나 main 이 호출하는 모듈로 옮기고,  나머지 시스템은 모든 객체가 생성되었고 모든 의존성이 연결되었다고 가정한다.\n팩토리 때로는 객체가 생성되는 시점을 애플리케이션이 결정할 필요도 생긴다.  이럴 때는 추상 팩토리 패턴을 사용하여 결정은 애플리케이션이 하지만, 생성 코드는 애플리케이션이 모르게 할 수 있다.\n의존성 주입 제어의 역전(IoC) 기법을 사용하는데,  한 객체가 맡은 보조 책임을 새로운 객체에게 전적으로 떠넘기는 것.  새로운 객체는 넘겨받은 책임만 맡으므로 단일 책임 원칙을 지키게 된다.\n확장 처음부터 확장을 생각하여 들어가는 비용을 정당화하긴 어렵다.  (시골에 확장성을 고려해 처음부터 6차선 도로를 만든다면\u0026hellip;??)  \u0026lsquo;처음부터 올바르게\u0026rsquo; 시스템을 만들 수 있다는 믿음은 미신이다.  오늘은 주어진 사용자의 스토리에 맞게 구현을 하고, 내일은 새로운 스토리에 맞춰 조정하고 확장한다.\n횡단(cross-cutting) 관심사 EJB2 아키텍처는 일부 영역에서 관심사를 거의 완벽하게 분리한다.  예를 들어 트랜잭션, 보안, 일부 영속적인 동작은 소스 코드가 아닌 배치 기술자에서 정의,  영속성과 같은 관심사는 애플리케이션의 자연스럽게 객체 경계를 넘나든다.\n자바 프록시 자바 프록시는 단순한 상황에 적합, 개별 객체나 클래스에서 메서드 호출을 감싸는 경우가 좋은 예.\nAspectJ 관점 관심사를 관점을 분리하는 가장 강력한 도구는 AspectJ 언어이다.  AspectJ는 언어 차원에서 관점을 모듈화 구성으로 지원하는 자바 언어 확장이다.\n테스트 주도 시스템 아키텍처 구축 애플리케이션 도메인 논리를 POJO 로 작성할 수 있다면,  즉 코드 수준에서 아키텍처 관심사를 분리할 수 있다면, 진정한 테스트 주도 아키텍처 구축이 가능해진다.  프로젝트를 시작할 때는 일반적인 범위, 목표, 일정은 물론이고 결과로 내놓을 시스템의 일반적인 구조도 생각해야 한다.  하지만 변하는 환경에 대처해 진로를 변경할 능력도 반드시 유지해야 한다. \n  최선의 시스템 구조는 각기 POJO 객체로 구현되는 모듈화된 관심사 영역(도메인) 으로 구성된다.  이렇게 서로 다른 영역을 해당 영역 코드에 최소한의 영향을 미치는 관점이나 유사한 도구를 사용해 통합한다.  이런 구조 역시 코드와 마찬가지로 테스트 주도 기법을 적용할 수 있다.\n  의사 결정을 최적화하라 가능한 마지막 순간까지 결정을 미루는 방법이 최선이다.  최대한 정보를 모아 최선의 결정을 내리기 위함\n명백한 가치가 있을 때 표준을 현명하게 사용하라 표준을 사용하면 재사용성이 증가하고, 캡슐화 하기 쉽다는 장점이 있겠지만,  때로는 표준을 만드는 시간이 너무 오래 걸리는 (배보다 배꼽이 더 큰) 케이스도 있다.\n결론 시스템은 깨끗해야된다. 그렇지 못한 시스템은 도메인 논리를 흐리며 기민성을 떨어뜨린다.  시스템을 설계하든 개별 모듈을 설계하든, 실제로 돌아가는 가장 단순한 수단을 사용해야 한다는 사실을 명심하자.\n사견을 덧붙이면\u0026hellip;? 음\u0026hellip; 이번 챕터는 굉장히 자바스럽다. 아니, 스프링 스럽다? 라고 해야하나?  뭐하튼, 그렇다. 깨끗한 구조를 설명하고 있긴 하지만, 마치 스프링의 역사를 보는 느낌? (EJB1,2,3 에 대한 얘기가 나오고, 스프링 프레임워크의 등장에 대한 얘기가 나온다.)  그런 느낌으로 읽었다. 내가 스프링 개념이 빈약해서 그런지..(..) 쉽게 이해가 안되는 부분도 있고, 쉽게 읽히지는 않았다.  중간에 보면 확장 에 관련된 얘기가 나온다. 이 부분에 관해서인데,  이전에 사수가 있었을 때, 서로 추구랄까? 스타일이랄까? 그런게 꽤 달랐다.  사수는 빨리 만들고 빨리 버리자 (일종의 빠른 프로토 타이핑으로 일단 만들고 돌려봐서 확장을 고려하자) 였고,  난 기능을 만들되 최대한 확장성을 고려하여 진행하자. 였다.  그러다보니 속도? 그런 건 말할 것도 없고 ㅋㅋㅋㅋ, 그 후 사수랑 얘기를 하는데, 본인도 처음에는 나와 비슷한 스타일이었다고 한다.  그런데 기획이 하도 바뀌니까 빨리 대충 만들고, 리펙토링을 중점으로 하게 되었다고\u0026hellip;  근데 요즘 보면 이 말이 참 맞는 것 같다. 기획이 참 잘 바뀌여\u0026hellip; 에자일도 아닌데 말이지..\n"
},
{
	"uri": "https://ysjune.github.io/posts/clean-code/chapter12/",
	"title": "12. 창발성",
	"tags": [],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "12. 창발성 창발적 설계로 깔끔한 코드를 구현하자  켄트 벡이 제시한 단순한 설계 규칙 4가지    모든 테스트를 실행하라 무엇보다도 먼저 설계는 의도한 대로 돌아가는 시스템을 내놓아야 한다.  테스트가 불가능한 시스템은 검증도 불가능하며, 검증이 불가능한 시스템은 출시하면 안된다고 생각한다.  테스트 케이스를 만들고 계속 돌려라 라는 단순한 규칙을 따르면 시스템은 낮은 결함도와 높은 응집력이라는,  객체 지향 방법론이 지향하는 목표를 저절로 달성한다.\n  중복을 없애라 우수한 설계에서 중복은 커다란 적이다.  똑같은 코드는 당연히 중복이고, 비슷한 코드는 더 비슷하게 고쳐주면 리펙토링이 쉬워진다.  구현 중복도 중복의 한 형태이다. 소규모 재사용은 시스템 복잡도를 극적으로 줄여주고, 추후 대규모 재사용을 가능토록 한다.\n  프로그래머 의도를 표현한다 자신이 이해하는 코드를 짜기는 쉽다. 코드를 짜는 동안에는 문제에 푹 빠져 코드를 구석구석 이해하니까.  하지만, 나중에 코드를 유지보수할 사람이 코드를 짜는 사람만큼이나 문제를 깊이 이해할 가능성은 희박하다.  우선, 좋은 이름을 선택한다. 이름과 기능이 딴판인 클래스나 함수는 안되겠다.  둘째, 함수와 클래스 크기를 가능한 줄인다.  셋째, 표준 명칭을 사용한다. 예를 들어 디자인 패턴은 의사소통과 표현력 강화가 주요 목적이다.  패턴을 사용할 경우 패턴명을 넣어주면 더 편하다. 하지만, 표현력을 높이는 가장 중요한 방법은 노력이다.  흔히 코드만 돌린 후 다음 문제로 직행하는 사례가 비일비재한데, 나중을 위해 조금이라도 쉽게 표현하려는 고민이 필요하다.  나중 읽는 사람이 나 자신이 될 수도 있다.\n  클래스와 매서드 수를 최소로 줄인다. SRP 를 극도로 준수하면 득보다 실이 더 많아진다.  이 규칙은 \u0026lsquo;가능한\u0026rsquo; 줄이라고 제안한다. 목표는 함수와 클래스 크기를 작게 유지하면서 동시에 시스템 크기도 작게 유지하는 데에 있다.  하지만, 이 규칙은 4가지 규칙 중 우선순위가 가장 낮다, 즉 클래스와 함수 수를 줄이는 작업은 중요하지만,  테스트 케이스를 만들고 중복을 제거하고 의도를 표현하는 작업이 더 중요하다는 의미이다.\n  결론을 덧붙이면\u0026hellip;? 우선\u0026hellip; 어려운 창발이 무슨 뜻인지부터 보자.\n 창발(創發, Emergence)또는 떠오름 현상은 하위 계층(구성 요소)에는 없는 특성이나 행동이 상위 계층(전체 구조)에서 자발적으로 돌연히 출현하는 현상이다. \u0026ndash; 위키백과\n 뜻을 봐도 잘 모르겠다. 예전에 영어로는 나타난다. 이런 뜻으로 외웠던 거 같은데..  나타난다 로 생각하면 클린 코드는 위의 4가지 규칙을 통해 나타난다 (emergence) 정도가 되려나??  뭐하튼.. 이번 내용은 짧다. 하지만, 내용은 핵심적이다.  테스트 케이스를 작성 -\u0026gt; 리펙토링  현재 회사에 와서 처음에는 CMS 를 포팅(spring -\u0026gt; spring boot, angularJS -\u0026gt; Angular) 할 때는 테스트 케이스도 만들고 재밌었다.  하지만, 요즘은 기능 추가 혹은 수정 건도 없고, 두서 없는 작업 지시에, 외주가 정말.. 개판으로 짜놓은 화면 소스를 유지보수 하고 있다.  어리광 부리는 거 아니냐? 라고 할 수도 있겠지만 너무 재미가 없다.  그래서 재미좀 찾아보려고 책도 보고 정리도 하면서 하고있긴 하지만..  아니다. 어느덧 책도 5장 정도 밖에 안 남았다. (부록에 나와 있는 부분은 따로 정리를 안하려고 한다. 그냥 편하게 읽고 넘어갈까 하지만, 변심이 생겨 주말에 정리할지도\u0026hellip;?)  일단, 이 책을 다 정리하면 다음에는 어떤 책을 정리할까 고민이긴 하다.\n"
},
{
	"uri": "https://ysjune.github.io/posts/clean-code/chapter13/",
	"title": "13. 동시성",
	"tags": [],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "13. 동시성 동시성이 필요한 이유? 동시성은 커플링(결합)을 없애는 전략이다, 즉 무엇과 언제를 분리하는 전략이다  단일 스레드의 경우 호출 스택을 살펴보면 프로그램 상태가 곧바로 드러난다.  응답 시간과 작업 처리량 혹은 한 번에 한 사람만 처리하는 경우, 정보를 대량으로 분석하는 경우, 이런 경우를 위해 동시성이 필요하다 할 수 있다.\n미신과 오해   동시성은 성능을 높여준다 (때때로 높여준다, 각 스레드가 독립적인 행동을 취할 때) 동시성을 구현해도 설계가 바뀌지 않는다 (단일과 다중 스레드 시스템은 설계가 판이하게 다름) 웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다 (오히려 더 알아야 한다. 동시 수정, 데드락 등을 피하기 위해)   타당한 생각   동시성은 다소 부하를 유발한다 (성능 측면에서 부하가 걸리며, 코드도 더 짜야됨) 동시성은 복잡하다. 동시성 버그는 재현이 어렵다 (그렇기에 일회성 문제로 여겨 무시되는 경우가 생김) 동시성을 구현하려면 근본적인 설계 전략을 재고해야 됨   난관 두 스레드가 있을 때 두 스레드가 자바 코드 한 줄을 거쳐가는 경로는 수 없이 많다.  대부분 올바른 결과를 내놓지만, 일부가 잘못된 결과를 내놓고, 이 경우가 드물다 \n동시성 방어 원칙  단일 책임 원칙 동시성은 복잡성 하나만으로 충분히 분리할만한 가치가 있으며, 동시성을 구현할 때는 다음을 고려한다.    동시성 코드는 독자적인 개발, 변경, 조율 주기가 있다. 독자적인 난관이 있으며, 다른 코드에서 겪는 난관과는 난이도가 다르다. 잘못 구현된 코드는 별의 별 방식으로 실패한다.   권장사항 : 동시성 코드는 다른 코드와 분리하라. \n따름 정리 : 자료 범위를 제한하라 두 스레드가 공유하는 영역을 synchronized 키워드로 보호한다. 이런 임계영역의 수는 줄여야 하고, 공유 영역이 많아질 수록 다음 가능성도 커진다    보호할 임계영역을 빼먹어서 공유 자료를 수정하는 모든 코드를 망가뜨린다. 모든 임계영역을 보호했는지 확인하느라 똑같은 노력과 수고를 반복한다. 찾아내기 어려운 버그가 더 찾기 어려워진다.   권장 사항 : 자료를 캡술화 하고, 공유 자료를 최대한 줄여라\n 따름 정리 : 자료 사본을 사용하라 공유 자료를 줄이려면 처음부터 공유하지 않는 방법이 최상이다. 이럴 경우 원본은 두고 사본을 사용하는 방법이 있는데  객체를 복사하는 시간이 걸린다면 테스트를 통해 측정해본다. 하지만 사본으로 동기화를 피할 수 있다면 내부 잠금을 없애 절약한 수행 시간이  사본 생성과 가비지 컬렉션에 드는 부하를 상쇄할 가능성이 크다.\n  따름 정리 : 스레드는 가능한 독립적으로 구현하라 다른 스레드와 자료를 공유하지 않는다. 각 스레드는 클라이언트 요청 하나를 처리한다. 그러면 각 스레드는 세상에 자신만 있는 듯이 돌아갈 수 있다.\n  권장 사항 : 독자적인 스레드로, 가능하면 다른 프로세서에서 돌려도 괜찮도록 자료를 독립적인 단위로 분할하라.\n실행 모델을 이해하라   생산자 - 소비자 생산자 스레드는 대기열에 정보를 채운 다음 소비자 스레드에게 \u0026ldquo;대기열에 정보가 있다\u0026quot;는 시그널을 보낸다. 소비자 스레드는 대기열에서 정보를 읽어들인 후 \u0026ldquo;대기열에 빈 공간이 있다\u0026rdquo; 는 시그널을 보낸다. 따라서 잘못하면 생산자 스레드와 소비자 스레드가 둘 다 진행 가능함에도 불구하고 동시에 서로에게서 시그널을 기다릴 가능성이 존재한다.\n  읽기 - 쓰기 읽기 스레드의 요구와 쓰기 스레드의 요구를 적절히 만족시켜 처리율도 적당히 높고 기아도 방지하는 해법이 필요. 간단한 방법은 읽기가 없을 때까지 쓰기가 기다리는 방법이지만, 읽기가 지속될 경우 쓰기가 기아 상태에 걸린다.  반대로 쓰기 가 우선이 되면, 처리율이 떨어진다.\n  식사하는 철학자들 둥근 식탁에 철학자들이 앉아있고 각 철학자 왼쪽에는 포크가 있으며, 철학자는 스파게티를 먹을 때 양손을 사용.  철학자를 스레드로 포크를 자원으로 바꿔 생각해보라. 여러 프로세스가 자원을 얻으러 경쟁하기에, 주의해서 설계하지 않으면 데드락, 라이브락, 처리율 저하, 효율성 저하등을 겪는다.\n  권장 사항 : 설명한 3가지와 관련된 알고리즘과 각 해법을 이해해라\n동기화하는 메소드 사이에 존재하는 의존성을 이해하라 자바에서는 동기화를 위해 synchronized 를 지원하지만 공유 클래스 하나에 동기화된 메소드가 여럿이라면 구현이 올바른지 다시 한 번 확인해야된다.\n권장 사항 : 공유 객체 하나에는 메소드 하나만 사용하라\n하지만, 공유 객체 하나에 여러 메소드가 필요한 상황도 있다.\n 클라이언트에서 잠금 : 클라이언트에서 첫 번째 메소드를 호출하기 전에 서버를 잠그고, 마지막 메소드를 호출할 때까지 유지한다. 서버에서 잠금 : 서버에 \u0026ldquo;서버를 잠그고 모든 메소드를 호출한 후 잠금을 해제\u0026quot;하는 메소드를 생성, 클라이언트는 이 메소드를 호출 연결 서버 : 잠금을 수행하는 중간 단계를 생성한다. 2.서버에서 잠금 과 다른 점은 서버를 변경하지 않는 것.  동기화하는 부분을 작게 만들어라 자바에서 synchronized 를 사용하면 락이 설정된다. 락은 스레드를 지연시키고 부하를 가중시키기에 남발은 좋지 않다. 하지만, 임계영역은 반드시 보호해야 하므로 임계영역을 최대한 줄인다.\n올바른 종료 코드는 구현하기 어렵다. 영구적으로 돌아가는 시스템과 잠시 돌다 깔끔하게 종료하는 시스템은 구현하는 방법이 다르다.  깔끔하게 종료하는 코드는 올바로 구현하기가 어렵다. 절대 오지 않을 시그널을 기다리는 데드락 상태가 걸릴 수 있기 때문.\n권장 사항 : 종료 코드를 개발 초기부터 고민하고 동작하게 초기부터 구현하라, 생각보다 오래 걸리고 어렵기에 이미 나온 알고리즘을 검토\n스레드 코드 테스트하기 코드가 올바르다고 증명하기는 현실적으로 불가능하다. 테스트가 정확성을 보장하지는 않지만, 충분한 테스트는 위험을 낮춘다.\n  말이 안되는 실패는 잠정적인 스레드 문제로 취급하라 다중 스레드 코드는 때때로 말이 안되는 오류를 일으킨다. 이 일회성 문제를 계속 무시한다면 잘못된 코드 위에 코드가 쌓인다.\n  다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자 스레드 환경 밖에서 생기는 버그와 스레드 환경에서 생기는 버그를 동시에 디버깅하지 마라. 먼저 스레드 환경 밖에서 코드를 올바로 돌려라.\n  다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있게 스레드 코드를 구현하라 한 스레드로 실행, 다중으로 실행, 실행 중 스레드 수 변경, 환경 변경, 다양한 속도 등.\n  다중스레드를 쓰는 코드 부분을 상황에 맞게 조율할 수 있게 작성해라 적절한 스레드 개수를 파악할면 상당한 시행착오가 필요. 프로그램 처리율과 효율에 따라 스스로 스레드 개수를 조율하는 코드도 고민\n  프로세서 수보다 많은 스레드를 돌려보라 스와핑을 일으키려면 프로세서 수보다 많은 스레드를 돌려야 하고, 스와핑이 잦으면 문제를 일으키는 코드를 찾기 쉬워진다.\n  다른 플렛폼에서 돌려보라 처음부터 그리고 자주 모든 목표 플랫폼에서 코드를 돌려라\n  코드에 보조 코드를 넣어 돌려라. 강제로 실패를 일으키게 해보라 보조 코드를 추가하는 방법은 두 가지 (직접 구현하기, 자동화) 이다. 흔들기 기법을 사용해 오류를 찾아내보자\n  사견을 덧붙이면\u0026hellip;? 어렵다! 이 한 마디로 표현이 가능할 것 같다.  처음 자바를 공부할 때도 이 부분이 어려웠고, 현업 개발자인 지금도 스레드 관련 부분은 어렵다.  물론 개념은 알고 있다. 하지만 항상 그렇듯 이론과 실제의 갭이랄까, 현업에서 스레드를 다뤄본 기억이 그렇게 있진 않다.  그렇기 때문에 지금도 어렵다고 생각하는 것이고, 이번의 동시성 얘기도 아, 그렇구나 하는 정도로 읽었다.  정리할 때는 어느 정도 이해를 바탕으로 정리를 하는데, 이번에는 내용도 길고 퇴근 후 짬짬히 읽고 정리하는 수준이라 이틀에 걸쳐 정리하였다.  그리고 이 스레드 라는게 면접 단골 질문이기도 해서, 추후에 멀티 스레드 및 테스트에 관한 글을 또 정리할 예정이다. \n"
},
{
	"uri": "https://ysjune.github.io/posts/clean-code/chapter2/",
	"title": "2. 의미 있는 이름",
	"tags": [],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "2. 의미 있는 이름 의도를 분명히 밝혀라 로직이 간단한 것보단, 이름이 간단 명료한 것이 좋다. \n그릇된 정보를 피하라 유사한 개념은 유사한 표기법을 사용한다. 일관성이 떨어지는 표기법은 그릇된 정보이다. 개발자는 대부분 (객체에 달린 상세한 주석이나 제공하는 다른 목록을 보고 선택하기 보다는 이름만 보고 객체를 선택하는 경우가 대다수이다.) \n의미있게 구분하라 customerInfo 와 customer / accountData 와 account 는 구분이 가지 않는다. 읽는 사람이 차이를 알도록 이름을 지어라. \n발음하기 쉬운 이름을 사용하라 genymdhms (generate date, year, month, day, hour, minute, second) 라는 단어의 조합은 발음하기도 어렵고, 토론하기도 어렵다. \n검색하기 쉬운 이름을 사용하라 이름을 의미있게 지으면 함수가 길어지긴 하지만, 찾기는 쉬워진다. 그냥 상수나 글자 하나의 변수를 사용하는 것보단 훨씬 낫다. \n자신의 기억력을 자랑하지 마라 일반적으로 문제 영역이나 해법 영역에서 사용하지 않고,  자신이 아는 이름으로 변수를 작성한다면 나중에 문제가 생기기 마련이다. for 등을 사용하는 반복문을 제외하고는 i,j,k 등을 사용하지 않는 것이 바람직하다. \n클래스 이름 클래스 이름과 객체 이름은 명사나 명사구가 적합하다.  Customer, Account 등.. Info 등과 같은 단어는 피하고, 동사는 사용하지 않는다. \n매서드 이름 매서드 이름은 동사나 동사구가 적합하다.  postPayment, deletePage 등이 좋은 예이다. \n기발한 이름은 피하라 재미난 이름보다 명료한 이름을 선택하는 것이 좋다. \n한 개념에 한 단어를 사용하라 추상적인 개념 하나에는 단어 하나를 선택해 이를 고수해라.  예를 들어 똑같은 클래스마다 get, fetch, retrieve 등을 사용하면 혼란을 야기할 수 있다. \n말장난을 하지 마라 한 단어를 두 가지 목적으로 사용하지 마라.  예를 들어 add 라는 기존에는 두 값을 더해서 값을 구하는 메소드가 있을 때,  집합에 값 하나를 추가하는 메소드는 add 와는 맥락이 다르므로 insert 나 append 라는 이름이 적당하다. \n해법영역에서 가져온 이름을 사용하라 코드를 작성하는 사람도 코드를 읽는 사람도 프로그래머이다. 기술 개념에는 기술 이름이 가장 적합한 선택이다.  Ex) singleton, factory \n불필요한 맥락은 없애라 예를 들어 휘발유 충전소 라는 애플리케이션을 만든다고 해서 모든 클래스 앞에 GSD 를 붙인다면 이는 불필요한 맥락이다. \n결론 우리들 대다수는 자신이 짠 클래스 이름과 매서드 이름을 모두 암기하지 못한다.  그렇기 때문에 문장이나 문단처럼 읽히는 코드 아니면, 적어도 표나 자료 구조처럼 읽히는 코드를 짜는 데에 집중해야 한다. \n사견을 덧붙이면\u0026hellip;? 개인적으로는 가장 공감하면서도 지키려고 하는 챕터의 내용이다.  그리고.. 어려운 부분이기도 하다.  여러 주의점들이 있겠지만, 나에게는  특히 말장난을 하지 마라 이 부분이 가장 주의해야 할 부분이 아닌가 싶다.  개인적으로 스프링으로 개발을 할 때,  서비스 계층은 add 등의 일반적인 용어를 사용하고 Persistent 계층은 DB 친화적인 단어를 사용하여 insert 를 사용한다.  그러다보면 종국에는 만능 add 와 만능 insert 가 되는 느낌이 들곤 하는데\u0026hellip;  내 나름대로도 어떤 상황에서는 어떤 단어로 통일하자는 그런 개념? 이 확립되어야 할 것 같다.\n"
},
{
	"uri": "https://ysjune.github.io/posts/clean-code/chapter3/",
	"title": "3. 함수",
	"tags": [],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "3. 함수 작게 만들어라  중첩 구조가 생길만큼 함수가 커져서는 안된다는 뜻이다.  함수에서 들여쓰기 수준은 1단이나 2단을 넘어서면 안 된다.  당연한 말이지만, 그래야 함수는 읽고 이해하기 쉬워진다. \n한 가지만 해라 함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다.  그 한 가지만을 해야 한다. \n함수 당 추상화 수준은 하나로 함수가 확실히 한 가지 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일해야 한다.  한 함수 내에 추상화 수준을 섞으면 코드를 읽는 사람이 헷갈린다.  특정 표현이 근본 개념인지, 아니면 세부사항인지 구분하기 어려운 탓이다.  그리고 구분하기 어려워지면 세부사항에 세부사항을 더 붙이는 복잡한 함수가 된다. \n위에서 아래로 내려가기 규칙 코드는 위에서 아래로 이야기처럼 읽혀야 좋다.  한 함수 다음에는 추상화 수준이 한 단계 낮은 함수가 온다,  즉 위에서 아래로 프로그램을 읽으면 함수 추상화 수준이 한 번에 한 단계씩 낮아진다. \n서술적인 이름을 사용하라 testableHtml -\u0026gt; SetupTeardownIncluder 좋은 이름이 주는 가치는 강조해도 모자르지 않다. \n함수 인수 함수에서 이상적인 인수 개수는 0개(무항) 이다.  다음은 1개, 다음은 2개이다. 3항은 가능하면 피하는 것이 좋고, 4항 이상일 경우에는 특별한 이유가 필요하다.  그리고 특별한 이유가 있어도 사용하길 지양한다. \n부수 효과를 일으키지 마라! 함수에서 한 가지를 하겠다고 약속하고선 남 몰래 다른 일을 한다.  이는 때로 예상치 못한 변수가 발생할 수 있다. \n명령과 조회를 분리하라 함수는 뭔가를 수행하거나 뭔가에 답하거나 둘 중 하나만 해야 한다.  객체 상태를 변경하거나 아니면 객체 정보를 반환하거나 둘 중 하나다. 둘 다 하면 혼란을 초래한다. \n오류 코드보다 예외를 사용하라 if 를 사용해서 오류 코드를 뽑아 처리하기 보다는 try/catch 문을 사용해라, 하지만 try/catch 문도 하나의 함수 안에 정상 동작과 오류 동적을 뒤섞기 때문에 catch 부분을 별도의 함수로 뽑아 내는 편이 좋다. \n반복하지 마라 (DRY : Don't Repeat Yourself) 코드 길이가 늘어날 뿐만 아니라 하나의 알고리즘이 변하면 네 곳이나 손봐야 한다.  게다가 오류가 발생할 확률도 몇 배나 높다. \n결론 시스템은 풀어나가야할 하나의 큰 이야기라고 할 수 있다.  함수를 잘 만드는 기교도 중요하지만,  분명하고 정확한 언어로 깔끔하게 맞아떨어져야 이야기를 풀어나가기가 쉬워진다는 사실 또한 기억해야 한다. \n사견을 덧붙이면\u0026hellip;? 이번 장은 함수에 대한 얘기였다. 주 언어가 자바인 나에게는 메소드 라고 할 수 있을 것 같다.  읽으면서 가장 기억에 남는 부분은 아무래도 함수 인수 이 부분인데, 이유인 즉  전 회사에서 코어를 담당하는 메소드의 파라미터가 무려 10개 였다!!!  길이도 길어서 볼 때마다 어려운 코드였고, 아에 대놓고 null 이 들어가는 인수도 있었다. 정말 이해하기 힘들고 어려워서 항상 저걸 쪼개고 싶다는 생각을 했는데\u0026hellip;  테스트도 없고 그 부분을 건드릴 깜냥(?)이 안되서 결국 나올 때까지 못 건드리고 나왔다.  그 후에는 유닛 테스트도 진행하고 나름 재밌게 하고 있다.  책에서도 나오지만 유닛테스트를 하다보면 assertEqual() 을 사용할 때가 있다. expected 와 actual 의 순서가 헷갈리곤 하는데 다행이도 인텔리 제이에서는 파라미터에 대한 설명(?) 이랄까 그런게 잘 나오더라\n"
},
{
	"uri": "https://ysjune.github.io/posts/clean-code/chapter4/",
	"title": "4. 주석",
	"tags": [],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "4. 주석 나쁜 코드에 주석을 달지 마라. 새로 짜라 주석은 나쁜 코드를 보완하지 못한다. 코드에 주석을 추가하는 일반적인 이유는 코드 품질이 나쁘기 때문이다.  주석을 달기보단, 그 코드를 깔끔하게 개선하는데에 시간을 투자해라.\n코드로 의도를 표현하라! if(employee.isEligibleForFullBenenfits() 같이 주석을 대신해 함수로 충분히 표현이 가능하다.\n좋은 주석 하지만 어떤 주석은 필요로 한다. 그 주석의 종류를 열거하자면, \n  법적인 주석 - 회사가 정립한 구현 표준에 맞춰 법적인 이유로 특정 주석을 넣는 경우\n  정보를 제공하는 주석 - 기본적인 정보를 주석으로 제공하면 편리함. 혹은 파라미터 등에서 어떤 포멧인지 (하지만, 필수는 아님. 함수명을 변경함으로 충분히 대체 가능)\n  의도를 설명하는 주석 - 구현을 이해하게 도와주는 형태의 주석, 주로 저자의 구현 의도가 드러나는 주석이라 할 수 있다.\n  의미를 명료하게 밝히는 주석 - 모호한 인수나 반환값을 읽기 좋게 표현하는 것\n  결과를 경고하는 주석 - 특정 테스트 케이스에서 실행할 경우 문제가 생길 수 있다는 것을 설명해주는 것\n  TODO 주석 - 때로는 앞으로 할 일을 남겨놓을 필요가 있기 때문에 사용한다.  하지만, 시스템에 나쁜 코드를 남겨 놓는 핑계가 되어서는 안된다.\n  나쁜 주석 대다수의 주석이 이 범주 안에 속하며, 허술한 코드를 변명하는 것에 지나지 않는다.\n  주절거리는 주석 - 의무감 혹은 프로세스에 의해서 주석을 다는 경우는 시간 낭비이다. 주석을 달기로 했으면 충분한 시간을 들여 최고의 주석을 달도록 노력한다.\n  같은 이야기를 중복하는 주석 - 헤더에 달린 주석이 같은 코드 내용을 그대로 중복하면 자칫 코드를 읽는데 시간이 더 소요될 수 있다.\n  오해할 여지가 있는 주석 - 분기 처리 등에서 설명이 살짝 부족한 경우 충분히 오해의 소지가 있어, 관련 기능을 포함하여 테스트 혹은 개발을 할 때 문제가 생길 여지가 다분하다.\n  의무적으로 다는 주석 - 무조건적으로 다는 주석은 코드를 복잡하게 만들며, 거짓말을 퍼뜨리고 혼동을 줄 여지가 충분하다.\n  있으나 마나 한 주석 - 너무 당연한 사실을 언급하며 새로운 정보를 제공하지 못하는 주석 ex) // 생성자\n  함수나 변수로 표현할 수 있다면 주석을 달지 마라 닫는 괄호에 다는 주석 때로는 괄호가 닫히는 곳에 주석을 달곤 하는데 (주로 반복이 중첩되거나, 여러 분기가 있는 경우) ,  괄호에 주석을 달아야 겠다고 생각한다면, 그 에너지를 함수를 줄이는 것에 사용하자.\n저자를 표시하는 주석 근래의 소스 코드 관리 시스템은 누가 언제 무엇을 추가했는지 귀신처럼 기억한다.  그러므로 굳이 주석을 달아서 코드를 오염시킬 필요가 없다.\n주석으로 처리한 코드 주석으로 처리된 코드는 다른 사람들이 지우기를 주저한다. 우리는 우수한 소스 관리 시스템을 사용하기 때문에, 굳이 주석으로 남길 필요가 없다. 그냥 코드를 삭제해라, 코드를 잃어버릴 염려는 없다.\n전역 정보 주석을 달아야 한다면 근처에 있는 코드만 기술하라. 전역적인 정보를 기술하지 마라.  만약 전역정보가 변한다고 해도, 그 주석에 있는 전역 정보에 대한 서술이 바뀔 가능성은 낮다.\n모호한 관계 주석을 달았다면 적어도 독자가 주석과 코드를 읽어보고 무슨 소린지 알아야 한다.  주석 자체가 다시 설명을 요구한다면, 그것은 잘못된 주석이다.\n사견을 덧붙이면\u0026hellip;? 나는 변수와 메소드 명을 중요시 하게 여긴다.  개발자라면, 코드로 의도를 전달할 수 있어야 한다고 생각하기에 주석은 가급적 피하는 편이다.  그리고 이번 장은 그런 나의 의도와 잘 맞는 장이라고 할 수 있겠다. 책에서도 나오는 얘기지만, 예전에는 해당 함수 등의 내용이 변경되면 기존 코드를 주석으로 해놓고, 새 기능을 작성했다. 아까워서 그랬는지, 나중에 쓸까봐 그랬는지는 지금와서는 잘 기억이 안 나지만(아마 후자가 아닐까 한다.) 이제는 미련없이 지운다. 경험상 그 주석 처리한 코드를 쓴 일은 없었고(짧은 경험이긴 하지만\u0026hellip;.), 설사 쓴다해도 되돌리면 그만이다.  그리고 혼자 개발하다보니 당장 좋은 방법이 생각 안나거나 할 때 TODO,FIXME 등을 꽤 애용하는 편인데(미래의 나야 부탁해)  책에서도 언급했듯이 TODO 떡칠을 항상 경계해야 할 것 같다.\n"
},
{
	"uri": "https://ysjune.github.io/posts/clean-code/chapter5/",
	"title": "5. 형식 맞추기",
	"tags": [],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "5. 형식 맞추기 형식을 맞추는 목적 오늘 구현한 기능이 다음 버전에서 바뀔 확률은 매우 높다.  그리고 오늘 구현한 코드의 가독성은 앞으로 바뀔 코드의 품질에 지대한 영향을 미친다. 오랜 시간이 지나 원본을 찾기 힘들정도로 코드가 변해도 맨 처음 잡아놓은 구현 스타일과 가독성 수준은 계속 영향을 미친다.\n적절한 행 길이를 유지하라 200줄 정도인 파일로도 커다란 시스템을 구축할 수 있다. (그만큼 모듈화가 되어있다는 뜻)  일반적으로 큰 파일보다 작은 파일이 이해하기 쉽다.\n신문 기사처럼 작성하라 최상단에 기사를 몇 마디로 요약하는 표제가 나온다.  독자는 표제를 보고서 기사를 읽을지 말지 결정한다.  첫 문단은 전체 기사 내용을 요약한다. 세세한 사실은 숨기고 커다란 그림을 보여준다.  쭉 읽으며 내려가면 세세한 사실이 조금씩 드러난다. 날짜, 이름, 발언, 주장, 기타 세부 사항이 나온다.\n개념은 빈 행으로 분리하라 빈 행은 새로운 개념을 시작한다는 시각적 단서다.  코드를 읽어 내려가다 보면 빈 행 바로 다음 줄에 눈길이 멈추게 된다.\n수직 거리 서로 밀접한 개념은 세로로 가까이 둬야 한다.  물론 두 개념이 서로 다른 파일에 속한다면 규칙이 통하지 않는다.  하지만 타당한 근거가 없다면 서로 밀접한 개념은 한 파일에 속해야 마땅하다.  연관성이 깊은 두 개념이 멀리 떨어져 있으면 코드를 읽는 사람이 소스 파일과 클래스를 여기저기 뒤지게 된다.\n 변수 선언 : 변수는 사용하는 위치에 최대한 가까이 선언 인스턴스 변수 : 클래스 맨 처음에 선언 (이유인 즉, 잘 설계한 클래스는 많은 클래스 매서드가 인스턴스 변수를 사용하기 떄문) 종속 함수 : 한 함수가 다른 함수를 호출한다면 두 함수는 세로로 가까이 배치한다. 또한, 가능하다면 호출하는 함수를 호출되는 함수보다 먼저 배치한다.  가로 형식 맞추기 통계적으로 봤을 때, 20 ~ 60자의 행이 총 행 수의 40%, 10자 미만은 30% 정도이다.\n가로 공백과 밀집도 가로로는 공백을 사용해 밀접한 개념과 느슨한 개념을 표현한다.\n들여쓰기 들여쓰기 한 파일은 구조가 한 눈에 들어온다.  반면에 들여쓰기를 하지 않은 코드는 열심히 분석하지 않는 한 거의 불가능하다.\n사견을 덧붙이면\u0026hellip;? 책으로 보면 이번 챕터는 코드가 많고, 짧은 느낌이 있다. 하지만 내용면에서는 충분하다.  한 마디로 말하자면 가독성 이 하나로 충분하지 않을까  그러고보면 이 형식맞추기라는 측면은 학부생때부터 계속 고민해온 사항이기도 하다.  예전에 국비 교육을 들었을 때, 반복문과 지역 변수들 사이의 개행에 관해 어떤 게 보기 좋을지 강사님한테 물었던 기억이 있다.  당시 강사님이 했던 말씀이 \u0026ldquo;보통 그런 경우는 의미 단위로 개행을 한다.\u0026rdquo; 라고 비스무리 하게 말하셨던 거 같고, 덧붙여  경험이 쌓이면, 좀 더 쉽게 개행할 수 있을 거라고 하셨던 거 같은데.. (큰일이다 2년 정도밖에 안 지났는데도 기억이 잘 안나는거보니)\n"
},
{
	"uri": "https://ysjune.github.io/posts/clean-code/chapter6/",
	"title": "6. 객체와 자료 구조",
	"tags": [],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "6. 객체와 자료 구조 자료 추상화 자료를 세세하게 공개하기보다는 추상적인 개념으로 표현하는 것이 좋다.  인터페이스나 조회/설정 함수만으로는 추상화가 이뤄지지 않는다.  개발자는 객체가 포함하는 자료를 표현할 가장 좋은 방법을 심각하게 고민해야 한다.  아무 생각 없이 조회/설정 함수를 추가하는 방법이 가장 나쁘다.\n자료/객체 비대칭 객체와 자료 구조는 근본적으로 양분된다.  객체 지향 코드에서 어려운 변경은 절차적인 코드에서 쉬우며,  절차적인 코드에서 어려운 변경은 객체 지향 코드에서 쉽다.  복잡한 시스템을 짜다보면 새로운 함수가 아니라 새로운 자료 타입이 필요한 경우가 생기는데,  이 때는 클래스와 객체 지향 기법이 가장 적합하다.  반면, 새로운 자료 타입이 아니라 새로운 함수가 필요한 경우도 있는데, 이 때는 절차적인 자료 구조가 좀 더 적합하다.\n디미터 법칙 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙\n기차 충돌  final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();\n 위와 같은 형태(꼬리에 꼬리를 무는 형태) 를 기차 충돌이라 하며, 지양해야 하는 방법이다.  하지만, 디미터의 법칙을 위반하느냐 하면 그건 확실히 알 수가 없다.  객체일 경우에는 위반하는 것이 되지만(객체라면 내부 구조를 숨겨야 하므로),  자료 구조라면 당연히 내부 구조를 노출하므로 디미터 법칙이 적용되지 않는다. But, final String outputDir = ctxt.options.scratchDir.absolutePath 였다면, 논란이 필요없다.\n잡종 구조 객체와 자료구조의 형태가 섞인 구조로 새로운 함수는 물론이고 새로운 자료 구조도 추가하기 어렵다.  양쪽에서 단점만 모와놓은 구조라 볼 수 있다.  함수나 타입을 보호할지 공개할지 확신하지 못해 어중간하게 내놓은 설계에 불과\n자료 전달 객체 자료 구조체의 전형적인 형태는 공개 변수만 있고, 함수가 없는 클래스다.  이런 자료 구조체를 떄로는 자료 전달 객체 Data Transfer Object (DTO) 라 한다.  그리고 좀 더 일반적인 형태는 빈(bean) 구조이다. 빈은 private 변수를 조회/설정 함수로 조작한다.  일종의 사이비 캡슐화로 별다른 이익을 제공하지 않는다.\n활성 레코드 DTO 의 특수한 형태이다. DTO + save/find 같은 함수도 제공한다.  활성 레코드는 데이터베이스 테이블이나 다른 소스에서 자료를 직접 변환한 결과다.  이런 레코드에 비지니스 규칙 메서드를 추가할 경우 잡종이 되므로, 활성 레코드는 자료 구조로 취급하고, 비즈니스 구조는 따로 가져간다.\n결론 객체는 동작을 공개하고 자료를 숨긴다.  그래서 기존 동작을 변경하지 않으면서 새 객체 타입을 추가하기는 쉬운 반면,  기존 객체에 새 동작을 추가하기는 어렵다.  자료 구조는 별다른 동작 없이 자료를 노출한다.  그래서 기존 자료 구조에 새 동작을 추가하기는 쉬우나, 기존 함수에 새 자료 구조를 추가하기는 어렵다.  어떤 시스템을 구현할 때 새로운 자료 타입을 추가하는 유연성이 필요하면 객체가,  다른 경우로 새로운 동작을 추가하는 유연성이 필요하면 자료 구조와 절차적인 코드가 더 적합하다.  결국 이렇다 하는 정답은 없는 것이다.\n사견을 덧붙이면\u0026hellip;? 이번 장의 내용은 짧다. 정말 짧지만, 이해하는 데에는 꽤나 많은 시간이 들었던 장이다.  특히 앞 장의 객체와 자료구조를 읽으면서\u0026hellip; 내가 평소에 만드는게 객체 인지 자료구조인지\u0026hellip;  이게 이건가? 저게 이건가? 하면서 명확하지 않은 채로 읽었기 때문이다. (일단 처음엔 읽는다, 이해가 안되도 그냥)  뒤로 가면서 익숙한게 나와서 그나마 좀 명확해졌는데, 그 부분이 바로 자료 전달 객체 이 부분이다.  완전 쌩신입 때의 나는 그저 DTO 만 만들었고 (그러다가 본 건 있어서 잡종 구조가 된 것 같기도 하다.)  최근까진 이게 클래스, 객체, 빈 다 총칭하는 줄 알았다.  이제는 둘의 차이점도 알았겠다. 최대한 잡종 구조는 지양, 경계하면서 코딩해야겠다.\n"
},
{
	"uri": "https://ysjune.github.io/posts/clean-code/chapter7/",
	"title": "7. 오류 처리",
	"tags": [],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "7. 오류 처리 오류 코드보다 예외를 사용하라 오류 처리 코드와 호출하여 논리를 진행하는 코드가 섞이면 알아보기가 어렵다.  논리가 뒤섞여 있기 때문.\ntry/catch/finally 문부터 작성하라 try 블록에 들어가는 코드를 실행하면 어느 시점에서든 실행히 중단된 후 catch 블록으로 넘어갈 수 있다.  어떤 면에서 catch 블록은 트랜잭션과 비슷하다.  try 블록에서 무슨 일이 생기든 catch 블록은 프로그램 상태를 일관성 있게 유지해야 한다.  먼저 강제로 예외를 일으키는 테스트 케이스를 작성한 후 테스트를 통과하게 코드를 작성하는 방법을 권장한다.\n미확인 예외를 사용하라 확인된 예외를 할 경우 최하위 (연쇄반응에서의 마지막) 함수에서 확인된 예외를 던질 경우  상위 함수에서는 그 예외를 알아야 하고, 결론적으로 캡슐화가 깨지게 되는 현상이 발생한다.  일반적인 애플리케이션은 의존성이라는 비용이 이익보다 크다.\n예외에 의미를 제공하라 예외를 던질 때는 전후 상황을 충분히 덧붙인다.  그러면 오류가 발생한 원인과 위치를 찾기 쉬워진다. 즉, catch 문에 logger 등을 사용\n호출자를 고려해 예외 클래스를 정의하라 애플리케이션에서 오류를 정의할 때 프로그래머에게 가장 중요한 관심사는 오류를 잡아내는 방법이 되어야 한다.  대다수 상황에서 우리가 오류를 처리하는 방식은 (오류를 일으킨 원인과 무관하게) 비교적 일정하다. \n 오류를 기록 프로그램을 계속 수행해도 좋은지..  외부 라이브러리를 사용할 경우 외부 라이브러리에서 나올 에러를 예외처리 하기보단 외부 라이브러리 자체를 예외 처리해라.  그래야 외존성도 좋고 갈아타는 비용도 적다  null 을 반환하지 마라 null 체크를 기반으로 돌아가는 코드는 엄밀히 말하자면 나쁜 코드다.  null 을 반환하는 코드는 일거리를 늘릴 뿐만 아니라 호출자에게 문제를 떠넘긴다.  누구 하나라도 null 체크를 빼먹는다면 애플리케이션이 통제 불능에 빠질지도 모른다.  매서드에서 null 을 반환하고픈 유혹이 든다면 그 대신에 예외를 던지거나 특수 사례 객체를 반환한다.  그리고 자바에선 Collections.emptyList() 가 있어 미리 정의된 읽기 전용 리스트를 반환한다.\nnull 을 전달하지 마라 메서드에 null 을 반환하는 방식도 나쁘지만, 메서드로 null 을 전달하는 방식은 더 나쁘다.  정상적인 인수로 null 을 받는 API 가 아니라면 null 을 넘기는 것은 최대한 지양해라.  대다수 프로그래밍 언어는 호출자가 실수로 null 을 넘겼을 때 적절히 처리하는 방법이 없다.  그렇다면 애초에 null 을 넘기지 못하게 하는 것이 합리적이다.  즉, 인수로 null 이 넘어오면 코드에 문제가 있다는 말이다.\n결론 깨끗한 코드는 읽기 좋아야 하지만, 안정성도 높아야 한다. 그리고 이 둘은 상충하는 목표가 아니다. 오류 처리를 프로그램 논리와 분리하면 독립적인 추론이 가능해지며 코드 유지보수성도 높아진다.\n사견을 덧붙이면\u0026hellip;? 글쎄.. 배울 때부터 try-catch 문을 사용하도록 배워서 그런지, 오히려 오류 코드라는 게 더 생소했다. null 에 관련해서는 에피소드가 떠오르는게 꽤 된다.  전 회사에서 코드 품질인증인지 뭔지를 받는다고 소스를 검증 업체에 넘긴 적이 있다.  거기서 많이 나왔던 지적 사항이 null 체크를 안한다는 것이었다. 그래서 당시에 엄청난 야근을 하면서(\u0026hellip;) null 체크 로직을 넣곤 했다.  당시엔 뭣도 모르는 신입 시절이라 하라는대로 했지만, 지금 생각해보면 그런 체크를 일일히 넣어줬어야 했던 코드인가? 에 대해서는 좀 의문이 든다.  그리고 다른 에피소드는 비교적 최근 일인데,  본인이 작업한 소스를 보여주고, 어떻게 리팩토링을 진행했는지 발표하는 그런 리팩토링 스터디에 참가했었다.  그 자리에서 다른 발표자의 자료를 보고 있는데, 마침 눈에 들어 왔던게, null 을 파라미터로 넣고 진행하는 메소드가 눈에 보였다.  왜 null 을 넣었고, 무슨 의도였는지 물어볼까 하다가 시간이 지나서 결국은 못 물어봤던 기억이 있다. (아직까지 생각나는거보니 나는 그런 형태가 되게 싫었나보다.)  내성적이라 말할 타이밍을 놓치고 그냥 넘어가는 경우가 많은데, 이런 부분은 고쳐야 되겠다 싶다.\n"
},
{
	"uri": "https://ysjune.github.io/posts/clean-code/chapter8/",
	"title": "8. 경계",
	"tags": [],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "8. 경계 외부 코드 사용하기 인터페이스 제공자와 인터페이스 사용자 사이에는 특유의 경계가 존재한다.  제공자는 사용성을 높이기 위해 많은 영역에서 지원하려고 하고,  사용자는 본인이 사용하는 쪽의 특화된 기능을 원하기 때문이다.  한 가지 예로 Map 을 보면 유용성이 높지만, 그만큼 위험하기도 하다.  여러 유형의 객체를 지원하지만, 오용의 가능성도 높기 때문.  그렇기에 경계 인터페이스를 여기저기 넘기지 않고,  Map 과 같은 경계 인터페이스를 이용할 때는 이를 이용하는 클래스나 클래스 계열 밖으로 노출되지 않도록 주의한다.\n경계 살피고 익히기 외부 코드를 익히기는 어렵고, 통합하기도 어렵다.  둘을 동시에 하려면 더 어렵다.  그렇기에 우리쪽 코드를 먼저 작성해 외부 코드를 호출하는 대신 먼저 간단한 테스트 케이스를 작성해 외부 코드를 익히는 것을 학습 테스트 라고 하고, 이 학습 테스트는 통제된 환경에서 API를 제대로 이애하는지 확인하는 셈이다.  학습 테스트는 API 를 사용하는 목적에 초점이 있다.\n학습 테스트는 공짜 이상이다 학습 테스트는 투자하는 노력보다 얻는 성과가 더 크다.  실제 코드와 동일한 방식으로 인터페이스를 사용하는 테스트 케이스가 필요하다.  이런 경계 테스트가 있다면 패키지의 새 버전으로 이전하기 쉬워진다.  그렇지 않다면 낡은 버전을 필요 이상으로 오랫동안 사용하려는 유혹에 빠지기 쉽다.\n아직 존재하지 않는 코드를 사용하기 경계와 관련해 또 다른 유형은 아는 코드와 모르는 코드를 분리하는 경계다.  초반에는 경계와 먼 부분부터 구현을 시작하여, 점차 만날 지점에서는 인터페이스를 구현하여 다른 곳과의 경계 부분에 adapter 패턴을 사용하여 붙인다.\n깨끗한 경계 소프트웨어 설계가 우수하다면 변경하는데 많은 투자와 재작업이 필요하지 않다.  엄청난 시간과 노력과 재작업을 요구하지 않는다.  경계에 위치하는 코드는 깔끔히 분리한다. 또한 기대치를 정의하는 테스트 케이스도 작성한다.  통제가 불가능한 외부 패키지에 의존하는 것보다 통제가 가능한 우리 코드에 의존하는 편이 좋다.  자칫하면 외부 코드에 휘둘리기 때문이다. 외부 패키지를 호출하는 코드를 가능한 줄여 경계를 관리하자.  새로운 클래스로 경계를 감싸거나, adapter 패턴을 사용해 인터페이스를 변환하자.\n사견을 덧붙이면\u0026hellip;? 이번 챕터에서는 외부 라이브러리 혹은 외부 API 등과 연결을 할 때, 어떻게 해야할지에 대해서 나와있다.  그리고 학습테스트(유닛테스트) 가 중요하다는 사실을 말하는 장이기도 하다.  이 책을 읽다보면 마틴 파울러의 리팩토링 책과 내용이 겹친다고 느껴지는 부분이 많다. (마치 시중에 있는 많은 자기계발서 와 비슷한..?)  그만큼 중요하지만 익숙해지지 않으면 힘든 것 같다. 나만해도 머리로는 해야지 하면서도 행동은 글쎄\u0026hellip;? 니까  책을 읽으면서 중간에 낡은 버전을 필요 이상으로 오랫동안 사용하려는 유혹에 빠지기 쉽다 라는 부분이 있다.  이전에 이런 경험이 있긴 하다. 타 라이브러리가 핵심 코어로 된 패키지 프로젝트가 있었다. 뭐 여기까지는 좋다. 그럴 수 있으니까.  하지만, 그 패키지에 테스트 케이스는 존재하지 않았고, 물론 리팩토링도 없었다.  그러다보니 시간이 지나면서 군데군데 요구사항 변경에 의한 땜빵만 늘어났고, 결국은 버리고 싶어도 버릴 수 없는 애물단지 같은 느낌이었다.  (왜냐고? 일단, 돌아는 가니까 팔아야지!)  이런 부분을 생각하면 정말 아쉽긴 하다. 하지만, 지금 그 때로 돌아간다고 해도 단위테스트를 만들고 그럴 수 있을 것 같진 않다.  하루살이란 느낌이 강했으니까\u0026hellip;  옆길로 좀 새긴 했지만\u0026hellip; 이번 장에서는 테스트를 통한 경계에 대해 말하기도 하지만, map 과 vo 에 대해서도 생각해볼 수 있는 좋은 장이었다.\n"
},
{
	"uri": "https://ysjune.github.io/posts/clean-code/chapter9/",
	"title": "9. 단위 테스트",
	"tags": [],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "9. 단위 테스트 TDD 의 법칙 3가지  실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다. 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다. 현재 실패하는 테스트를 통화할 정도로만 실제 코드를 작성한다.  깨끗한 코드 유지하기 지저분한 코드를 내놓으나 테스트를 안 하나 오십보 백보이다.  그 이유는 실제 코드가 진화하면 테스트 코드도 변해야 하기 때문이다.  그런데 테스트 코드가 지저분하면 그만큼 수정하기가 어려워진다.  테스트 코드는 실제 코드 못지 않게 중요하다. 테스트 코드는 이류 시민이 아니다.  실제 코드 못지 않게 깨끗하게 짜야 한다.\n테스트는 유연성, 유지보수성, 재사용성을 제공한다. 테스트 코드를 깨끗하게 유지하지 않으면 결국은 잃어버린다.  그리고 테스트 케이스가 없으면 실제 코드를 유연하게 만드는 버팀목도 사라진다.  테스트 케이스가 없다면 모든 변경은 잠정적인 버그다.\n깨끗한 테스트 코드 깨끗한 테스트 코드를 만들려면 세 가지가 필요하다. 가독성!, 가독성!!, 가독성!!!  테스트 코드는 최소의 표현으로 많은 것을 나타내야 한다.\n이중 표준 테스트에 적용하는 표준은 실제 코드에 적용하는 표준과는 확실히 다르다.  단순, 간결, 표현력 풍부해야 하지만, 실제 코드만큼 효율적일 필요는 없다.  실제 환경에서는 절대로 안되지만, 테스트 환경에서는 전혀 문제 없는 방식이 있다.  대게 메모리나 CPU 효율과 관련 있는 경우다. 코드의 깨끗함과는 무관한 케이스이다.\n테스트 당 개념 하나 테스트 함수마다 한 개념만 테스트하라 이것저것 잡다한 개념을 연속으로 테스트하는 긴 함수는 피해야한다.\nF.I.R.S.T  First : 테스트는 빨라야 한다. 테스트가 느리면 자주 돌릴 엄두를 못 내고, 자주 돌리지 않으면 초반에 문제를 찾아내 고치지 못한다. Independent : 각 테스트는 서로 의존하면 안된다. 한 테스트가 다음 테스트가 실행될 환경을 준비해서는 안된다. 각 테스트는 독립적으로 그리고 어떤 순서로 실행해도 괜찮아야 한다. Repeatable : 테스트는 어떤 환경에서도 반복 가능해야 한다. 어느 환경에서든 실행할 수 있어야 한다. 그렇지 않으면 변명거리를 만들게 된다. Self-Validating : 테스트는 부울 값으로 결과를 내야 한다. 성공 아니면 실패다. 통과 여부를 알려고 로그 파일을 읽게 만들어서는 안된다. 테스트가 스스로 성공과 실패를 가늠하지 않는다면 판단은 주관적이 되며 지루한 수작업 평가가 필요하게 된다. Timely : 테스트는 적시에 작성해야 한다. 단위 테스트는 테스트하려는 실제 코드를 구현하기 직전에 구현한다.  결론 사실상 깨끗한 테스트 코드라는 주제는 책 한 권을 할애해도 모자랄 주제다.  테스트 코드는 실제 코드만큼이나 프로젝트 건강에 중요하다.  테스트 코드가 방치디어 망가지면 실제 코드도 망가진다. 테스트 코드를 깨끗하게 유지하자.\n사견을 덧붙이면\u0026hellip;? 테스트 코드까지 왔다. 테스트 코드는 말로만 들었지, 실제로 접해본 건 5개월 정도 전이다.  그 전에는 테스트 코드가 뭔지 몰랐고, 뭔지 안 시점에서는 어떻게 적용해야할지 몰랐다. (뭐, 지금도 잘 하는 건 아니지만)  전 장에서도 언급했지만, 유닛 테스트 하면 역시 리펙토링이 떠오르게 된다.  개인적으로는 리펙토링 스터디를 통해 좋은 테스트 코드 작성법을 알게 된 것 같다.  이전에는 테스트 코드를 한 프로세스를 테스트 한다는 개념으로 작성했었다. 그러다보니 시간이 길게 걸리고 메소드 하나하나에 대한 검증이 쉽지 않았다.  그런 코드를 가지고 발표를 진행하는데 들었던 얘기가 여기에 나와 있는 말과 같다 테스트 당 개념 하나  아마 다른 건 몰라도 이 개념은 계속 지켜나가지 않을까?\n"
},
{
	"uri": "https://ysjune.github.io/categories/clean-code/",
	"title": "clean code",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ysjune.github.io/about/",
	"title": "About",
	"tags": [""],
	"categories": [],
	"series": [""],
	"description": "",
	"content": "Hello! I'm Snack. Web Programmer\nMain Language is JAVA\nI mainly do server programming through Spring and a little javascript\nNowadays, I'm interested in javascript(typescript), good Domain Architect and Machine learning\nI'm lazy, But Slow and Steady :)\n"
},
{
	"uri": "https://ysjune.github.io/tags/",
	"title": "Tags",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ysjune.github.io/archive/",
	"title": "Archive",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "Archive Page",
	"content": ""
}]